// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated on Thu, 22 Sep 2016 02:14:02 MSK.
// By https://git.io/cgogen. DO NOT EDIT.

package nk

/*
#cgo CFLAGS: -DNK_INCLUDE_FIXED_TYPES=1
#include "nuklear.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"runtime"
	"sync"
	"unsafe"
)

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

func (x PluginAlloc) PassRef() (ref *C.nk_plugin_alloc, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if pluginAlloc88237AC9Func == nil {
		pluginAlloc88237AC9Func = x
	}
	return (*C.nk_plugin_alloc)(C.nk_plugin_alloc_88237ac9), nil
}

func (x PluginAlloc) PassValue() (ref C.nk_plugin_alloc, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if pluginAlloc88237AC9Func == nil {
		pluginAlloc88237AC9Func = x
	}
	return (C.nk_plugin_alloc)(C.nk_plugin_alloc_88237ac9), nil
}

//export pluginAlloc88237AC9
func pluginAlloc88237AC9(carg0 C.nk_handle, cold unsafe.Pointer, carg2 C.nk_size) unsafe.Pointer {
	if pluginAlloc88237AC9Func != nil {
		arg088237ac9 := *(*Handle)(unsafe.Pointer(&carg0))
		old88237ac9 := (unsafe.Pointer)(unsafe.Pointer(cold))
		arg288237ac9 := (Size)(carg2)
		ret88237ac9 := pluginAlloc88237AC9Func(arg088237ac9, old88237ac9, arg288237ac9)
		ret, _ := (unsafe.Pointer)(unsafe.Pointer(ret88237ac9)), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pluginAlloc88237AC9Func PluginAlloc

func (x PluginFree) PassRef() (ref *C.nk_plugin_free, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if pluginFree9E32BB09Func == nil {
		pluginFree9E32BB09Func = x
	}
	return (*C.nk_plugin_free)(C.nk_plugin_free_9e32bb09), nil
}

func (x PluginFree) PassValue() (ref C.nk_plugin_free, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if pluginFree9E32BB09Func == nil {
		pluginFree9E32BB09Func = x
	}
	return (C.nk_plugin_free)(C.nk_plugin_free_9e32bb09), nil
}

//export pluginFree9E32BB09
func pluginFree9E32BB09(carg0 C.nk_handle, cold unsafe.Pointer) {
	if pluginFree9E32BB09Func != nil {
		arg09e32bb09 := *(*Handle)(unsafe.Pointer(&carg0))
		old9e32bb09 := (unsafe.Pointer)(unsafe.Pointer(cold))
		pluginFree9E32BB09Func(arg09e32bb09, old9e32bb09)
		return
	}
	panic("callback func has not been set (race?)")
}

var pluginFree9E32BB09Func PluginFree

// packSTextEdit reads sliced Go data structure out from plain C format.
func packSTextEdit(v []TextEdit, ptr0 *C.struct_nk_text_edit) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStructNkTextEditValue]C.struct_nk_text_edit)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTextEditRef(unsafe.Pointer(&ptr1))
	}
}

type sliceHeader struct {
	Data uintptr
	Len  int
	Cap  int
}

func (x PluginFilter) PassRef() (ref *C.nk_plugin_filter, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if pluginFilter1DF5F22CFunc == nil {
		pluginFilter1DF5F22CFunc = x
	}
	return (*C.nk_plugin_filter)(C.nk_plugin_filter_1df5f22c), nil
}

func (x PluginFilter) PassValue() (ref C.nk_plugin_filter, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if pluginFilter1DF5F22CFunc == nil {
		pluginFilter1DF5F22CFunc = x
	}
	return (C.nk_plugin_filter)(C.nk_plugin_filter_1df5f22c), nil
}

//export pluginFilter1DF5F22C
func pluginFilter1DF5F22C(carg0 *C.struct_nk_text_edit, cunicode C.nk_rune) C.int {
	if pluginFilter1DF5F22CFunc != nil {
		var arg01df5f22c []TextEdit
		packSTextEdit(arg01df5f22c, carg0)
		unicode1df5f22c := (Rune)(cunicode)
		ret1df5f22c := pluginFilter1DF5F22CFunc(arg01df5f22c, unicode1df5f22c)
		ret, _ := (C.int)(ret1df5f22c), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pluginFilter1DF5F22CFunc PluginFilter

func (x PluginPaste) PassRef() (ref *C.nk_plugin_paste, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if pluginPaste70E696C4Func == nil {
		pluginPaste70E696C4Func = x
	}
	return (*C.nk_plugin_paste)(C.nk_plugin_paste_70e696c4), nil
}

func (x PluginPaste) PassValue() (ref C.nk_plugin_paste, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if pluginPaste70E696C4Func == nil {
		pluginPaste70E696C4Func = x
	}
	return (C.nk_plugin_paste)(C.nk_plugin_paste_70e696c4), nil
}

//export pluginPaste70E696C4
func pluginPaste70E696C4(carg0 C.nk_handle, carg1 *C.struct_nk_text_edit) {
	if pluginPaste70E696C4Func != nil {
		arg070e696c4 := *(*Handle)(unsafe.Pointer(&carg0))
		var arg170e696c4 []TextEdit
		packSTextEdit(arg170e696c4, carg1)
		pluginPaste70E696C4Func(arg070e696c4, arg170e696c4)
		return
	}
	panic("callback func has not been set (race?)")
}

var pluginPaste70E696C4Func PluginPaste

// packPCharString creates a Go string backed by *C.char and avoids copying.
func packPCharString(p *C.char) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = uintptr(unsafe.Pointer(p))
		for *p != 0 {
			p = (*C.char)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - h.Data)
	}
	return
}

type stringHeader struct {
	Data uintptr
	Len  int
}

// RawString reperesents a string backed by data on the C side.
type RawString string

// Copy returns a Go-managed copy of raw string.
func (raw RawString) Copy() string {
	if len(raw) == 0 {
		return ""
	}
	h := (*stringHeader)(unsafe.Pointer(&raw))
	return C.GoStringN((*C.char)(unsafe.Pointer(h.Data)), C.int(h.Len))
}

func (x PluginCopy) PassRef() (ref *C.nk_plugin_copy, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if pluginCopy9EA6C143Func == nil {
		pluginCopy9EA6C143Func = x
	}
	return (*C.nk_plugin_copy)(C.nk_plugin_copy_9ea6c143), nil
}

func (x PluginCopy) PassValue() (ref C.nk_plugin_copy, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if pluginCopy9EA6C143Func == nil {
		pluginCopy9EA6C143Func = x
	}
	return (C.nk_plugin_copy)(C.nk_plugin_copy_9ea6c143), nil
}

//export pluginCopy9EA6C143
func pluginCopy9EA6C143(carg0 C.nk_handle, carg1 *C.char, clen C.int) {
	if pluginCopy9EA6C143Func != nil {
		arg09ea6c143 := *(*Handle)(unsafe.Pointer(&carg0))
		arg19ea6c143 := packPCharString(carg1)
		len9ea6c143 := (int32)(clen)
		pluginCopy9EA6C143Func(arg09ea6c143, arg19ea6c143, len9ea6c143)
		return
	}
	panic("callback func has not been set (race?)")
}

var pluginCopy9EA6C143Func PluginCopy

func (x TextWidthF) PassRef() (ref *C.nk_text_width_f, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if textWidthF67477C0Func == nil {
		textWidthF67477C0Func = x
	}
	return (*C.nk_text_width_f)(C.nk_text_width_f_67477c0), nil
}

func (x TextWidthF) PassValue() (ref C.nk_text_width_f, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if textWidthF67477C0Func == nil {
		textWidthF67477C0Func = x
	}
	return (C.nk_text_width_f)(C.nk_text_width_f_67477c0), nil
}

//export textWidthF67477C0
func textWidthF67477C0(carg0 C.nk_handle, ch C.float, carg2 *C.char, clen C.int) C.float {
	if textWidthF67477C0Func != nil {
		arg067477c0 := *(*Handle)(unsafe.Pointer(&carg0))
		h67477c0 := (float32)(ch)
		arg267477c0 := packPCharString(carg2)
		len67477c0 := (int32)(clen)
		ret67477c0 := textWidthF67477C0Func(arg067477c0, h67477c0, arg267477c0, len67477c0)
		ret, _ := (C.float)(ret67477c0), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var textWidthF67477C0Func TextWidthF

func (x QueryFontGlyphF) PassRef() (ref *C.nk_query_font_glyph_f, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if queryFontGlyphF5BA87240Func == nil {
		queryFontGlyphF5BA87240Func = x
	}
	return (*C.nk_query_font_glyph_f)(C.nk_query_font_glyph_f_5ba87240), nil
}

func (x QueryFontGlyphF) PassValue() (ref C.nk_query_font_glyph_f, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if queryFontGlyphF5BA87240Func == nil {
		queryFontGlyphF5BA87240Func = x
	}
	return (C.nk_query_font_glyph_f)(C.nk_query_font_glyph_f_5ba87240), nil
}

//export queryFontGlyphF5BA87240
func queryFontGlyphF5BA87240(chandle C.nk_handle, cfontHeight C.float, cglyph *C.struct_nk_user_font_glyph, ccodepoint C.nk_rune, cnextCodepoint C.nk_rune) {
	if queryFontGlyphF5BA87240Func != nil {
		handle5ba87240 := *(*Handle)(unsafe.Pointer(&chandle))
		fontHeight5ba87240 := (float32)(cfontHeight)
		var glyph5ba87240 []UserFontGlyph
		hxfc4425b := (*sliceHeader)(unsafe.Pointer(&glyph5ba87240))
		hxfc4425b.Data = uintptr(unsafe.Pointer(cglyph))
		hxfc4425b.Cap = 0x7fffffff
		// hxfc4425b.Len = ?

		codepoint5ba87240 := (Rune)(ccodepoint)
		nextCodepoint5ba87240 := (Rune)(cnextCodepoint)
		queryFontGlyphF5BA87240Func(handle5ba87240, fontHeight5ba87240, glyph5ba87240, codepoint5ba87240, nextCodepoint5ba87240)
		return
	}
	panic("callback func has not been set (race?)")
}

var queryFontGlyphF5BA87240Func QueryFontGlyphF

// allocStructNkBufferMemory allocates memory for type C.struct_nk_buffer in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkBufferMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkBufferValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkBufferValue = unsafe.Sizeof([1]C.struct_nk_buffer{})

// allocA2StructNkBufferMarkerMemory allocates memory for type [2]C.struct_nk_buffer_marker in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA2StructNkBufferMarkerMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfA2StructNkBufferMarkerValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfA2StructNkBufferMarkerValue = unsafe.Sizeof([1][2]C.struct_nk_buffer_marker{})

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// unpackA2BufferMarker transforms a sliced Go data structure into plain C format.
func unpackA2BufferMarker(x [2]BufferMarker) (unpacked [2]C.struct_nk_buffer_marker, allocs *cgoAllocMap) {
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(*[2]C.struct_nk_buffer_marker) {
		go allocs.Free()
	})

	mem0 := allocA2StructNkBufferMarkerMemory(1)
	allocs.Add(mem0)
	v0 := (*[2]C.struct_nk_buffer_marker)(mem0)
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	unpacked = *(*[2]C.struct_nk_buffer_marker)(mem0)
	return
}

// packA2BufferMarker reads sliced Go data structure out from plain C format.
func packA2BufferMarker(v *[2]BufferMarker, ptr0 *[2]C.struct_nk_buffer_marker) {
	for i0 := range v {
		ptr1 := ptr0[i0]
		v[i0] = *NewBufferMarkerRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Buffer) Ref() *C.struct_nk_buffer {
	if x == nil {
		return nil
	}
	return x.ref28a0f983
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Buffer) Free() {
	if x != nil && x.allocs28a0f983 != nil {
		x.allocs28a0f983.(*cgoAllocMap).Free()
		x.ref28a0f983 = nil
	}
}

// NewBufferRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBufferRef(ref unsafe.Pointer) *Buffer {
	if ref == nil {
		return nil
	}
	obj := new(Buffer)
	obj.ref28a0f983 = (*C.struct_nk_buffer)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Buffer) PassRef() (*C.struct_nk_buffer, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref28a0f983 != nil {
		return x.ref28a0f983, nil
	}
	mem28a0f983 := allocStructNkBufferMemory(1)
	ref28a0f983 := (*C.struct_nk_buffer)(mem28a0f983)
	allocs28a0f983 := new(cgoAllocMap)
	var cmarker_allocs *cgoAllocMap
	ref28a0f983.marker, cmarker_allocs = unpackA2BufferMarker(x.Marker)
	allocs28a0f983.Borrow(cmarker_allocs)

	var cpool_allocs *cgoAllocMap
	ref28a0f983.pool, cpool_allocs = *(*C.struct_nk_allocator)(unsafe.Pointer(&x.Pool)), cgoAllocsUnknown
	allocs28a0f983.Borrow(cpool_allocs)

	var c_type_allocs *cgoAllocMap
	ref28a0f983._type, c_type_allocs = (C.enum_nk_allocation_type)(x.Type), cgoAllocsUnknown
	allocs28a0f983.Borrow(c_type_allocs)

	var cmemory_allocs *cgoAllocMap
	ref28a0f983.memory, cmemory_allocs = x.Memory.PassValue()
	allocs28a0f983.Borrow(cmemory_allocs)

	var cgrow_factor_allocs *cgoAllocMap
	ref28a0f983.grow_factor, cgrow_factor_allocs = (C.float)(x.GrowFactor), cgoAllocsUnknown
	allocs28a0f983.Borrow(cgrow_factor_allocs)

	var callocated_allocs *cgoAllocMap
	ref28a0f983.allocated, callocated_allocs = (C.nk_size)(x.Allocated), cgoAllocsUnknown
	allocs28a0f983.Borrow(callocated_allocs)

	var cneeded_allocs *cgoAllocMap
	ref28a0f983.needed, cneeded_allocs = (C.nk_size)(x.Needed), cgoAllocsUnknown
	allocs28a0f983.Borrow(cneeded_allocs)

	var ccalls_allocs *cgoAllocMap
	ref28a0f983.calls, ccalls_allocs = (C.nk_size)(x.Calls), cgoAllocsUnknown
	allocs28a0f983.Borrow(ccalls_allocs)

	var csize_allocs *cgoAllocMap
	ref28a0f983.size, csize_allocs = (C.nk_size)(x.Size), cgoAllocsUnknown
	allocs28a0f983.Borrow(csize_allocs)

	x.ref28a0f983 = ref28a0f983
	x.allocs28a0f983 = allocs28a0f983
	return ref28a0f983, allocs28a0f983

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Buffer) PassValue() (C.struct_nk_buffer, *cgoAllocMap) {
	if x.ref28a0f983 != nil {
		return *x.ref28a0f983, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Buffer) Deref() {
	if x.ref28a0f983 == nil {
		return
	}
	packA2BufferMarker(&x.Marker, (*[2]C.struct_nk_buffer_marker)(unsafe.Pointer(&x.ref28a0f983.marker)))
	x.Pool = *(*Allocator)(unsafe.Pointer(&x.ref28a0f983.pool))
	x.Type = (AllocationType)(x.ref28a0f983._type)
	x.Memory = *NewMemoryRef(unsafe.Pointer(&x.ref28a0f983.memory))
	x.GrowFactor = (float32)(x.ref28a0f983.grow_factor)
	x.Allocated = (Size)(x.ref28a0f983.allocated)
	x.Needed = (Size)(x.ref28a0f983.needed)
	x.Calls = (Size)(x.ref28a0f983.calls)
	x.Size = (Size)(x.ref28a0f983.size)
}

// allocStructNkStyleEditMemory allocates memory for type C.struct_nk_style_edit in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkStyleEditMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkStyleEditValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkStyleEditValue = unsafe.Sizeof([1]C.struct_nk_style_edit{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *StyleEdit) Ref() *C.struct_nk_style_edit {
	if x == nil {
		return nil
	}
	return x.refb8d3f26a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *StyleEdit) Free() {
	if x != nil && x.allocsb8d3f26a != nil {
		x.allocsb8d3f26a.(*cgoAllocMap).Free()
		x.refb8d3f26a = nil
	}
}

// NewStyleEditRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewStyleEditRef(ref unsafe.Pointer) *StyleEdit {
	if ref == nil {
		return nil
	}
	obj := new(StyleEdit)
	obj.refb8d3f26a = (*C.struct_nk_style_edit)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *StyleEdit) PassRef() (*C.struct_nk_style_edit, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb8d3f26a != nil {
		return x.refb8d3f26a, nil
	}
	memb8d3f26a := allocStructNkStyleEditMemory(1)
	refb8d3f26a := (*C.struct_nk_style_edit)(memb8d3f26a)
	allocsb8d3f26a := new(cgoAllocMap)
	var cnormal_allocs *cgoAllocMap
	refb8d3f26a.normal, cnormal_allocs = x.Normal.PassValue()
	allocsb8d3f26a.Borrow(cnormal_allocs)

	var chover_allocs *cgoAllocMap
	refb8d3f26a.hover, chover_allocs = x.Hover.PassValue()
	allocsb8d3f26a.Borrow(chover_allocs)

	var cactive_allocs *cgoAllocMap
	refb8d3f26a.active, cactive_allocs = x.Active.PassValue()
	allocsb8d3f26a.Borrow(cactive_allocs)

	var cborder_color_allocs *cgoAllocMap
	refb8d3f26a.border_color, cborder_color_allocs = x.BorderColor.PassValue()
	allocsb8d3f26a.Borrow(cborder_color_allocs)

	var cscrollbar_allocs *cgoAllocMap
	refb8d3f26a.scrollbar, cscrollbar_allocs = x.Scrollbar.PassValue()
	allocsb8d3f26a.Borrow(cscrollbar_allocs)

	var ccursor_normal_allocs *cgoAllocMap
	refb8d3f26a.cursor_normal, ccursor_normal_allocs = x.CursorNormal.PassValue()
	allocsb8d3f26a.Borrow(ccursor_normal_allocs)

	var ccursor_hover_allocs *cgoAllocMap
	refb8d3f26a.cursor_hover, ccursor_hover_allocs = x.CursorHover.PassValue()
	allocsb8d3f26a.Borrow(ccursor_hover_allocs)

	var ccursor_text_normal_allocs *cgoAllocMap
	refb8d3f26a.cursor_text_normal, ccursor_text_normal_allocs = x.CursorTextNormal.PassValue()
	allocsb8d3f26a.Borrow(ccursor_text_normal_allocs)

	var ccursor_text_hover_allocs *cgoAllocMap
	refb8d3f26a.cursor_text_hover, ccursor_text_hover_allocs = x.CursorTextHover.PassValue()
	allocsb8d3f26a.Borrow(ccursor_text_hover_allocs)

	var ctext_normal_allocs *cgoAllocMap
	refb8d3f26a.text_normal, ctext_normal_allocs = x.TextNormal.PassValue()
	allocsb8d3f26a.Borrow(ctext_normal_allocs)

	var ctext_hover_allocs *cgoAllocMap
	refb8d3f26a.text_hover, ctext_hover_allocs = x.TextHover.PassValue()
	allocsb8d3f26a.Borrow(ctext_hover_allocs)

	var ctext_active_allocs *cgoAllocMap
	refb8d3f26a.text_active, ctext_active_allocs = x.TextActive.PassValue()
	allocsb8d3f26a.Borrow(ctext_active_allocs)

	var cselected_normal_allocs *cgoAllocMap
	refb8d3f26a.selected_normal, cselected_normal_allocs = x.SelectedNormal.PassValue()
	allocsb8d3f26a.Borrow(cselected_normal_allocs)

	var cselected_hover_allocs *cgoAllocMap
	refb8d3f26a.selected_hover, cselected_hover_allocs = x.SelectedHover.PassValue()
	allocsb8d3f26a.Borrow(cselected_hover_allocs)

	var cselected_text_normal_allocs *cgoAllocMap
	refb8d3f26a.selected_text_normal, cselected_text_normal_allocs = x.SelectedTextNormal.PassValue()
	allocsb8d3f26a.Borrow(cselected_text_normal_allocs)

	var cselected_text_hover_allocs *cgoAllocMap
	refb8d3f26a.selected_text_hover, cselected_text_hover_allocs = x.SelectedTextHover.PassValue()
	allocsb8d3f26a.Borrow(cselected_text_hover_allocs)

	var cborder_allocs *cgoAllocMap
	refb8d3f26a.border, cborder_allocs = (C.float)(x.Border), cgoAllocsUnknown
	allocsb8d3f26a.Borrow(cborder_allocs)

	var crounding_allocs *cgoAllocMap
	refb8d3f26a.rounding, crounding_allocs = (C.float)(x.Rounding), cgoAllocsUnknown
	allocsb8d3f26a.Borrow(crounding_allocs)

	var ccursor_size_allocs *cgoAllocMap
	refb8d3f26a.cursor_size, ccursor_size_allocs = (C.float)(x.CursorSize), cgoAllocsUnknown
	allocsb8d3f26a.Borrow(ccursor_size_allocs)

	var cscrollbar_size_allocs *cgoAllocMap
	refb8d3f26a.scrollbar_size, cscrollbar_size_allocs = x.ScrollbarSize.PassValue()
	allocsb8d3f26a.Borrow(cscrollbar_size_allocs)

	var cpadding_allocs *cgoAllocMap
	refb8d3f26a.padding, cpadding_allocs = x.Padding.PassValue()
	allocsb8d3f26a.Borrow(cpadding_allocs)

	var crow_padding_allocs *cgoAllocMap
	refb8d3f26a.row_padding, crow_padding_allocs = (C.float)(x.RowPadding), cgoAllocsUnknown
	allocsb8d3f26a.Borrow(crow_padding_allocs)

	x.refb8d3f26a = refb8d3f26a
	x.allocsb8d3f26a = allocsb8d3f26a
	return refb8d3f26a, allocsb8d3f26a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x StyleEdit) PassValue() (C.struct_nk_style_edit, *cgoAllocMap) {
	if x.refb8d3f26a != nil {
		return *x.refb8d3f26a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *StyleEdit) Deref() {
	if x.refb8d3f26a == nil {
		return
	}
	x.Normal = *NewStyleItemRef(unsafe.Pointer(&x.refb8d3f26a.normal))
	x.Hover = *NewStyleItemRef(unsafe.Pointer(&x.refb8d3f26a.hover))
	x.Active = *NewStyleItemRef(unsafe.Pointer(&x.refb8d3f26a.active))
	x.BorderColor = *NewColorRef(unsafe.Pointer(&x.refb8d3f26a.border_color))
	x.Scrollbar = *NewStyleScrollbarRef(unsafe.Pointer(&x.refb8d3f26a.scrollbar))
	x.CursorNormal = *NewColorRef(unsafe.Pointer(&x.refb8d3f26a.cursor_normal))
	x.CursorHover = *NewColorRef(unsafe.Pointer(&x.refb8d3f26a.cursor_hover))
	x.CursorTextNormal = *NewColorRef(unsafe.Pointer(&x.refb8d3f26a.cursor_text_normal))
	x.CursorTextHover = *NewColorRef(unsafe.Pointer(&x.refb8d3f26a.cursor_text_hover))
	x.TextNormal = *NewColorRef(unsafe.Pointer(&x.refb8d3f26a.text_normal))
	x.TextHover = *NewColorRef(unsafe.Pointer(&x.refb8d3f26a.text_hover))
	x.TextActive = *NewColorRef(unsafe.Pointer(&x.refb8d3f26a.text_active))
	x.SelectedNormal = *NewColorRef(unsafe.Pointer(&x.refb8d3f26a.selected_normal))
	x.SelectedHover = *NewColorRef(unsafe.Pointer(&x.refb8d3f26a.selected_hover))
	x.SelectedTextNormal = *NewColorRef(unsafe.Pointer(&x.refb8d3f26a.selected_text_normal))
	x.SelectedTextHover = *NewColorRef(unsafe.Pointer(&x.refb8d3f26a.selected_text_hover))
	x.Border = (float32)(x.refb8d3f26a.border)
	x.Rounding = (float32)(x.refb8d3f26a.rounding)
	x.CursorSize = (float32)(x.refb8d3f26a.cursor_size)
	x.ScrollbarSize = *NewVec2Ref(unsafe.Pointer(&x.refb8d3f26a.scrollbar_size))
	x.Padding = *NewVec2Ref(unsafe.Pointer(&x.refb8d3f26a.padding))
	x.RowPadding = (float32)(x.refb8d3f26a.row_padding)
}

// allocStructNkKeyMemory allocates memory for type C.struct_nk_key in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkKeyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkKeyValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkKeyValue = unsafe.Sizeof([1]C.struct_nk_key{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Key) Ref() *C.struct_nk_key {
	if x == nil {
		return nil
	}
	return x.ref21c21703
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Key) Free() {
	if x != nil && x.allocs21c21703 != nil {
		x.allocs21c21703.(*cgoAllocMap).Free()
		x.ref21c21703 = nil
	}
}

// NewKeyRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewKeyRef(ref unsafe.Pointer) *Key {
	if ref == nil {
		return nil
	}
	obj := new(Key)
	obj.ref21c21703 = (*C.struct_nk_key)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Key) PassRef() (*C.struct_nk_key, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref21c21703 != nil {
		return x.ref21c21703, nil
	}
	mem21c21703 := allocStructNkKeyMemory(1)
	ref21c21703 := (*C.struct_nk_key)(mem21c21703)
	allocs21c21703 := new(cgoAllocMap)
	var cdown_allocs *cgoAllocMap
	ref21c21703.down, cdown_allocs = (C.int)(x.Down), cgoAllocsUnknown
	allocs21c21703.Borrow(cdown_allocs)

	var cclicked_allocs *cgoAllocMap
	ref21c21703.clicked, cclicked_allocs = (C.uint)(x.Clicked), cgoAllocsUnknown
	allocs21c21703.Borrow(cclicked_allocs)

	x.ref21c21703 = ref21c21703
	x.allocs21c21703 = allocs21c21703
	return ref21c21703, allocs21c21703

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Key) PassValue() (C.struct_nk_key, *cgoAllocMap) {
	if x.ref21c21703 != nil {
		return *x.ref21c21703, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Key) Deref() {
	if x.ref21c21703 == nil {
		return
	}
	x.Down = (int32)(x.ref21c21703.down)
	x.Clicked = (uint32)(x.ref21c21703.clicked)
}

// Ref returns a reference to C object as it is.
func (x *UserFontGlyph) Ref() *C.struct_nk_user_font_glyph {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_user_font_glyph)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *UserFontGlyph) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewUserFontGlyphRef converts the C object reference into a raw struct reference without wrapping.
func NewUserFontGlyphRef(ref *C.struct_nk_user_font_glyph) *UserFontGlyph {
	return (*UserFontGlyph)(unsafe.Pointer(ref))
}

// NewUserFontGlyph allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewUserFontGlyph() *UserFontGlyph {
	return (*UserFontGlyph)(allocStructNkUserFontGlyphMemory(1))
}

// allocStructNkUserFontGlyphMemory allocates memory for type C.struct_nk_user_font_glyph in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkUserFontGlyphMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkUserFontGlyphValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkUserFontGlyphValue = unsafe.Sizeof([1]C.struct_nk_user_font_glyph{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *UserFontGlyph) PassRef() *C.struct_nk_user_font_glyph {
	if x == nil {
		x = (*UserFontGlyph)(allocStructNkUserFontGlyphMemory(1))
	}
	return (*C.struct_nk_user_font_glyph)(unsafe.Pointer(x))
}

// allocStructNkCommandBufferMemory allocates memory for type C.struct_nk_command_buffer in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkCommandBufferMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkCommandBufferValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkCommandBufferValue = unsafe.Sizeof([1]C.struct_nk_command_buffer{})

// unpackSBuffer transforms a sliced Go data structure into plain C format.
func unpackSBuffer(x []Buffer) (unpacked *C.struct_nk_buffer, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.struct_nk_buffer) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocStructNkBufferMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_nk_buffer)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_nk_buffer)(unsafe.Pointer(h.Data))
	return
}

// packSBuffer reads sliced Go data structure out from plain C format.
func packSBuffer(v []Buffer, ptr0 *C.struct_nk_buffer) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStructNkBufferValue]C.struct_nk_buffer)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewBufferRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CommandBuffer) Ref() *C.struct_nk_command_buffer {
	if x == nil {
		return nil
	}
	return x.refa28222e0
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CommandBuffer) Free() {
	if x != nil && x.allocsa28222e0 != nil {
		x.allocsa28222e0.(*cgoAllocMap).Free()
		x.refa28222e0 = nil
	}
}

// NewCommandBufferRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCommandBufferRef(ref unsafe.Pointer) *CommandBuffer {
	if ref == nil {
		return nil
	}
	obj := new(CommandBuffer)
	obj.refa28222e0 = (*C.struct_nk_command_buffer)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CommandBuffer) PassRef() (*C.struct_nk_command_buffer, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa28222e0 != nil {
		return x.refa28222e0, nil
	}
	mema28222e0 := allocStructNkCommandBufferMemory(1)
	refa28222e0 := (*C.struct_nk_command_buffer)(mema28222e0)
	allocsa28222e0 := new(cgoAllocMap)
	var cbase_allocs *cgoAllocMap
	refa28222e0.base, cbase_allocs = unpackSBuffer(x.Base)
	allocsa28222e0.Borrow(cbase_allocs)

	var cclip_allocs *cgoAllocMap
	refa28222e0.clip, cclip_allocs = x.Clip.PassValue()
	allocsa28222e0.Borrow(cclip_allocs)

	var cuse_clipping_allocs *cgoAllocMap
	refa28222e0.use_clipping, cuse_clipping_allocs = (C.int)(x.UseClipping), cgoAllocsUnknown
	allocsa28222e0.Borrow(cuse_clipping_allocs)

	var cuserdata_allocs *cgoAllocMap
	refa28222e0.userdata, cuserdata_allocs = *(*C.nk_handle)(unsafe.Pointer(&x.Userdata)), cgoAllocsUnknown
	allocsa28222e0.Borrow(cuserdata_allocs)

	var cbegin_allocs *cgoAllocMap
	refa28222e0.begin, cbegin_allocs = (C.nk_size)(x.Begin), cgoAllocsUnknown
	allocsa28222e0.Borrow(cbegin_allocs)

	var cend_allocs *cgoAllocMap
	refa28222e0.end, cend_allocs = (C.nk_size)(x.End), cgoAllocsUnknown
	allocsa28222e0.Borrow(cend_allocs)

	var clast_allocs *cgoAllocMap
	refa28222e0.last, clast_allocs = (C.nk_size)(x.Last), cgoAllocsUnknown
	allocsa28222e0.Borrow(clast_allocs)

	x.refa28222e0 = refa28222e0
	x.allocsa28222e0 = allocsa28222e0
	return refa28222e0, allocsa28222e0

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CommandBuffer) PassValue() (C.struct_nk_command_buffer, *cgoAllocMap) {
	if x.refa28222e0 != nil {
		return *x.refa28222e0, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CommandBuffer) Deref() {
	if x.refa28222e0 == nil {
		return
	}
	packSBuffer(x.Base, x.refa28222e0.base)
	x.Clip = *NewRectRef(unsafe.Pointer(&x.refa28222e0.clip))
	x.UseClipping = (int32)(x.refa28222e0.use_clipping)
	x.Userdata = *(*Handle)(unsafe.Pointer(&x.refa28222e0.userdata))
	x.Begin = (Size)(x.refa28222e0.begin)
	x.End = (Size)(x.refa28222e0.end)
	x.Last = (Size)(x.refa28222e0.last)
}

// allocStructNkConvertConfigMemory allocates memory for type C.struct_nk_convert_config in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkConvertConfigMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkConvertConfigValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkConvertConfigValue = unsafe.Sizeof([1]C.struct_nk_convert_config{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ConvertConfig) Ref() *C.struct_nk_convert_config {
	if x == nil {
		return nil
	}
	return x.ref82bf4c25
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ConvertConfig) Free() {
	if x != nil && x.allocs82bf4c25 != nil {
		x.allocs82bf4c25.(*cgoAllocMap).Free()
		x.ref82bf4c25 = nil
	}
}

// NewConvertConfigRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewConvertConfigRef(ref unsafe.Pointer) *ConvertConfig {
	if ref == nil {
		return nil
	}
	obj := new(ConvertConfig)
	obj.ref82bf4c25 = (*C.struct_nk_convert_config)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ConvertConfig) PassRef() (*C.struct_nk_convert_config, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref82bf4c25 != nil {
		return x.ref82bf4c25, nil
	}
	mem82bf4c25 := allocStructNkConvertConfigMemory(1)
	ref82bf4c25 := (*C.struct_nk_convert_config)(mem82bf4c25)
	allocs82bf4c25 := new(cgoAllocMap)
	var cglobal_alpha_allocs *cgoAllocMap
	ref82bf4c25.global_alpha, cglobal_alpha_allocs = (C.float)(x.GlobalAlpha), cgoAllocsUnknown
	allocs82bf4c25.Borrow(cglobal_alpha_allocs)

	var cline_AA_allocs *cgoAllocMap
	ref82bf4c25.line_AA, cline_AA_allocs = (C.enum_nk_anti_aliasing)(x.LineAa), cgoAllocsUnknown
	allocs82bf4c25.Borrow(cline_AA_allocs)

	var cshape_AA_allocs *cgoAllocMap
	ref82bf4c25.shape_AA, cshape_AA_allocs = (C.enum_nk_anti_aliasing)(x.ShapeAa), cgoAllocsUnknown
	allocs82bf4c25.Borrow(cshape_AA_allocs)

	var ccircle_segment_count_allocs *cgoAllocMap
	ref82bf4c25.circle_segment_count, ccircle_segment_count_allocs = (C.uint)(x.CircleSegmentCount), cgoAllocsUnknown
	allocs82bf4c25.Borrow(ccircle_segment_count_allocs)

	var carc_segment_count_allocs *cgoAllocMap
	ref82bf4c25.arc_segment_count, carc_segment_count_allocs = (C.uint)(x.ArcSegmentCount), cgoAllocsUnknown
	allocs82bf4c25.Borrow(carc_segment_count_allocs)

	var ccurve_segment_count_allocs *cgoAllocMap
	ref82bf4c25.curve_segment_count, ccurve_segment_count_allocs = (C.uint)(x.CurveSegmentCount), cgoAllocsUnknown
	allocs82bf4c25.Borrow(ccurve_segment_count_allocs)

	var cnull_allocs *cgoAllocMap
	ref82bf4c25.null, cnull_allocs = x.Null.PassValue()
	allocs82bf4c25.Borrow(cnull_allocs)

	var cvertex_layout_allocs *cgoAllocMap
	ref82bf4c25.vertex_layout, cvertex_layout_allocs = (*C.struct_nk_draw_vertex_layout_element)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.VertexLayout)).Data)), cgoAllocsUnknown
	allocs82bf4c25.Borrow(cvertex_layout_allocs)

	var cvertex_size_allocs *cgoAllocMap
	ref82bf4c25.vertex_size, cvertex_size_allocs = (C.nk_size)(x.VertexSize), cgoAllocsUnknown
	allocs82bf4c25.Borrow(cvertex_size_allocs)

	var cvertex_alignment_allocs *cgoAllocMap
	ref82bf4c25.vertex_alignment, cvertex_alignment_allocs = (C.nk_size)(x.VertexAlignment), cgoAllocsUnknown
	allocs82bf4c25.Borrow(cvertex_alignment_allocs)

	x.ref82bf4c25 = ref82bf4c25
	x.allocs82bf4c25 = allocs82bf4c25
	return ref82bf4c25, allocs82bf4c25

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ConvertConfig) PassValue() (C.struct_nk_convert_config, *cgoAllocMap) {
	if x.ref82bf4c25 != nil {
		return *x.ref82bf4c25, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ConvertConfig) Deref() {
	if x.ref82bf4c25 == nil {
		return
	}
	x.GlobalAlpha = (float32)(x.ref82bf4c25.global_alpha)
	x.LineAa = (AntiAliasing)(x.ref82bf4c25.line_AA)
	x.ShapeAa = (AntiAliasing)(x.ref82bf4c25.shape_AA)
	x.CircleSegmentCount = (uint32)(x.ref82bf4c25.circle_segment_count)
	x.ArcSegmentCount = (uint32)(x.ref82bf4c25.arc_segment_count)
	x.CurveSegmentCount = (uint32)(x.ref82bf4c25.curve_segment_count)
	x.Null = *NewDrawNullTextureRef(unsafe.Pointer(&x.ref82bf4c25.null))
	hxf95e7c8 := (*sliceHeader)(unsafe.Pointer(&x.VertexLayout))
	hxf95e7c8.Data = uintptr(unsafe.Pointer(x.ref82bf4c25.vertex_layout))
	hxf95e7c8.Cap = 0x7fffffff
	// hxf95e7c8.Len = ?

	x.VertexSize = (Size)(x.ref82bf4c25.vertex_size)
	x.VertexAlignment = (Size)(x.ref82bf4c25.vertex_alignment)
}

// allocStructNkClipboardMemory allocates memory for type C.struct_nk_clipboard in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkClipboardMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkClipboardValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkClipboardValue = unsafe.Sizeof([1]C.struct_nk_clipboard{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Clipboard) Ref() *C.struct_nk_clipboard {
	if x == nil {
		return nil
	}
	return x.ref564266a3
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Clipboard) Free() {
	if x != nil && x.allocs564266a3 != nil {
		x.allocs564266a3.(*cgoAllocMap).Free()
		x.ref564266a3 = nil
	}
}

// NewClipboardRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewClipboardRef(ref unsafe.Pointer) *Clipboard {
	if ref == nil {
		return nil
	}
	obj := new(Clipboard)
	obj.ref564266a3 = (*C.struct_nk_clipboard)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Clipboard) PassRef() (*C.struct_nk_clipboard, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref564266a3 != nil {
		return x.ref564266a3, nil
	}
	mem564266a3 := allocStructNkClipboardMemory(1)
	ref564266a3 := (*C.struct_nk_clipboard)(mem564266a3)
	allocs564266a3 := new(cgoAllocMap)
	var cuserdata_allocs *cgoAllocMap
	ref564266a3.userdata, cuserdata_allocs = *(*C.nk_handle)(unsafe.Pointer(&x.Userdata)), cgoAllocsUnknown
	allocs564266a3.Borrow(cuserdata_allocs)

	var cpaste_allocs *cgoAllocMap
	ref564266a3.paste, cpaste_allocs = x.Paste.PassValue()
	allocs564266a3.Borrow(cpaste_allocs)

	var ccopy_allocs *cgoAllocMap
	ref564266a3.copy, ccopy_allocs = x.Copy.PassValue()
	allocs564266a3.Borrow(ccopy_allocs)

	x.ref564266a3 = ref564266a3
	x.allocs564266a3 = allocs564266a3
	return ref564266a3, allocs564266a3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Clipboard) PassValue() (C.struct_nk_clipboard, *cgoAllocMap) {
	if x.ref564266a3 != nil {
		return *x.ref564266a3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Clipboard) Deref() {
	if x.ref564266a3 == nil {
		return
	}
	x.Userdata = *(*Handle)(unsafe.Pointer(&x.ref564266a3.userdata))
	// x.Paste is a callback func
	// x.Copy is a callback func
}

// allocStructNkStrMemory allocates memory for type C.struct_nk_str in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkStrMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkStrValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkStrValue = unsafe.Sizeof([1]C.struct_nk_str{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Str) Ref() *C.struct_nk_str {
	if x == nil {
		return nil
	}
	return x.reff7fc1f53
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Str) Free() {
	if x != nil && x.allocsf7fc1f53 != nil {
		x.allocsf7fc1f53.(*cgoAllocMap).Free()
		x.reff7fc1f53 = nil
	}
}

// NewStrRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewStrRef(ref unsafe.Pointer) *Str {
	if ref == nil {
		return nil
	}
	obj := new(Str)
	obj.reff7fc1f53 = (*C.struct_nk_str)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Str) PassRef() (*C.struct_nk_str, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff7fc1f53 != nil {
		return x.reff7fc1f53, nil
	}
	memf7fc1f53 := allocStructNkStrMemory(1)
	reff7fc1f53 := (*C.struct_nk_str)(memf7fc1f53)
	allocsf7fc1f53 := new(cgoAllocMap)
	var cbuffer_allocs *cgoAllocMap
	reff7fc1f53.buffer, cbuffer_allocs = x.Buffer.PassValue()
	allocsf7fc1f53.Borrow(cbuffer_allocs)

	var clen_allocs *cgoAllocMap
	reff7fc1f53.len, clen_allocs = (C.int)(x.Len), cgoAllocsUnknown
	allocsf7fc1f53.Borrow(clen_allocs)

	x.reff7fc1f53 = reff7fc1f53
	x.allocsf7fc1f53 = allocsf7fc1f53
	return reff7fc1f53, allocsf7fc1f53

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Str) PassValue() (C.struct_nk_str, *cgoAllocMap) {
	if x.reff7fc1f53 != nil {
		return *x.reff7fc1f53, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Str) Deref() {
	if x.reff7fc1f53 == nil {
		return
	}
	x.Buffer = *NewBufferRef(unsafe.Pointer(&x.reff7fc1f53.buffer))
	x.Len = (int32)(x.reff7fc1f53.len)
}

// allocStructNkCommandCurveMemory allocates memory for type C.struct_nk_command_curve in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkCommandCurveMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkCommandCurveValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkCommandCurveValue = unsafe.Sizeof([1]C.struct_nk_command_curve{})

// allocA2StructNkVec2iMemory allocates memory for type [2]C.struct_nk_vec2i in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA2StructNkVec2iMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfA2StructNkVec2iValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfA2StructNkVec2iValue = unsafe.Sizeof([1][2]C.struct_nk_vec2i{})

// unpackA2Vec2i transforms a sliced Go data structure into plain C format.
func unpackA2Vec2i(x [2]Vec2i) (unpacked [2]C.struct_nk_vec2i, allocs *cgoAllocMap) {
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(*[2]C.struct_nk_vec2i) {
		go allocs.Free()
	})

	mem0 := allocA2StructNkVec2iMemory(1)
	allocs.Add(mem0)
	v0 := (*[2]C.struct_nk_vec2i)(mem0)
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	unpacked = *(*[2]C.struct_nk_vec2i)(mem0)
	return
}

// packA2Vec2i reads sliced Go data structure out from plain C format.
func packA2Vec2i(v *[2]Vec2i, ptr0 *[2]C.struct_nk_vec2i) {
	for i0 := range v {
		ptr1 := ptr0[i0]
		v[i0] = *NewVec2iRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CommandCurve) Ref() *C.struct_nk_command_curve {
	if x == nil {
		return nil
	}
	return x.ref86b4d23a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CommandCurve) Free() {
	if x != nil && x.allocs86b4d23a != nil {
		x.allocs86b4d23a.(*cgoAllocMap).Free()
		x.ref86b4d23a = nil
	}
}

// NewCommandCurveRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCommandCurveRef(ref unsafe.Pointer) *CommandCurve {
	if ref == nil {
		return nil
	}
	obj := new(CommandCurve)
	obj.ref86b4d23a = (*C.struct_nk_command_curve)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CommandCurve) PassRef() (*C.struct_nk_command_curve, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref86b4d23a != nil {
		return x.ref86b4d23a, nil
	}
	mem86b4d23a := allocStructNkCommandCurveMemory(1)
	ref86b4d23a := (*C.struct_nk_command_curve)(mem86b4d23a)
	allocs86b4d23a := new(cgoAllocMap)
	var cheader_allocs *cgoAllocMap
	ref86b4d23a.header, cheader_allocs = x.Header.PassValue()
	allocs86b4d23a.Borrow(cheader_allocs)

	var cline_thickness_allocs *cgoAllocMap
	ref86b4d23a.line_thickness, cline_thickness_allocs = (C.ushort)(x.LineThickness), cgoAllocsUnknown
	allocs86b4d23a.Borrow(cline_thickness_allocs)

	var cbegin_allocs *cgoAllocMap
	ref86b4d23a.begin, cbegin_allocs = x.Begin.PassValue()
	allocs86b4d23a.Borrow(cbegin_allocs)

	var cend_allocs *cgoAllocMap
	ref86b4d23a.end, cend_allocs = x.End.PassValue()
	allocs86b4d23a.Borrow(cend_allocs)

	var cctrl_allocs *cgoAllocMap
	ref86b4d23a.ctrl, cctrl_allocs = unpackA2Vec2i(x.Ctrl)
	allocs86b4d23a.Borrow(cctrl_allocs)

	var ccolor_allocs *cgoAllocMap
	ref86b4d23a.color, ccolor_allocs = x.Color.PassValue()
	allocs86b4d23a.Borrow(ccolor_allocs)

	x.ref86b4d23a = ref86b4d23a
	x.allocs86b4d23a = allocs86b4d23a
	return ref86b4d23a, allocs86b4d23a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CommandCurve) PassValue() (C.struct_nk_command_curve, *cgoAllocMap) {
	if x.ref86b4d23a != nil {
		return *x.ref86b4d23a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CommandCurve) Deref() {
	if x.ref86b4d23a == nil {
		return
	}
	x.Header = *NewCommandRef(unsafe.Pointer(&x.ref86b4d23a.header))
	x.LineThickness = (uint16)(x.ref86b4d23a.line_thickness)
	x.Begin = *NewVec2iRef(unsafe.Pointer(&x.ref86b4d23a.begin))
	x.End = *NewVec2iRef(unsafe.Pointer(&x.ref86b4d23a.end))
	packA2Vec2i(&x.Ctrl, (*[2]C.struct_nk_vec2i)(unsafe.Pointer(&x.ref86b4d23a.ctrl)))
	x.Color = *NewColorRef(unsafe.Pointer(&x.ref86b4d23a.color))
}

// allocStructNkColorMemory allocates memory for type C.struct_nk_color in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkColorMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkColorValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkColorValue = unsafe.Sizeof([1]C.struct_nk_color{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Color) Ref() *C.struct_nk_color {
	if x == nil {
		return nil
	}
	return x.reff069487f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Color) Free() {
	if x != nil && x.allocsf069487f != nil {
		x.allocsf069487f.(*cgoAllocMap).Free()
		x.reff069487f = nil
	}
}

// NewColorRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewColorRef(ref unsafe.Pointer) *Color {
	if ref == nil {
		return nil
	}
	obj := new(Color)
	obj.reff069487f = (*C.struct_nk_color)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Color) PassRef() (*C.struct_nk_color, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff069487f != nil {
		return x.reff069487f, nil
	}
	memf069487f := allocStructNkColorMemory(1)
	reff069487f := (*C.struct_nk_color)(memf069487f)
	allocsf069487f := new(cgoAllocMap)
	var cr_allocs *cgoAllocMap
	reff069487f.r, cr_allocs = (C.nk_byte)(x.R), cgoAllocsUnknown
	allocsf069487f.Borrow(cr_allocs)

	var cg_allocs *cgoAllocMap
	reff069487f.g, cg_allocs = (C.nk_byte)(x.G), cgoAllocsUnknown
	allocsf069487f.Borrow(cg_allocs)

	var cb_allocs *cgoAllocMap
	reff069487f.b, cb_allocs = (C.nk_byte)(x.B), cgoAllocsUnknown
	allocsf069487f.Borrow(cb_allocs)

	var ca_allocs *cgoAllocMap
	reff069487f.a, ca_allocs = (C.nk_byte)(x.A), cgoAllocsUnknown
	allocsf069487f.Borrow(ca_allocs)

	x.reff069487f = reff069487f
	x.allocsf069487f = allocsf069487f
	return reff069487f, allocsf069487f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Color) PassValue() (C.struct_nk_color, *cgoAllocMap) {
	if x.reff069487f != nil {
		return *x.reff069487f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Color) Deref() {
	if x.reff069487f == nil {
		return
	}
	x.R = (Byte)(x.reff069487f.r)
	x.G = (Byte)(x.reff069487f.g)
	x.B = (Byte)(x.reff069487f.b)
	x.A = (Byte)(x.reff069487f.a)
}

// allocStructNkConfigStackColorMemory allocates memory for type C.struct_nk_config_stack_color in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkConfigStackColorMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkConfigStackColorValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkConfigStackColorValue = unsafe.Sizeof([1]C.struct_nk_config_stack_color{})

// allocA32StructNkConfigStackColorElementMemory allocates memory for type [32]C.struct_nk_config_stack_color_element in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA32StructNkConfigStackColorElementMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfA32StructNkConfigStackColorElementValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfA32StructNkConfigStackColorElementValue = unsafe.Sizeof([1][32]C.struct_nk_config_stack_color_element{})

// unpackA32ConfigStackColorElement transforms a sliced Go data structure into plain C format.
func unpackA32ConfigStackColorElement(x [32]ConfigStackColorElement) (unpacked [32]C.struct_nk_config_stack_color_element, allocs *cgoAllocMap) {
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(*[32]C.struct_nk_config_stack_color_element) {
		go allocs.Free()
	})

	mem0 := allocA32StructNkConfigStackColorElementMemory(1)
	allocs.Add(mem0)
	v0 := (*[32]C.struct_nk_config_stack_color_element)(mem0)
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	unpacked = *(*[32]C.struct_nk_config_stack_color_element)(mem0)
	return
}

// packA32ConfigStackColorElement reads sliced Go data structure out from plain C format.
func packA32ConfigStackColorElement(v *[32]ConfigStackColorElement, ptr0 *[32]C.struct_nk_config_stack_color_element) {
	for i0 := range v {
		ptr1 := ptr0[i0]
		v[i0] = *NewConfigStackColorElementRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ConfigStackColor) Ref() *C.struct_nk_config_stack_color {
	if x == nil {
		return nil
	}
	return x.ref237e1889
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ConfigStackColor) Free() {
	if x != nil && x.allocs237e1889 != nil {
		x.allocs237e1889.(*cgoAllocMap).Free()
		x.ref237e1889 = nil
	}
}

// NewConfigStackColorRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewConfigStackColorRef(ref unsafe.Pointer) *ConfigStackColor {
	if ref == nil {
		return nil
	}
	obj := new(ConfigStackColor)
	obj.ref237e1889 = (*C.struct_nk_config_stack_color)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ConfigStackColor) PassRef() (*C.struct_nk_config_stack_color, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref237e1889 != nil {
		return x.ref237e1889, nil
	}
	mem237e1889 := allocStructNkConfigStackColorMemory(1)
	ref237e1889 := (*C.struct_nk_config_stack_color)(mem237e1889)
	allocs237e1889 := new(cgoAllocMap)
	var chead_allocs *cgoAllocMap
	ref237e1889.head, chead_allocs = (C.int)(x.Head), cgoAllocsUnknown
	allocs237e1889.Borrow(chead_allocs)

	var celements_allocs *cgoAllocMap
	ref237e1889.elements, celements_allocs = unpackA32ConfigStackColorElement(x.Elements)
	allocs237e1889.Borrow(celements_allocs)

	x.ref237e1889 = ref237e1889
	x.allocs237e1889 = allocs237e1889
	return ref237e1889, allocs237e1889

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ConfigStackColor) PassValue() (C.struct_nk_config_stack_color, *cgoAllocMap) {
	if x.ref237e1889 != nil {
		return *x.ref237e1889, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ConfigStackColor) Deref() {
	if x.ref237e1889 == nil {
		return
	}
	x.Head = (int32)(x.ref237e1889.head)
	packA32ConfigStackColorElement(&x.Elements, (*[32]C.struct_nk_config_stack_color_element)(unsafe.Pointer(&x.ref237e1889.elements)))
}

// Ref returns a reference to C object as it is.
func (x *DrawCommand) Ref() *C.struct_nk_draw_command {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_draw_command)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *DrawCommand) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewDrawCommandRef converts the C object reference into a raw struct reference without wrapping.
func NewDrawCommandRef(ref *C.struct_nk_draw_command) *DrawCommand {
	return (*DrawCommand)(unsafe.Pointer(ref))
}

// NewDrawCommand allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewDrawCommand() *DrawCommand {
	return (*DrawCommand)(allocStructNkDrawCommandMemory(1))
}

// allocStructNkDrawCommandMemory allocates memory for type C.struct_nk_draw_command in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkDrawCommandMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkDrawCommandValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkDrawCommandValue = unsafe.Sizeof([1]C.struct_nk_draw_command{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *DrawCommand) PassRef() *C.struct_nk_draw_command {
	if x == nil {
		x = (*DrawCommand)(allocStructNkDrawCommandMemory(1))
	}
	return (*C.struct_nk_draw_command)(unsafe.Pointer(x))
}

// allocStructNkCommandArcFilledMemory allocates memory for type C.struct_nk_command_arc_filled in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkCommandArcFilledMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkCommandArcFilledValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkCommandArcFilledValue = unsafe.Sizeof([1]C.struct_nk_command_arc_filled{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CommandArcFilled) Ref() *C.struct_nk_command_arc_filled {
	if x == nil {
		return nil
	}
	return x.reff41e98e9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CommandArcFilled) Free() {
	if x != nil && x.allocsf41e98e9 != nil {
		x.allocsf41e98e9.(*cgoAllocMap).Free()
		x.reff41e98e9 = nil
	}
}

// NewCommandArcFilledRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCommandArcFilledRef(ref unsafe.Pointer) *CommandArcFilled {
	if ref == nil {
		return nil
	}
	obj := new(CommandArcFilled)
	obj.reff41e98e9 = (*C.struct_nk_command_arc_filled)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CommandArcFilled) PassRef() (*C.struct_nk_command_arc_filled, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff41e98e9 != nil {
		return x.reff41e98e9, nil
	}
	memf41e98e9 := allocStructNkCommandArcFilledMemory(1)
	reff41e98e9 := (*C.struct_nk_command_arc_filled)(memf41e98e9)
	allocsf41e98e9 := new(cgoAllocMap)
	var cheader_allocs *cgoAllocMap
	reff41e98e9.header, cheader_allocs = x.Header.PassValue()
	allocsf41e98e9.Borrow(cheader_allocs)

	var ccx_allocs *cgoAllocMap
	reff41e98e9.cx, ccx_allocs = (C.short)(x.Cx), cgoAllocsUnknown
	allocsf41e98e9.Borrow(ccx_allocs)

	var ccy_allocs *cgoAllocMap
	reff41e98e9.cy, ccy_allocs = (C.short)(x.Cy), cgoAllocsUnknown
	allocsf41e98e9.Borrow(ccy_allocs)

	var cr_allocs *cgoAllocMap
	reff41e98e9.r, cr_allocs = (C.ushort)(x.R), cgoAllocsUnknown
	allocsf41e98e9.Borrow(cr_allocs)

	var ca_allocs *cgoAllocMap
	reff41e98e9.a, ca_allocs = *(*[2]C.float)(unsafe.Pointer(&x.A)), cgoAllocsUnknown
	allocsf41e98e9.Borrow(ca_allocs)

	var ccolor_allocs *cgoAllocMap
	reff41e98e9.color, ccolor_allocs = x.Color.PassValue()
	allocsf41e98e9.Borrow(ccolor_allocs)

	x.reff41e98e9 = reff41e98e9
	x.allocsf41e98e9 = allocsf41e98e9
	return reff41e98e9, allocsf41e98e9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CommandArcFilled) PassValue() (C.struct_nk_command_arc_filled, *cgoAllocMap) {
	if x.reff41e98e9 != nil {
		return *x.reff41e98e9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CommandArcFilled) Deref() {
	if x.reff41e98e9 == nil {
		return
	}
	x.Header = *NewCommandRef(unsafe.Pointer(&x.reff41e98e9.header))
	x.Cx = (int16)(x.reff41e98e9.cx)
	x.Cy = (int16)(x.reff41e98e9.cy)
	x.R = (uint16)(x.reff41e98e9.r)
	x.A = *(*[2]float32)(unsafe.Pointer(&x.reff41e98e9.a))
	x.Color = *NewColorRef(unsafe.Pointer(&x.reff41e98e9.color))
}

// allocStructNkPanelMemory allocates memory for type C.struct_nk_panel in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkPanelMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkPanelValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkPanelValue = unsafe.Sizeof([1]C.struct_nk_panel{})

// allocStructNkScrollMemory allocates memory for type C.struct_nk_scroll in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkScrollMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkScrollValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkScrollValue = unsafe.Sizeof([1]C.struct_nk_scroll{})

// unpackSScroll transforms a sliced Go data structure into plain C format.
func unpackSScroll(x []Scroll) (unpacked *C.struct_nk_scroll, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.struct_nk_scroll) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocStructNkScrollMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_nk_scroll)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_nk_scroll)(unsafe.Pointer(h.Data))
	return
}

// unpackSCommandBuffer transforms a sliced Go data structure into plain C format.
func unpackSCommandBuffer(x []CommandBuffer) (unpacked *C.struct_nk_command_buffer, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.struct_nk_command_buffer) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocStructNkCommandBufferMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_nk_command_buffer)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_nk_command_buffer)(unsafe.Pointer(h.Data))
	return
}

// unpackSPanel transforms a sliced Go data structure into plain C format.
func unpackSPanel(x []Panel) (unpacked *C.struct_nk_panel, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.struct_nk_panel) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocStructNkPanelMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_nk_panel)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_nk_panel)(unsafe.Pointer(h.Data))
	return
}

// packSScroll reads sliced Go data structure out from plain C format.
func packSScroll(v []Scroll, ptr0 *C.struct_nk_scroll) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStructNkScrollValue]C.struct_nk_scroll)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewScrollRef(unsafe.Pointer(&ptr1))
	}
}

// packSCommandBuffer reads sliced Go data structure out from plain C format.
func packSCommandBuffer(v []CommandBuffer, ptr0 *C.struct_nk_command_buffer) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStructNkCommandBufferValue]C.struct_nk_command_buffer)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewCommandBufferRef(unsafe.Pointer(&ptr1))
	}
}

// packSPanel reads sliced Go data structure out from plain C format.
func packSPanel(v []Panel, ptr0 *C.struct_nk_panel) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStructNkPanelValue]C.struct_nk_panel)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPanelRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Panel) Ref() *C.struct_nk_panel {
	if x == nil {
		return nil
	}
	return x.ref3492d399
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Panel) Free() {
	if x != nil && x.allocs3492d399 != nil {
		x.allocs3492d399.(*cgoAllocMap).Free()
		x.ref3492d399 = nil
	}
}

// NewPanelRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPanelRef(ref unsafe.Pointer) *Panel {
	if ref == nil {
		return nil
	}
	obj := new(Panel)
	obj.ref3492d399 = (*C.struct_nk_panel)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Panel) PassRef() (*C.struct_nk_panel, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3492d399 != nil {
		return x.ref3492d399, nil
	}
	mem3492d399 := allocStructNkPanelMemory(1)
	ref3492d399 := (*C.struct_nk_panel)(mem3492d399)
	allocs3492d399 := new(cgoAllocMap)
	var c_type_allocs *cgoAllocMap
	ref3492d399._type, c_type_allocs = (C.enum_nk_panel_type)(x.Type), cgoAllocsUnknown
	allocs3492d399.Borrow(c_type_allocs)

	var cflags_allocs *cgoAllocMap
	ref3492d399.flags, cflags_allocs = (C.nk_flags)(x.Flags), cgoAllocsUnknown
	allocs3492d399.Borrow(cflags_allocs)

	var cbounds_allocs *cgoAllocMap
	ref3492d399.bounds, cbounds_allocs = x.Bounds.PassValue()
	allocs3492d399.Borrow(cbounds_allocs)

	var coffset_allocs *cgoAllocMap
	ref3492d399.offset, coffset_allocs = unpackSScroll(x.Offset)
	allocs3492d399.Borrow(coffset_allocs)

	var cat_x_allocs *cgoAllocMap
	ref3492d399.at_x, cat_x_allocs = (C.float)(x.AtX), cgoAllocsUnknown
	allocs3492d399.Borrow(cat_x_allocs)

	var cat_y_allocs *cgoAllocMap
	ref3492d399.at_y, cat_y_allocs = (C.float)(x.AtY), cgoAllocsUnknown
	allocs3492d399.Borrow(cat_y_allocs)

	var cmax_x_allocs *cgoAllocMap
	ref3492d399.max_x, cmax_x_allocs = (C.float)(x.MaxX), cgoAllocsUnknown
	allocs3492d399.Borrow(cmax_x_allocs)

	var cfooter_height_allocs *cgoAllocMap
	ref3492d399.footer_height, cfooter_height_allocs = (C.float)(x.FooterHeight), cgoAllocsUnknown
	allocs3492d399.Borrow(cfooter_height_allocs)

	var cheader_height_allocs *cgoAllocMap
	ref3492d399.header_height, cheader_height_allocs = (C.float)(x.HeaderHeight), cgoAllocsUnknown
	allocs3492d399.Borrow(cheader_height_allocs)

	var cborder_allocs *cgoAllocMap
	ref3492d399.border, cborder_allocs = (C.float)(x.Border), cgoAllocsUnknown
	allocs3492d399.Borrow(cborder_allocs)

	var chas_scrolling_allocs *cgoAllocMap
	ref3492d399.has_scrolling, chas_scrolling_allocs = (C.uint)(x.HasScrolling), cgoAllocsUnknown
	allocs3492d399.Borrow(chas_scrolling_allocs)

	var cclip_allocs *cgoAllocMap
	ref3492d399.clip, cclip_allocs = x.Clip.PassValue()
	allocs3492d399.Borrow(cclip_allocs)

	var cmenu_allocs *cgoAllocMap
	ref3492d399.menu, cmenu_allocs = x.Menu.PassValue()
	allocs3492d399.Borrow(cmenu_allocs)

	var crow_allocs *cgoAllocMap
	ref3492d399.row, crow_allocs = x.Row.PassValue()
	allocs3492d399.Borrow(crow_allocs)

	var cchart_allocs *cgoAllocMap
	ref3492d399.chart, cchart_allocs = x.Chart.PassValue()
	allocs3492d399.Borrow(cchart_allocs)

	var cpopup_buffer_allocs *cgoAllocMap
	ref3492d399.popup_buffer, cpopup_buffer_allocs = x.PopupBuffer.PassValue()
	allocs3492d399.Borrow(cpopup_buffer_allocs)

	var cbuffer_allocs *cgoAllocMap
	ref3492d399.buffer, cbuffer_allocs = unpackSCommandBuffer(x.Buffer)
	allocs3492d399.Borrow(cbuffer_allocs)

	var cparent_allocs *cgoAllocMap
	ref3492d399.parent, cparent_allocs = unpackSPanel(x.Parent)
	allocs3492d399.Borrow(cparent_allocs)

	x.ref3492d399 = ref3492d399
	x.allocs3492d399 = allocs3492d399
	return ref3492d399, allocs3492d399

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Panel) PassValue() (C.struct_nk_panel, *cgoAllocMap) {
	if x.ref3492d399 != nil {
		return *x.ref3492d399, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Panel) Deref() {
	if x.ref3492d399 == nil {
		return
	}
	x.Type = (PanelType)(x.ref3492d399._type)
	x.Flags = (Flags)(x.ref3492d399.flags)
	x.Bounds = *NewRectRef(unsafe.Pointer(&x.ref3492d399.bounds))
	packSScroll(x.Offset, x.ref3492d399.offset)
	x.AtX = (float32)(x.ref3492d399.at_x)
	x.AtY = (float32)(x.ref3492d399.at_y)
	x.MaxX = (float32)(x.ref3492d399.max_x)
	x.FooterHeight = (float32)(x.ref3492d399.footer_height)
	x.HeaderHeight = (float32)(x.ref3492d399.header_height)
	x.Border = (float32)(x.ref3492d399.border)
	x.HasScrolling = (uint32)(x.ref3492d399.has_scrolling)
	x.Clip = *NewRectRef(unsafe.Pointer(&x.ref3492d399.clip))
	x.Menu = *NewMenuStateRef(unsafe.Pointer(&x.ref3492d399.menu))
	x.Row = *NewRowLayoutRef(unsafe.Pointer(&x.ref3492d399.row))
	x.Chart = *NewChartRef(unsafe.Pointer(&x.ref3492d399.chart))
	x.PopupBuffer = *NewPopupBufferRef(unsafe.Pointer(&x.ref3492d399.popup_buffer))
	packSCommandBuffer(x.Buffer, x.ref3492d399.buffer)
	packSPanel(x.Parent, x.ref3492d399.parent)
}

// allocStructNkConfigStackStyleItemMemory allocates memory for type C.struct_nk_config_stack_style_item in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkConfigStackStyleItemMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkConfigStackStyleItemValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkConfigStackStyleItemValue = unsafe.Sizeof([1]C.struct_nk_config_stack_style_item{})

// allocA16StructNkConfigStackStyleItemElementMemory allocates memory for type [16]C.struct_nk_config_stack_style_item_element in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA16StructNkConfigStackStyleItemElementMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfA16StructNkConfigStackStyleItemElementValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfA16StructNkConfigStackStyleItemElementValue = unsafe.Sizeof([1][16]C.struct_nk_config_stack_style_item_element{})

// unpackA16ConfigStackStyleItemElement transforms a sliced Go data structure into plain C format.
func unpackA16ConfigStackStyleItemElement(x [16]ConfigStackStyleItemElement) (unpacked [16]C.struct_nk_config_stack_style_item_element, allocs *cgoAllocMap) {
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(*[16]C.struct_nk_config_stack_style_item_element) {
		go allocs.Free()
	})

	mem0 := allocA16StructNkConfigStackStyleItemElementMemory(1)
	allocs.Add(mem0)
	v0 := (*[16]C.struct_nk_config_stack_style_item_element)(mem0)
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	unpacked = *(*[16]C.struct_nk_config_stack_style_item_element)(mem0)
	return
}

// packA16ConfigStackStyleItemElement reads sliced Go data structure out from plain C format.
func packA16ConfigStackStyleItemElement(v *[16]ConfigStackStyleItemElement, ptr0 *[16]C.struct_nk_config_stack_style_item_element) {
	for i0 := range v {
		ptr1 := ptr0[i0]
		v[i0] = *NewConfigStackStyleItemElementRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ConfigStackStyleItem) Ref() *C.struct_nk_config_stack_style_item {
	if x == nil {
		return nil
	}
	return x.ref99f88018
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ConfigStackStyleItem) Free() {
	if x != nil && x.allocs99f88018 != nil {
		x.allocs99f88018.(*cgoAllocMap).Free()
		x.ref99f88018 = nil
	}
}

// NewConfigStackStyleItemRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewConfigStackStyleItemRef(ref unsafe.Pointer) *ConfigStackStyleItem {
	if ref == nil {
		return nil
	}
	obj := new(ConfigStackStyleItem)
	obj.ref99f88018 = (*C.struct_nk_config_stack_style_item)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ConfigStackStyleItem) PassRef() (*C.struct_nk_config_stack_style_item, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref99f88018 != nil {
		return x.ref99f88018, nil
	}
	mem99f88018 := allocStructNkConfigStackStyleItemMemory(1)
	ref99f88018 := (*C.struct_nk_config_stack_style_item)(mem99f88018)
	allocs99f88018 := new(cgoAllocMap)
	var chead_allocs *cgoAllocMap
	ref99f88018.head, chead_allocs = (C.int)(x.Head), cgoAllocsUnknown
	allocs99f88018.Borrow(chead_allocs)

	var celements_allocs *cgoAllocMap
	ref99f88018.elements, celements_allocs = unpackA16ConfigStackStyleItemElement(x.Elements)
	allocs99f88018.Borrow(celements_allocs)

	x.ref99f88018 = ref99f88018
	x.allocs99f88018 = allocs99f88018
	return ref99f88018, allocs99f88018

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ConfigStackStyleItem) PassValue() (C.struct_nk_config_stack_style_item, *cgoAllocMap) {
	if x.ref99f88018 != nil {
		return *x.ref99f88018, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ConfigStackStyleItem) Deref() {
	if x.ref99f88018 == nil {
		return
	}
	x.Head = (int32)(x.ref99f88018.head)
	packA16ConfigStackStyleItemElement(&x.Elements, (*[16]C.struct_nk_config_stack_style_item_element)(unsafe.Pointer(&x.ref99f88018.elements)))
}

// allocStructNkMenuStateMemory allocates memory for type C.struct_nk_menu_state in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkMenuStateMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkMenuStateValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkMenuStateValue = unsafe.Sizeof([1]C.struct_nk_menu_state{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MenuState) Ref() *C.struct_nk_menu_state {
	if x == nil {
		return nil
	}
	return x.ref6455ac1d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MenuState) Free() {
	if x != nil && x.allocs6455ac1d != nil {
		x.allocs6455ac1d.(*cgoAllocMap).Free()
		x.ref6455ac1d = nil
	}
}

// NewMenuStateRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMenuStateRef(ref unsafe.Pointer) *MenuState {
	if ref == nil {
		return nil
	}
	obj := new(MenuState)
	obj.ref6455ac1d = (*C.struct_nk_menu_state)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MenuState) PassRef() (*C.struct_nk_menu_state, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6455ac1d != nil {
		return x.ref6455ac1d, nil
	}
	mem6455ac1d := allocStructNkMenuStateMemory(1)
	ref6455ac1d := (*C.struct_nk_menu_state)(mem6455ac1d)
	allocs6455ac1d := new(cgoAllocMap)
	var cx_allocs *cgoAllocMap
	ref6455ac1d.x, cx_allocs = (C.float)(x.X), cgoAllocsUnknown
	allocs6455ac1d.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	ref6455ac1d.y, cy_allocs = (C.float)(x.Y), cgoAllocsUnknown
	allocs6455ac1d.Borrow(cy_allocs)

	var cw_allocs *cgoAllocMap
	ref6455ac1d.w, cw_allocs = (C.float)(x.W), cgoAllocsUnknown
	allocs6455ac1d.Borrow(cw_allocs)

	var ch_allocs *cgoAllocMap
	ref6455ac1d.h, ch_allocs = (C.float)(x.H), cgoAllocsUnknown
	allocs6455ac1d.Borrow(ch_allocs)

	var coffset_allocs *cgoAllocMap
	ref6455ac1d.offset, coffset_allocs = x.Offset.PassValue()
	allocs6455ac1d.Borrow(coffset_allocs)

	x.ref6455ac1d = ref6455ac1d
	x.allocs6455ac1d = allocs6455ac1d
	return ref6455ac1d, allocs6455ac1d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MenuState) PassValue() (C.struct_nk_menu_state, *cgoAllocMap) {
	if x.ref6455ac1d != nil {
		return *x.ref6455ac1d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *MenuState) Deref() {
	if x.ref6455ac1d == nil {
		return
	}
	x.X = (float32)(x.ref6455ac1d.x)
	x.Y = (float32)(x.ref6455ac1d.y)
	x.W = (float32)(x.ref6455ac1d.w)
	x.H = (float32)(x.ref6455ac1d.h)
	x.Offset = *NewScrollRef(unsafe.Pointer(&x.ref6455ac1d.offset))
}

// allocStructNkConfigStackFloatMemory allocates memory for type C.struct_nk_config_stack_float in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkConfigStackFloatMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkConfigStackFloatValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkConfigStackFloatValue = unsafe.Sizeof([1]C.struct_nk_config_stack_float{})

// allocA32StructNkConfigStackFloatElementMemory allocates memory for type [32]C.struct_nk_config_stack_float_element in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA32StructNkConfigStackFloatElementMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfA32StructNkConfigStackFloatElementValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfA32StructNkConfigStackFloatElementValue = unsafe.Sizeof([1][32]C.struct_nk_config_stack_float_element{})

// unpackA32ConfigStackFloatElement transforms a sliced Go data structure into plain C format.
func unpackA32ConfigStackFloatElement(x [32]ConfigStackFloatElement) (unpacked [32]C.struct_nk_config_stack_float_element, allocs *cgoAllocMap) {
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(*[32]C.struct_nk_config_stack_float_element) {
		go allocs.Free()
	})

	mem0 := allocA32StructNkConfigStackFloatElementMemory(1)
	allocs.Add(mem0)
	v0 := (*[32]C.struct_nk_config_stack_float_element)(mem0)
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	unpacked = *(*[32]C.struct_nk_config_stack_float_element)(mem0)
	return
}

// packA32ConfigStackFloatElement reads sliced Go data structure out from plain C format.
func packA32ConfigStackFloatElement(v *[32]ConfigStackFloatElement, ptr0 *[32]C.struct_nk_config_stack_float_element) {
	for i0 := range v {
		ptr1 := ptr0[i0]
		v[i0] = *NewConfigStackFloatElementRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ConfigStackFloat) Ref() *C.struct_nk_config_stack_float {
	if x == nil {
		return nil
	}
	return x.ref8c8d0ef5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ConfigStackFloat) Free() {
	if x != nil && x.allocs8c8d0ef5 != nil {
		x.allocs8c8d0ef5.(*cgoAllocMap).Free()
		x.ref8c8d0ef5 = nil
	}
}

// NewConfigStackFloatRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewConfigStackFloatRef(ref unsafe.Pointer) *ConfigStackFloat {
	if ref == nil {
		return nil
	}
	obj := new(ConfigStackFloat)
	obj.ref8c8d0ef5 = (*C.struct_nk_config_stack_float)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ConfigStackFloat) PassRef() (*C.struct_nk_config_stack_float, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8c8d0ef5 != nil {
		return x.ref8c8d0ef5, nil
	}
	mem8c8d0ef5 := allocStructNkConfigStackFloatMemory(1)
	ref8c8d0ef5 := (*C.struct_nk_config_stack_float)(mem8c8d0ef5)
	allocs8c8d0ef5 := new(cgoAllocMap)
	var chead_allocs *cgoAllocMap
	ref8c8d0ef5.head, chead_allocs = (C.int)(x.Head), cgoAllocsUnknown
	allocs8c8d0ef5.Borrow(chead_allocs)

	var celements_allocs *cgoAllocMap
	ref8c8d0ef5.elements, celements_allocs = unpackA32ConfigStackFloatElement(x.Elements)
	allocs8c8d0ef5.Borrow(celements_allocs)

	x.ref8c8d0ef5 = ref8c8d0ef5
	x.allocs8c8d0ef5 = allocs8c8d0ef5
	return ref8c8d0ef5, allocs8c8d0ef5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ConfigStackFloat) PassValue() (C.struct_nk_config_stack_float, *cgoAllocMap) {
	if x.ref8c8d0ef5 != nil {
		return *x.ref8c8d0ef5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ConfigStackFloat) Deref() {
	if x.ref8c8d0ef5 == nil {
		return
	}
	x.Head = (int32)(x.ref8c8d0ef5.head)
	packA32ConfigStackFloatElement(&x.Elements, (*[32]C.struct_nk_config_stack_float_element)(unsafe.Pointer(&x.ref8c8d0ef5.elements)))
}

// allocStructNkPoolMemory allocates memory for type C.struct_nk_pool in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkPoolMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkPoolValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkPoolValue = unsafe.Sizeof([1]C.struct_nk_pool{})

// allocStructNkPageMemory allocates memory for type C.struct_nk_page in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkPageMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkPageValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkPageValue = unsafe.Sizeof([1]C.struct_nk_page{})

// unpackSPage transforms a sliced Go data structure into plain C format.
func unpackSPage(x []Page) (unpacked *C.struct_nk_page, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.struct_nk_page) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocStructNkPageMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_nk_page)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_nk_page)(unsafe.Pointer(h.Data))
	return
}

// allocStructNkPageElementMemory allocates memory for type C.struct_nk_page_element in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkPageElementMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkPageElementValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkPageElementValue = unsafe.Sizeof([1]C.struct_nk_page_element{})

// unpackSPageElement transforms a sliced Go data structure into plain C format.
func unpackSPageElement(x []PageElement) (unpacked *C.struct_nk_page_element, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.struct_nk_page_element) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocStructNkPageElementMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_nk_page_element)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_nk_page_element)(unsafe.Pointer(h.Data))
	return
}

// packSPage reads sliced Go data structure out from plain C format.
func packSPage(v []Page, ptr0 *C.struct_nk_page) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStructNkPageValue]C.struct_nk_page)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPageRef(unsafe.Pointer(&ptr1))
	}
}

// packSPageElement reads sliced Go data structure out from plain C format.
func packSPageElement(v []PageElement, ptr0 *C.struct_nk_page_element) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStructNkPageElementValue]C.struct_nk_page_element)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPageElementRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Pool) Ref() *C.struct_nk_pool {
	if x == nil {
		return nil
	}
	return x.ref9939b1cc
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Pool) Free() {
	if x != nil && x.allocs9939b1cc != nil {
		x.allocs9939b1cc.(*cgoAllocMap).Free()
		x.ref9939b1cc = nil
	}
}

// NewPoolRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPoolRef(ref unsafe.Pointer) *Pool {
	if ref == nil {
		return nil
	}
	obj := new(Pool)
	obj.ref9939b1cc = (*C.struct_nk_pool)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Pool) PassRef() (*C.struct_nk_pool, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9939b1cc != nil {
		return x.ref9939b1cc, nil
	}
	mem9939b1cc := allocStructNkPoolMemory(1)
	ref9939b1cc := (*C.struct_nk_pool)(mem9939b1cc)
	allocs9939b1cc := new(cgoAllocMap)
	var calloc_allocs *cgoAllocMap
	ref9939b1cc.alloc, calloc_allocs = *(*C.struct_nk_allocator)(unsafe.Pointer(&x.Alloc)), cgoAllocsUnknown
	allocs9939b1cc.Borrow(calloc_allocs)

	var c_type_allocs *cgoAllocMap
	ref9939b1cc._type, c_type_allocs = (C.enum_nk_allocation_type)(x.Type), cgoAllocsUnknown
	allocs9939b1cc.Borrow(c_type_allocs)

	var cpage_count_allocs *cgoAllocMap
	ref9939b1cc.page_count, cpage_count_allocs = (C.uint)(x.PageCount), cgoAllocsUnknown
	allocs9939b1cc.Borrow(cpage_count_allocs)

	var cpages_allocs *cgoAllocMap
	ref9939b1cc.pages, cpages_allocs = unpackSPage(x.Pages)
	allocs9939b1cc.Borrow(cpages_allocs)

	var cfreelist_allocs *cgoAllocMap
	ref9939b1cc.freelist, cfreelist_allocs = unpackSPageElement(x.Freelist)
	allocs9939b1cc.Borrow(cfreelist_allocs)

	var ccapacity_allocs *cgoAllocMap
	ref9939b1cc.capacity, ccapacity_allocs = (C.uint)(x.Capacity), cgoAllocsUnknown
	allocs9939b1cc.Borrow(ccapacity_allocs)

	var csize_allocs *cgoAllocMap
	ref9939b1cc.size, csize_allocs = (C.nk_size)(x.Size), cgoAllocsUnknown
	allocs9939b1cc.Borrow(csize_allocs)

	var ccap_allocs *cgoAllocMap
	ref9939b1cc.cap, ccap_allocs = (C.nk_size)(x.Cap), cgoAllocsUnknown
	allocs9939b1cc.Borrow(ccap_allocs)

	x.ref9939b1cc = ref9939b1cc
	x.allocs9939b1cc = allocs9939b1cc
	return ref9939b1cc, allocs9939b1cc

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Pool) PassValue() (C.struct_nk_pool, *cgoAllocMap) {
	if x.ref9939b1cc != nil {
		return *x.ref9939b1cc, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Pool) Deref() {
	if x.ref9939b1cc == nil {
		return
	}
	x.Alloc = *(*Allocator)(unsafe.Pointer(&x.ref9939b1cc.alloc))
	x.Type = (AllocationType)(x.ref9939b1cc._type)
	x.PageCount = (uint32)(x.ref9939b1cc.page_count)
	packSPage(x.Pages, x.ref9939b1cc.pages)
	packSPageElement(x.Freelist, x.ref9939b1cc.freelist)
	x.Capacity = (uint32)(x.ref9939b1cc.capacity)
	x.Size = (Size)(x.ref9939b1cc.size)
	x.Cap = (Size)(x.ref9939b1cc.cap)
}

// allocStructNkStyleTabMemory allocates memory for type C.struct_nk_style_tab in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkStyleTabMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkStyleTabValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkStyleTabValue = unsafe.Sizeof([1]C.struct_nk_style_tab{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *StyleTab) Ref() *C.struct_nk_style_tab {
	if x == nil {
		return nil
	}
	return x.ref967cf1ef
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *StyleTab) Free() {
	if x != nil && x.allocs967cf1ef != nil {
		x.allocs967cf1ef.(*cgoAllocMap).Free()
		x.ref967cf1ef = nil
	}
}

// NewStyleTabRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewStyleTabRef(ref unsafe.Pointer) *StyleTab {
	if ref == nil {
		return nil
	}
	obj := new(StyleTab)
	obj.ref967cf1ef = (*C.struct_nk_style_tab)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *StyleTab) PassRef() (*C.struct_nk_style_tab, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref967cf1ef != nil {
		return x.ref967cf1ef, nil
	}
	mem967cf1ef := allocStructNkStyleTabMemory(1)
	ref967cf1ef := (*C.struct_nk_style_tab)(mem967cf1ef)
	allocs967cf1ef := new(cgoAllocMap)
	var cbackground_allocs *cgoAllocMap
	ref967cf1ef.background, cbackground_allocs = x.Background.PassValue()
	allocs967cf1ef.Borrow(cbackground_allocs)

	var cborder_color_allocs *cgoAllocMap
	ref967cf1ef.border_color, cborder_color_allocs = x.BorderColor.PassValue()
	allocs967cf1ef.Borrow(cborder_color_allocs)

	var ctext_allocs *cgoAllocMap
	ref967cf1ef.text, ctext_allocs = x.Text.PassValue()
	allocs967cf1ef.Borrow(ctext_allocs)

	var ctab_maximize_button_allocs *cgoAllocMap
	ref967cf1ef.tab_maximize_button, ctab_maximize_button_allocs = x.TabMaximizeButton.PassValue()
	allocs967cf1ef.Borrow(ctab_maximize_button_allocs)

	var ctab_minimize_button_allocs *cgoAllocMap
	ref967cf1ef.tab_minimize_button, ctab_minimize_button_allocs = x.TabMinimizeButton.PassValue()
	allocs967cf1ef.Borrow(ctab_minimize_button_allocs)

	var cnode_maximize_button_allocs *cgoAllocMap
	ref967cf1ef.node_maximize_button, cnode_maximize_button_allocs = x.NodeMaximizeButton.PassValue()
	allocs967cf1ef.Borrow(cnode_maximize_button_allocs)

	var cnode_minimize_button_allocs *cgoAllocMap
	ref967cf1ef.node_minimize_button, cnode_minimize_button_allocs = x.NodeMinimizeButton.PassValue()
	allocs967cf1ef.Borrow(cnode_minimize_button_allocs)

	var csym_minimize_allocs *cgoAllocMap
	ref967cf1ef.sym_minimize, csym_minimize_allocs = (C.enum_nk_symbol_type)(x.SymMinimize), cgoAllocsUnknown
	allocs967cf1ef.Borrow(csym_minimize_allocs)

	var csym_maximize_allocs *cgoAllocMap
	ref967cf1ef.sym_maximize, csym_maximize_allocs = (C.enum_nk_symbol_type)(x.SymMaximize), cgoAllocsUnknown
	allocs967cf1ef.Borrow(csym_maximize_allocs)

	var cborder_allocs *cgoAllocMap
	ref967cf1ef.border, cborder_allocs = (C.float)(x.Border), cgoAllocsUnknown
	allocs967cf1ef.Borrow(cborder_allocs)

	var crounding_allocs *cgoAllocMap
	ref967cf1ef.rounding, crounding_allocs = (C.float)(x.Rounding), cgoAllocsUnknown
	allocs967cf1ef.Borrow(crounding_allocs)

	var cindent_allocs *cgoAllocMap
	ref967cf1ef.indent, cindent_allocs = (C.float)(x.Indent), cgoAllocsUnknown
	allocs967cf1ef.Borrow(cindent_allocs)

	var cpadding_allocs *cgoAllocMap
	ref967cf1ef.padding, cpadding_allocs = x.Padding.PassValue()
	allocs967cf1ef.Borrow(cpadding_allocs)

	var cspacing_allocs *cgoAllocMap
	ref967cf1ef.spacing, cspacing_allocs = x.Spacing.PassValue()
	allocs967cf1ef.Borrow(cspacing_allocs)

	x.ref967cf1ef = ref967cf1ef
	x.allocs967cf1ef = allocs967cf1ef
	return ref967cf1ef, allocs967cf1ef

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x StyleTab) PassValue() (C.struct_nk_style_tab, *cgoAllocMap) {
	if x.ref967cf1ef != nil {
		return *x.ref967cf1ef, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *StyleTab) Deref() {
	if x.ref967cf1ef == nil {
		return
	}
	x.Background = *NewStyleItemRef(unsafe.Pointer(&x.ref967cf1ef.background))
	x.BorderColor = *NewColorRef(unsafe.Pointer(&x.ref967cf1ef.border_color))
	x.Text = *NewColorRef(unsafe.Pointer(&x.ref967cf1ef.text))
	x.TabMaximizeButton = *NewStyleButtonRef(unsafe.Pointer(&x.ref967cf1ef.tab_maximize_button))
	x.TabMinimizeButton = *NewStyleButtonRef(unsafe.Pointer(&x.ref967cf1ef.tab_minimize_button))
	x.NodeMaximizeButton = *NewStyleButtonRef(unsafe.Pointer(&x.ref967cf1ef.node_maximize_button))
	x.NodeMinimizeButton = *NewStyleButtonRef(unsafe.Pointer(&x.ref967cf1ef.node_minimize_button))
	x.SymMinimize = (SymbolType)(x.ref967cf1ef.sym_minimize)
	x.SymMaximize = (SymbolType)(x.ref967cf1ef.sym_maximize)
	x.Border = (float32)(x.ref967cf1ef.border)
	x.Rounding = (float32)(x.ref967cf1ef.rounding)
	x.Indent = (float32)(x.ref967cf1ef.indent)
	x.Padding = *NewVec2Ref(unsafe.Pointer(&x.ref967cf1ef.padding))
	x.Spacing = *NewVec2Ref(unsafe.Pointer(&x.ref967cf1ef.spacing))
}

// allocStructNkConfigStackUserFontMemory allocates memory for type C.struct_nk_config_stack_user_font in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkConfigStackUserFontMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkConfigStackUserFontValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkConfigStackUserFontValue = unsafe.Sizeof([1]C.struct_nk_config_stack_user_font{})

// allocA8StructNkConfigStackUserFontElementMemory allocates memory for type [8]C.struct_nk_config_stack_user_font_element in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA8StructNkConfigStackUserFontElementMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfA8StructNkConfigStackUserFontElementValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfA8StructNkConfigStackUserFontElementValue = unsafe.Sizeof([1][8]C.struct_nk_config_stack_user_font_element{})

// unpackA8ConfigStackUserFontElement transforms a sliced Go data structure into plain C format.
func unpackA8ConfigStackUserFontElement(x [8]ConfigStackUserFontElement) (unpacked [8]C.struct_nk_config_stack_user_font_element, allocs *cgoAllocMap) {
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(*[8]C.struct_nk_config_stack_user_font_element) {
		go allocs.Free()
	})

	mem0 := allocA8StructNkConfigStackUserFontElementMemory(1)
	allocs.Add(mem0)
	v0 := (*[8]C.struct_nk_config_stack_user_font_element)(mem0)
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	unpacked = *(*[8]C.struct_nk_config_stack_user_font_element)(mem0)
	return
}

// packA8ConfigStackUserFontElement reads sliced Go data structure out from plain C format.
func packA8ConfigStackUserFontElement(v *[8]ConfigStackUserFontElement, ptr0 *[8]C.struct_nk_config_stack_user_font_element) {
	for i0 := range v {
		ptr1 := ptr0[i0]
		v[i0] = *NewConfigStackUserFontElementRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ConfigStackUserFont) Ref() *C.struct_nk_config_stack_user_font {
	if x == nil {
		return nil
	}
	return x.refa664861d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ConfigStackUserFont) Free() {
	if x != nil && x.allocsa664861d != nil {
		x.allocsa664861d.(*cgoAllocMap).Free()
		x.refa664861d = nil
	}
}

// NewConfigStackUserFontRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewConfigStackUserFontRef(ref unsafe.Pointer) *ConfigStackUserFont {
	if ref == nil {
		return nil
	}
	obj := new(ConfigStackUserFont)
	obj.refa664861d = (*C.struct_nk_config_stack_user_font)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ConfigStackUserFont) PassRef() (*C.struct_nk_config_stack_user_font, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa664861d != nil {
		return x.refa664861d, nil
	}
	mema664861d := allocStructNkConfigStackUserFontMemory(1)
	refa664861d := (*C.struct_nk_config_stack_user_font)(mema664861d)
	allocsa664861d := new(cgoAllocMap)
	var chead_allocs *cgoAllocMap
	refa664861d.head, chead_allocs = (C.int)(x.Head), cgoAllocsUnknown
	allocsa664861d.Borrow(chead_allocs)

	var celements_allocs *cgoAllocMap
	refa664861d.elements, celements_allocs = unpackA8ConfigStackUserFontElement(x.Elements)
	allocsa664861d.Borrow(celements_allocs)

	x.refa664861d = refa664861d
	x.allocsa664861d = allocsa664861d
	return refa664861d, allocsa664861d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ConfigStackUserFont) PassValue() (C.struct_nk_config_stack_user_font, *cgoAllocMap) {
	if x.refa664861d != nil {
		return *x.refa664861d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ConfigStackUserFont) Deref() {
	if x.refa664861d == nil {
		return
	}
	x.Head = (int32)(x.refa664861d.head)
	packA8ConfigStackUserFontElement(&x.Elements, (*[8]C.struct_nk_config_stack_user_font_element)(unsafe.Pointer(&x.refa664861d.elements)))
}

// allocStructNkMemoryStatusMemory allocates memory for type C.struct_nk_memory_status in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkMemoryStatusMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkMemoryStatusValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkMemoryStatusValue = unsafe.Sizeof([1]C.struct_nk_memory_status{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MemoryStatus) Ref() *C.struct_nk_memory_status {
	if x == nil {
		return nil
	}
	return x.ref7d6685cf
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MemoryStatus) Free() {
	if x != nil && x.allocs7d6685cf != nil {
		x.allocs7d6685cf.(*cgoAllocMap).Free()
		x.ref7d6685cf = nil
	}
}

// NewMemoryStatusRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMemoryStatusRef(ref unsafe.Pointer) *MemoryStatus {
	if ref == nil {
		return nil
	}
	obj := new(MemoryStatus)
	obj.ref7d6685cf = (*C.struct_nk_memory_status)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MemoryStatus) PassRef() (*C.struct_nk_memory_status, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7d6685cf != nil {
		return x.ref7d6685cf, nil
	}
	mem7d6685cf := allocStructNkMemoryStatusMemory(1)
	ref7d6685cf := (*C.struct_nk_memory_status)(mem7d6685cf)
	allocs7d6685cf := new(cgoAllocMap)
	var cmemory_allocs *cgoAllocMap
	ref7d6685cf.memory, cmemory_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.Memory)), cgoAllocsUnknown
	allocs7d6685cf.Borrow(cmemory_allocs)

	var c_type_allocs *cgoAllocMap
	ref7d6685cf._type, c_type_allocs = (C.uint)(x.Type), cgoAllocsUnknown
	allocs7d6685cf.Borrow(c_type_allocs)

	var csize_allocs *cgoAllocMap
	ref7d6685cf.size, csize_allocs = (C.nk_size)(x.Size), cgoAllocsUnknown
	allocs7d6685cf.Borrow(csize_allocs)

	var callocated_allocs *cgoAllocMap
	ref7d6685cf.allocated, callocated_allocs = (C.nk_size)(x.Allocated), cgoAllocsUnknown
	allocs7d6685cf.Borrow(callocated_allocs)

	var cneeded_allocs *cgoAllocMap
	ref7d6685cf.needed, cneeded_allocs = (C.nk_size)(x.Needed), cgoAllocsUnknown
	allocs7d6685cf.Borrow(cneeded_allocs)

	var ccalls_allocs *cgoAllocMap
	ref7d6685cf.calls, ccalls_allocs = (C.nk_size)(x.Calls), cgoAllocsUnknown
	allocs7d6685cf.Borrow(ccalls_allocs)

	x.ref7d6685cf = ref7d6685cf
	x.allocs7d6685cf = allocs7d6685cf
	return ref7d6685cf, allocs7d6685cf

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MemoryStatus) PassValue() (C.struct_nk_memory_status, *cgoAllocMap) {
	if x.ref7d6685cf != nil {
		return *x.ref7d6685cf, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *MemoryStatus) Deref() {
	if x.ref7d6685cf == nil {
		return
	}
	x.Memory = (unsafe.Pointer)(unsafe.Pointer(x.ref7d6685cf.memory))
	x.Type = (uint32)(x.ref7d6685cf._type)
	x.Size = (Size)(x.ref7d6685cf.size)
	x.Allocated = (Size)(x.ref7d6685cf.allocated)
	x.Needed = (Size)(x.ref7d6685cf.needed)
	x.Calls = (Size)(x.ref7d6685cf.calls)
}

// allocStructNkStyleTextMemory allocates memory for type C.struct_nk_style_text in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkStyleTextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkStyleTextValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkStyleTextValue = unsafe.Sizeof([1]C.struct_nk_style_text{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *StyleText) Ref() *C.struct_nk_style_text {
	if x == nil {
		return nil
	}
	return x.ref26d8bb7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *StyleText) Free() {
	if x != nil && x.allocs26d8bb7 != nil {
		x.allocs26d8bb7.(*cgoAllocMap).Free()
		x.ref26d8bb7 = nil
	}
}

// NewStyleTextRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewStyleTextRef(ref unsafe.Pointer) *StyleText {
	if ref == nil {
		return nil
	}
	obj := new(StyleText)
	obj.ref26d8bb7 = (*C.struct_nk_style_text)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *StyleText) PassRef() (*C.struct_nk_style_text, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref26d8bb7 != nil {
		return x.ref26d8bb7, nil
	}
	mem26d8bb7 := allocStructNkStyleTextMemory(1)
	ref26d8bb7 := (*C.struct_nk_style_text)(mem26d8bb7)
	allocs26d8bb7 := new(cgoAllocMap)
	var ccolor_allocs *cgoAllocMap
	ref26d8bb7.color, ccolor_allocs = x.Color.PassValue()
	allocs26d8bb7.Borrow(ccolor_allocs)

	var cpadding_allocs *cgoAllocMap
	ref26d8bb7.padding, cpadding_allocs = x.Padding.PassValue()
	allocs26d8bb7.Borrow(cpadding_allocs)

	x.ref26d8bb7 = ref26d8bb7
	x.allocs26d8bb7 = allocs26d8bb7
	return ref26d8bb7, allocs26d8bb7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x StyleText) PassValue() (C.struct_nk_style_text, *cgoAllocMap) {
	if x.ref26d8bb7 != nil {
		return *x.ref26d8bb7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *StyleText) Deref() {
	if x.ref26d8bb7 == nil {
		return
	}
	x.Color = *NewColorRef(unsafe.Pointer(&x.ref26d8bb7.color))
	x.Padding = *NewVec2Ref(unsafe.Pointer(&x.ref26d8bb7.padding))
}

// allocStructNkStyleToggleMemory allocates memory for type C.struct_nk_style_toggle in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkStyleToggleMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkStyleToggleValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkStyleToggleValue = unsafe.Sizeof([1]C.struct_nk_style_toggle{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *StyleToggle) Ref() *C.struct_nk_style_toggle {
	if x == nil {
		return nil
	}
	return x.ref380d8178
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *StyleToggle) Free() {
	if x != nil && x.allocs380d8178 != nil {
		x.allocs380d8178.(*cgoAllocMap).Free()
		x.ref380d8178 = nil
	}
}

// NewStyleToggleRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewStyleToggleRef(ref unsafe.Pointer) *StyleToggle {
	if ref == nil {
		return nil
	}
	obj := new(StyleToggle)
	obj.ref380d8178 = (*C.struct_nk_style_toggle)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *StyleToggle) PassRef() (*C.struct_nk_style_toggle, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref380d8178 != nil {
		return x.ref380d8178, nil
	}
	mem380d8178 := allocStructNkStyleToggleMemory(1)
	ref380d8178 := (*C.struct_nk_style_toggle)(mem380d8178)
	allocs380d8178 := new(cgoAllocMap)
	var cnormal_allocs *cgoAllocMap
	ref380d8178.normal, cnormal_allocs = x.Normal.PassValue()
	allocs380d8178.Borrow(cnormal_allocs)

	var chover_allocs *cgoAllocMap
	ref380d8178.hover, chover_allocs = x.Hover.PassValue()
	allocs380d8178.Borrow(chover_allocs)

	var cactive_allocs *cgoAllocMap
	ref380d8178.active, cactive_allocs = x.Active.PassValue()
	allocs380d8178.Borrow(cactive_allocs)

	var cborder_color_allocs *cgoAllocMap
	ref380d8178.border_color, cborder_color_allocs = x.BorderColor.PassValue()
	allocs380d8178.Borrow(cborder_color_allocs)

	var ccursor_normal_allocs *cgoAllocMap
	ref380d8178.cursor_normal, ccursor_normal_allocs = x.CursorNormal.PassValue()
	allocs380d8178.Borrow(ccursor_normal_allocs)

	var ccursor_hover_allocs *cgoAllocMap
	ref380d8178.cursor_hover, ccursor_hover_allocs = x.CursorHover.PassValue()
	allocs380d8178.Borrow(ccursor_hover_allocs)

	var ctext_normal_allocs *cgoAllocMap
	ref380d8178.text_normal, ctext_normal_allocs = x.TextNormal.PassValue()
	allocs380d8178.Borrow(ctext_normal_allocs)

	var ctext_hover_allocs *cgoAllocMap
	ref380d8178.text_hover, ctext_hover_allocs = x.TextHover.PassValue()
	allocs380d8178.Borrow(ctext_hover_allocs)

	var ctext_active_allocs *cgoAllocMap
	ref380d8178.text_active, ctext_active_allocs = x.TextActive.PassValue()
	allocs380d8178.Borrow(ctext_active_allocs)

	var ctext_background_allocs *cgoAllocMap
	ref380d8178.text_background, ctext_background_allocs = x.TextBackground.PassValue()
	allocs380d8178.Borrow(ctext_background_allocs)

	var ctext_alignment_allocs *cgoAllocMap
	ref380d8178.text_alignment, ctext_alignment_allocs = (C.nk_flags)(x.TextAlignment), cgoAllocsUnknown
	allocs380d8178.Borrow(ctext_alignment_allocs)

	var cpadding_allocs *cgoAllocMap
	ref380d8178.padding, cpadding_allocs = x.Padding.PassValue()
	allocs380d8178.Borrow(cpadding_allocs)

	var ctouch_padding_allocs *cgoAllocMap
	ref380d8178.touch_padding, ctouch_padding_allocs = x.TouchPadding.PassValue()
	allocs380d8178.Borrow(ctouch_padding_allocs)

	var cspacing_allocs *cgoAllocMap
	ref380d8178.spacing, cspacing_allocs = (C.float)(x.Spacing), cgoAllocsUnknown
	allocs380d8178.Borrow(cspacing_allocs)

	var cborder_allocs *cgoAllocMap
	ref380d8178.border, cborder_allocs = (C.float)(x.Border), cgoAllocsUnknown
	allocs380d8178.Borrow(cborder_allocs)

	var cuserdata_allocs *cgoAllocMap
	ref380d8178.userdata, cuserdata_allocs = *(*C.nk_handle)(unsafe.Pointer(&x.Userdata)), cgoAllocsUnknown
	allocs380d8178.Borrow(cuserdata_allocs)

	var cdraw_begin_allocs *cgoAllocMap
	ref380d8178.draw_begin, cdraw_begin_allocs = (*[0]byte)(unsafe.Pointer(x.DrawBegin)), cgoAllocsUnknown
	allocs380d8178.Borrow(cdraw_begin_allocs)

	var cdraw_end_allocs *cgoAllocMap
	ref380d8178.draw_end, cdraw_end_allocs = (*[0]byte)(unsafe.Pointer(x.DrawEnd)), cgoAllocsUnknown
	allocs380d8178.Borrow(cdraw_end_allocs)

	x.ref380d8178 = ref380d8178
	x.allocs380d8178 = allocs380d8178
	return ref380d8178, allocs380d8178

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x StyleToggle) PassValue() (C.struct_nk_style_toggle, *cgoAllocMap) {
	if x.ref380d8178 != nil {
		return *x.ref380d8178, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *StyleToggle) Deref() {
	if x.ref380d8178 == nil {
		return
	}
	x.Normal = *NewStyleItemRef(unsafe.Pointer(&x.ref380d8178.normal))
	x.Hover = *NewStyleItemRef(unsafe.Pointer(&x.ref380d8178.hover))
	x.Active = *NewStyleItemRef(unsafe.Pointer(&x.ref380d8178.active))
	x.BorderColor = *NewColorRef(unsafe.Pointer(&x.ref380d8178.border_color))
	x.CursorNormal = *NewStyleItemRef(unsafe.Pointer(&x.ref380d8178.cursor_normal))
	x.CursorHover = *NewStyleItemRef(unsafe.Pointer(&x.ref380d8178.cursor_hover))
	x.TextNormal = *NewColorRef(unsafe.Pointer(&x.ref380d8178.text_normal))
	x.TextHover = *NewColorRef(unsafe.Pointer(&x.ref380d8178.text_hover))
	x.TextActive = *NewColorRef(unsafe.Pointer(&x.ref380d8178.text_active))
	x.TextBackground = *NewColorRef(unsafe.Pointer(&x.ref380d8178.text_background))
	x.TextAlignment = (Flags)(x.ref380d8178.text_alignment)
	x.Padding = *NewVec2Ref(unsafe.Pointer(&x.ref380d8178.padding))
	x.TouchPadding = *NewVec2Ref(unsafe.Pointer(&x.ref380d8178.touch_padding))
	x.Spacing = (float32)(x.ref380d8178.spacing)
	x.Border = (float32)(x.ref380d8178.border)
	x.Userdata = *(*Handle)(unsafe.Pointer(&x.ref380d8178.userdata))
	// x.DrawBegin is a callback func
	// x.DrawEnd is a callback func
}

// allocStructNkStyleMemory allocates memory for type C.struct_nk_style in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkStyleMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkStyleValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkStyleValue = unsafe.Sizeof([1]C.struct_nk_style{})

// allocStructNkUserFontMemory allocates memory for type C.struct_nk_user_font in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkUserFontMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkUserFontValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkUserFontValue = unsafe.Sizeof([1]C.struct_nk_user_font{})

// unpackSUserFont transforms a sliced Go data structure into plain C format.
func unpackSUserFont(x []UserFont) (unpacked *C.struct_nk_user_font, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.struct_nk_user_font) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocStructNkUserFontMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_nk_user_font)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_nk_user_font)(unsafe.Pointer(h.Data))
	return
}

// allocA7PStructNkCursorMemory allocates memory for type [7]*C.struct_nk_cursor in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA7PStructNkCursorMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfA7PStructNkCursorValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfA7PStructNkCursorValue = unsafe.Sizeof([1][7]*C.struct_nk_cursor{})

// unpackA7PCursor transforms a sliced Go data structure into plain C format.
func unpackA7PCursor(x [7]*Cursor) (unpacked [7]*C.struct_nk_cursor, allocs *cgoAllocMap) {
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(*[7]*C.struct_nk_cursor) {
		go allocs.Free()
	})

	mem0 := allocA7PStructNkCursorMemory(1)
	allocs.Add(mem0)
	v0 := (*[7]*C.struct_nk_cursor)(mem0)
	for i0 := range x {
		v0[i0], _ = x[i0].PassRef()
	}
	unpacked = *(*[7]*C.struct_nk_cursor)(mem0)
	return
}

// allocStructNkCursorMemory allocates memory for type C.struct_nk_cursor in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkCursorMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkCursorValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkCursorValue = unsafe.Sizeof([1]C.struct_nk_cursor{})

// unpackSCursor transforms a sliced Go data structure into plain C format.
func unpackSCursor(x []Cursor) (unpacked *C.struct_nk_cursor, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.struct_nk_cursor) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocStructNkCursorMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_nk_cursor)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_nk_cursor)(unsafe.Pointer(h.Data))
	return
}

// packSUserFont reads sliced Go data structure out from plain C format.
func packSUserFont(v []UserFont, ptr0 *C.struct_nk_user_font) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStructNkUserFontValue]C.struct_nk_user_font)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewUserFontRef(unsafe.Pointer(&ptr1))
	}
}

// packA7PCursor reads sliced Go data structure out from plain C format.
func packA7PCursor(v *[7]*Cursor, ptr0 *[7]*C.struct_nk_cursor) {
	for i0 := range v {
		ptr1 := ptr0[i0]
		v[i0] = NewCursorRef(unsafe.Pointer(ptr1))
	}
}

// packSCursor reads sliced Go data structure out from plain C format.
func packSCursor(v []Cursor, ptr0 *C.struct_nk_cursor) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStructNkCursorValue]C.struct_nk_cursor)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewCursorRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Style) Ref() *C.struct_nk_style {
	if x == nil {
		return nil
	}
	return x.refa582b8fc
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Style) Free() {
	if x != nil && x.allocsa582b8fc != nil {
		x.allocsa582b8fc.(*cgoAllocMap).Free()
		x.refa582b8fc = nil
	}
}

// NewStyleRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewStyleRef(ref unsafe.Pointer) *Style {
	if ref == nil {
		return nil
	}
	obj := new(Style)
	obj.refa582b8fc = (*C.struct_nk_style)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Style) PassRef() (*C.struct_nk_style, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa582b8fc != nil {
		return x.refa582b8fc, nil
	}
	mema582b8fc := allocStructNkStyleMemory(1)
	refa582b8fc := (*C.struct_nk_style)(mema582b8fc)
	allocsa582b8fc := new(cgoAllocMap)
	var cfont_allocs *cgoAllocMap
	refa582b8fc.font, cfont_allocs = unpackSUserFont(x.Font)
	allocsa582b8fc.Borrow(cfont_allocs)

	var ccursors_allocs *cgoAllocMap
	refa582b8fc.cursors, ccursors_allocs = unpackA7PCursor(x.Cursors)
	allocsa582b8fc.Borrow(ccursors_allocs)

	var ccursor_active_allocs *cgoAllocMap
	refa582b8fc.cursor_active, ccursor_active_allocs = unpackSCursor(x.CursorActive)
	allocsa582b8fc.Borrow(ccursor_active_allocs)

	var ccursor_last_allocs *cgoAllocMap
	refa582b8fc.cursor_last, ccursor_last_allocs = unpackSCursor(x.CursorLast)
	allocsa582b8fc.Borrow(ccursor_last_allocs)

	var ccursor_visible_allocs *cgoAllocMap
	refa582b8fc.cursor_visible, ccursor_visible_allocs = (C.int)(x.CursorVisible), cgoAllocsUnknown
	allocsa582b8fc.Borrow(ccursor_visible_allocs)

	var ctext_allocs *cgoAllocMap
	refa582b8fc.text, ctext_allocs = x.Text.PassValue()
	allocsa582b8fc.Borrow(ctext_allocs)

	var cbutton_allocs *cgoAllocMap
	refa582b8fc.button, cbutton_allocs = x.Button.PassValue()
	allocsa582b8fc.Borrow(cbutton_allocs)

	var ccontextual_button_allocs *cgoAllocMap
	refa582b8fc.contextual_button, ccontextual_button_allocs = x.ContextualButton.PassValue()
	allocsa582b8fc.Borrow(ccontextual_button_allocs)

	var cmenu_button_allocs *cgoAllocMap
	refa582b8fc.menu_button, cmenu_button_allocs = x.MenuButton.PassValue()
	allocsa582b8fc.Borrow(cmenu_button_allocs)

	var coption_allocs *cgoAllocMap
	refa582b8fc.option, coption_allocs = x.Option.PassValue()
	allocsa582b8fc.Borrow(coption_allocs)

	var ccheckbox_allocs *cgoAllocMap
	refa582b8fc.checkbox, ccheckbox_allocs = x.Checkbox.PassValue()
	allocsa582b8fc.Borrow(ccheckbox_allocs)

	var cselectable_allocs *cgoAllocMap
	refa582b8fc.selectable, cselectable_allocs = x.Selectable.PassValue()
	allocsa582b8fc.Borrow(cselectable_allocs)

	var cslider_allocs *cgoAllocMap
	refa582b8fc.slider, cslider_allocs = x.Slider.PassValue()
	allocsa582b8fc.Borrow(cslider_allocs)

	var cprogress_allocs *cgoAllocMap
	refa582b8fc.progress, cprogress_allocs = x.Progress.PassValue()
	allocsa582b8fc.Borrow(cprogress_allocs)

	var cproperty_allocs *cgoAllocMap
	refa582b8fc.property, cproperty_allocs = x.Property.PassValue()
	allocsa582b8fc.Borrow(cproperty_allocs)

	var cedit_allocs *cgoAllocMap
	refa582b8fc.edit, cedit_allocs = x.Edit.PassValue()
	allocsa582b8fc.Borrow(cedit_allocs)

	var cchart_allocs *cgoAllocMap
	refa582b8fc.chart, cchart_allocs = x.Chart.PassValue()
	allocsa582b8fc.Borrow(cchart_allocs)

	var cscrollh_allocs *cgoAllocMap
	refa582b8fc.scrollh, cscrollh_allocs = x.Scrollh.PassValue()
	allocsa582b8fc.Borrow(cscrollh_allocs)

	var cscrollv_allocs *cgoAllocMap
	refa582b8fc.scrollv, cscrollv_allocs = x.Scrollv.PassValue()
	allocsa582b8fc.Borrow(cscrollv_allocs)

	var ctab_allocs *cgoAllocMap
	refa582b8fc.tab, ctab_allocs = x.Tab.PassValue()
	allocsa582b8fc.Borrow(ctab_allocs)

	var ccombo_allocs *cgoAllocMap
	refa582b8fc.combo, ccombo_allocs = x.Combo.PassValue()
	allocsa582b8fc.Borrow(ccombo_allocs)

	var cwindow_allocs *cgoAllocMap
	refa582b8fc.window, cwindow_allocs = x.Window.PassValue()
	allocsa582b8fc.Borrow(cwindow_allocs)

	x.refa582b8fc = refa582b8fc
	x.allocsa582b8fc = allocsa582b8fc
	return refa582b8fc, allocsa582b8fc

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Style) PassValue() (C.struct_nk_style, *cgoAllocMap) {
	if x.refa582b8fc != nil {
		return *x.refa582b8fc, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Style) Deref() {
	if x.refa582b8fc == nil {
		return
	}
	packSUserFont(x.Font, x.refa582b8fc.font)
	packA7PCursor(&x.Cursors, (*[7]*C.struct_nk_cursor)(unsafe.Pointer(&x.refa582b8fc.cursors)))
	packSCursor(x.CursorActive, x.refa582b8fc.cursor_active)
	packSCursor(x.CursorLast, x.refa582b8fc.cursor_last)
	x.CursorVisible = (int32)(x.refa582b8fc.cursor_visible)
	x.Text = *NewStyleTextRef(unsafe.Pointer(&x.refa582b8fc.text))
	x.Button = *NewStyleButtonRef(unsafe.Pointer(&x.refa582b8fc.button))
	x.ContextualButton = *NewStyleButtonRef(unsafe.Pointer(&x.refa582b8fc.contextual_button))
	x.MenuButton = *NewStyleButtonRef(unsafe.Pointer(&x.refa582b8fc.menu_button))
	x.Option = *NewStyleToggleRef(unsafe.Pointer(&x.refa582b8fc.option))
	x.Checkbox = *NewStyleToggleRef(unsafe.Pointer(&x.refa582b8fc.checkbox))
	x.Selectable = *NewStyleSelectableRef(unsafe.Pointer(&x.refa582b8fc.selectable))
	x.Slider = *NewStyleSliderRef(unsafe.Pointer(&x.refa582b8fc.slider))
	x.Progress = *NewStyleProgressRef(unsafe.Pointer(&x.refa582b8fc.progress))
	x.Property = *NewStylePropertyRef(unsafe.Pointer(&x.refa582b8fc.property))
	x.Edit = *NewStyleEditRef(unsafe.Pointer(&x.refa582b8fc.edit))
	x.Chart = *NewStyleChartRef(unsafe.Pointer(&x.refa582b8fc.chart))
	x.Scrollh = *NewStyleScrollbarRef(unsafe.Pointer(&x.refa582b8fc.scrollh))
	x.Scrollv = *NewStyleScrollbarRef(unsafe.Pointer(&x.refa582b8fc.scrollv))
	x.Tab = *NewStyleTabRef(unsafe.Pointer(&x.refa582b8fc.tab))
	x.Combo = *NewStyleComboRef(unsafe.Pointer(&x.refa582b8fc.combo))
	x.Window = *NewStyleWindowRef(unsafe.Pointer(&x.refa582b8fc.window))
}

// allocStructNkChartMemory allocates memory for type C.struct_nk_chart in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkChartMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkChartValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkChartValue = unsafe.Sizeof([1]C.struct_nk_chart{})

// allocA4StructNkChartSlotMemory allocates memory for type [4]C.struct_nk_chart_slot in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA4StructNkChartSlotMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfA4StructNkChartSlotValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfA4StructNkChartSlotValue = unsafe.Sizeof([1][4]C.struct_nk_chart_slot{})

// unpackA4ChartSlot transforms a sliced Go data structure into plain C format.
func unpackA4ChartSlot(x [4]ChartSlot) (unpacked [4]C.struct_nk_chart_slot, allocs *cgoAllocMap) {
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(*[4]C.struct_nk_chart_slot) {
		go allocs.Free()
	})

	mem0 := allocA4StructNkChartSlotMemory(1)
	allocs.Add(mem0)
	v0 := (*[4]C.struct_nk_chart_slot)(mem0)
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	unpacked = *(*[4]C.struct_nk_chart_slot)(mem0)
	return
}

// packA4ChartSlot reads sliced Go data structure out from plain C format.
func packA4ChartSlot(v *[4]ChartSlot, ptr0 *[4]C.struct_nk_chart_slot) {
	for i0 := range v {
		ptr1 := ptr0[i0]
		v[i0] = *NewChartSlotRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Chart) Ref() *C.struct_nk_chart {
	if x == nil {
		return nil
	}
	return x.ref73692abc
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Chart) Free() {
	if x != nil && x.allocs73692abc != nil {
		x.allocs73692abc.(*cgoAllocMap).Free()
		x.ref73692abc = nil
	}
}

// NewChartRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewChartRef(ref unsafe.Pointer) *Chart {
	if ref == nil {
		return nil
	}
	obj := new(Chart)
	obj.ref73692abc = (*C.struct_nk_chart)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Chart) PassRef() (*C.struct_nk_chart, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref73692abc != nil {
		return x.ref73692abc, nil
	}
	mem73692abc := allocStructNkChartMemory(1)
	ref73692abc := (*C.struct_nk_chart)(mem73692abc)
	allocs73692abc := new(cgoAllocMap)
	var cslots_allocs *cgoAllocMap
	ref73692abc.slots, cslots_allocs = unpackA4ChartSlot(x.Slots)
	allocs73692abc.Borrow(cslots_allocs)

	var cslot_allocs *cgoAllocMap
	ref73692abc.slot, cslot_allocs = (C.int)(x.Slot), cgoAllocsUnknown
	allocs73692abc.Borrow(cslot_allocs)

	var cx_allocs *cgoAllocMap
	ref73692abc.x, cx_allocs = (C.float)(x.X), cgoAllocsUnknown
	allocs73692abc.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	ref73692abc.y, cy_allocs = (C.float)(x.Y), cgoAllocsUnknown
	allocs73692abc.Borrow(cy_allocs)

	var cw_allocs *cgoAllocMap
	ref73692abc.w, cw_allocs = (C.float)(x.W), cgoAllocsUnknown
	allocs73692abc.Borrow(cw_allocs)

	var ch_allocs *cgoAllocMap
	ref73692abc.h, ch_allocs = (C.float)(x.H), cgoAllocsUnknown
	allocs73692abc.Borrow(ch_allocs)

	x.ref73692abc = ref73692abc
	x.allocs73692abc = allocs73692abc
	return ref73692abc, allocs73692abc

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Chart) PassValue() (C.struct_nk_chart, *cgoAllocMap) {
	if x.ref73692abc != nil {
		return *x.ref73692abc, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Chart) Deref() {
	if x.ref73692abc == nil {
		return
	}
	packA4ChartSlot(&x.Slots, (*[4]C.struct_nk_chart_slot)(unsafe.Pointer(&x.ref73692abc.slots)))
	x.Slot = (int32)(x.ref73692abc.slot)
	x.X = (float32)(x.ref73692abc.x)
	x.Y = (float32)(x.ref73692abc.y)
	x.W = (float32)(x.ref73692abc.w)
	x.H = (float32)(x.ref73692abc.h)
}

// allocStructNkRectiMemory allocates memory for type C.struct_nk_recti in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkRectiMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkRectiValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkRectiValue = unsafe.Sizeof([1]C.struct_nk_recti{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Recti) Ref() *C.struct_nk_recti {
	if x == nil {
		return nil
	}
	return x.refea5b5362
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Recti) Free() {
	if x != nil && x.allocsea5b5362 != nil {
		x.allocsea5b5362.(*cgoAllocMap).Free()
		x.refea5b5362 = nil
	}
}

// NewRectiRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRectiRef(ref unsafe.Pointer) *Recti {
	if ref == nil {
		return nil
	}
	obj := new(Recti)
	obj.refea5b5362 = (*C.struct_nk_recti)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Recti) PassRef() (*C.struct_nk_recti, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refea5b5362 != nil {
		return x.refea5b5362, nil
	}
	memea5b5362 := allocStructNkRectiMemory(1)
	refea5b5362 := (*C.struct_nk_recti)(memea5b5362)
	allocsea5b5362 := new(cgoAllocMap)
	var cx_allocs *cgoAllocMap
	refea5b5362.x, cx_allocs = (C.short)(x.X), cgoAllocsUnknown
	allocsea5b5362.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	refea5b5362.y, cy_allocs = (C.short)(x.Y), cgoAllocsUnknown
	allocsea5b5362.Borrow(cy_allocs)

	var cw_allocs *cgoAllocMap
	refea5b5362.w, cw_allocs = (C.short)(x.W), cgoAllocsUnknown
	allocsea5b5362.Borrow(cw_allocs)

	var ch_allocs *cgoAllocMap
	refea5b5362.h, ch_allocs = (C.short)(x.H), cgoAllocsUnknown
	allocsea5b5362.Borrow(ch_allocs)

	x.refea5b5362 = refea5b5362
	x.allocsea5b5362 = allocsea5b5362
	return refea5b5362, allocsea5b5362

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Recti) PassValue() (C.struct_nk_recti, *cgoAllocMap) {
	if x.refea5b5362 != nil {
		return *x.refea5b5362, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Recti) Deref() {
	if x.refea5b5362 == nil {
		return
	}
	x.X = (int16)(x.refea5b5362.x)
	x.Y = (int16)(x.refea5b5362.y)
	x.W = (int16)(x.refea5b5362.w)
	x.H = (int16)(x.refea5b5362.h)
}

// allocStructNkStyleItemMemory allocates memory for type C.struct_nk_style_item in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkStyleItemMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkStyleItemValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkStyleItemValue = unsafe.Sizeof([1]C.struct_nk_style_item{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *StyleItem) Ref() *C.struct_nk_style_item {
	if x == nil {
		return nil
	}
	return x.ref26fd096e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *StyleItem) Free() {
	if x != nil && x.allocs26fd096e != nil {
		x.allocs26fd096e.(*cgoAllocMap).Free()
		x.ref26fd096e = nil
	}
}

// NewStyleItemRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewStyleItemRef(ref unsafe.Pointer) *StyleItem {
	if ref == nil {
		return nil
	}
	obj := new(StyleItem)
	obj.ref26fd096e = (*C.struct_nk_style_item)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *StyleItem) PassRef() (*C.struct_nk_style_item, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref26fd096e != nil {
		return x.ref26fd096e, nil
	}
	mem26fd096e := allocStructNkStyleItemMemory(1)
	ref26fd096e := (*C.struct_nk_style_item)(mem26fd096e)
	allocs26fd096e := new(cgoAllocMap)
	var c_type_allocs *cgoAllocMap
	ref26fd096e._type, c_type_allocs = (C.enum_nk_style_item_type)(x.Type), cgoAllocsUnknown
	allocs26fd096e.Borrow(c_type_allocs)

	var cdata_allocs *cgoAllocMap
	ref26fd096e.data, cdata_allocs = *(*C.union_nk_style_item_data)(unsafe.Pointer(&x.Data)), cgoAllocsUnknown
	allocs26fd096e.Borrow(cdata_allocs)

	x.ref26fd096e = ref26fd096e
	x.allocs26fd096e = allocs26fd096e
	return ref26fd096e, allocs26fd096e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x StyleItem) PassValue() (C.struct_nk_style_item, *cgoAllocMap) {
	if x.ref26fd096e != nil {
		return *x.ref26fd096e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *StyleItem) Deref() {
	if x.ref26fd096e == nil {
		return
	}
	x.Type = (StyleItemType)(x.ref26fd096e._type)
	x.Data = *(*StyleItemData)(unsafe.Pointer(&x.ref26fd096e.data))
}

// allocStructNkTextEditMemory allocates memory for type C.struct_nk_text_edit in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkTextEditMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkTextEditValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkTextEditValue = unsafe.Sizeof([1]C.struct_nk_text_edit{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TextEdit) Ref() *C.struct_nk_text_edit {
	if x == nil {
		return nil
	}
	return x.ref5fd2021a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TextEdit) Free() {
	if x != nil && x.allocs5fd2021a != nil {
		x.allocs5fd2021a.(*cgoAllocMap).Free()
		x.ref5fd2021a = nil
	}
}

// NewTextEditRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTextEditRef(ref unsafe.Pointer) *TextEdit {
	if ref == nil {
		return nil
	}
	obj := new(TextEdit)
	obj.ref5fd2021a = (*C.struct_nk_text_edit)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TextEdit) PassRef() (*C.struct_nk_text_edit, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5fd2021a != nil {
		return x.ref5fd2021a, nil
	}
	mem5fd2021a := allocStructNkTextEditMemory(1)
	ref5fd2021a := (*C.struct_nk_text_edit)(mem5fd2021a)
	allocs5fd2021a := new(cgoAllocMap)
	var cclip_allocs *cgoAllocMap
	ref5fd2021a.clip, cclip_allocs = x.Clip.PassValue()
	allocs5fd2021a.Borrow(cclip_allocs)

	var cstring_allocs *cgoAllocMap
	ref5fd2021a.string, cstring_allocs = x.String.PassValue()
	allocs5fd2021a.Borrow(cstring_allocs)

	var cfilter_allocs *cgoAllocMap
	ref5fd2021a.filter, cfilter_allocs = x.Filter.PassValue()
	allocs5fd2021a.Borrow(cfilter_allocs)

	var cscrollbar_allocs *cgoAllocMap
	ref5fd2021a.scrollbar, cscrollbar_allocs = x.Scrollbar.PassValue()
	allocs5fd2021a.Borrow(cscrollbar_allocs)

	var ccursor_allocs *cgoAllocMap
	ref5fd2021a.cursor, ccursor_allocs = (C.int)(x.Cursor), cgoAllocsUnknown
	allocs5fd2021a.Borrow(ccursor_allocs)

	var cselect_start_allocs *cgoAllocMap
	ref5fd2021a.select_start, cselect_start_allocs = (C.int)(x.SelectStart), cgoAllocsUnknown
	allocs5fd2021a.Borrow(cselect_start_allocs)

	var cselect_end_allocs *cgoAllocMap
	ref5fd2021a.select_end, cselect_end_allocs = (C.int)(x.SelectEnd), cgoAllocsUnknown
	allocs5fd2021a.Borrow(cselect_end_allocs)

	var cmode_allocs *cgoAllocMap
	ref5fd2021a.mode, cmode_allocs = (C.uchar)(x.Mode), cgoAllocsUnknown
	allocs5fd2021a.Borrow(cmode_allocs)

	var ccursor_at_end_of_line_allocs *cgoAllocMap
	ref5fd2021a.cursor_at_end_of_line, ccursor_at_end_of_line_allocs = (C.uchar)(x.CursorAtEndOfLine), cgoAllocsUnknown
	allocs5fd2021a.Borrow(ccursor_at_end_of_line_allocs)

	var cinitialized_allocs *cgoAllocMap
	ref5fd2021a.initialized, cinitialized_allocs = (C.uchar)(x.Initialized), cgoAllocsUnknown
	allocs5fd2021a.Borrow(cinitialized_allocs)

	var chas_preferred_x_allocs *cgoAllocMap
	ref5fd2021a.has_preferred_x, chas_preferred_x_allocs = (C.uchar)(x.HasPreferredX), cgoAllocsUnknown
	allocs5fd2021a.Borrow(chas_preferred_x_allocs)

	var csingle_line_allocs *cgoAllocMap
	ref5fd2021a.single_line, csingle_line_allocs = (C.uchar)(x.SingleLine), cgoAllocsUnknown
	allocs5fd2021a.Borrow(csingle_line_allocs)

	var cactive_allocs *cgoAllocMap
	ref5fd2021a.active, cactive_allocs = (C.uchar)(x.Active), cgoAllocsUnknown
	allocs5fd2021a.Borrow(cactive_allocs)

	var cpadding1_allocs *cgoAllocMap
	ref5fd2021a.padding1, cpadding1_allocs = (C.uchar)(x.Padding1), cgoAllocsUnknown
	allocs5fd2021a.Borrow(cpadding1_allocs)

	var cpreferred_x_allocs *cgoAllocMap
	ref5fd2021a.preferred_x, cpreferred_x_allocs = (C.float)(x.PreferredX), cgoAllocsUnknown
	allocs5fd2021a.Borrow(cpreferred_x_allocs)

	var cundo_allocs *cgoAllocMap
	ref5fd2021a.undo, cundo_allocs = x.Undo.PassValue()
	allocs5fd2021a.Borrow(cundo_allocs)

	x.ref5fd2021a = ref5fd2021a
	x.allocs5fd2021a = allocs5fd2021a
	return ref5fd2021a, allocs5fd2021a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TextEdit) PassValue() (C.struct_nk_text_edit, *cgoAllocMap) {
	if x.ref5fd2021a != nil {
		return *x.ref5fd2021a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TextEdit) Deref() {
	if x.ref5fd2021a == nil {
		return
	}
	x.Clip = *NewClipboardRef(unsafe.Pointer(&x.ref5fd2021a.clip))
	x.String = *NewStrRef(unsafe.Pointer(&x.ref5fd2021a.string))
	// x.Filter is a callback func
	x.Scrollbar = *NewVec2Ref(unsafe.Pointer(&x.ref5fd2021a.scrollbar))
	x.Cursor = (int32)(x.ref5fd2021a.cursor)
	x.SelectStart = (int32)(x.ref5fd2021a.select_start)
	x.SelectEnd = (int32)(x.ref5fd2021a.select_end)
	x.Mode = (byte)(x.ref5fd2021a.mode)
	x.CursorAtEndOfLine = (byte)(x.ref5fd2021a.cursor_at_end_of_line)
	x.Initialized = (byte)(x.ref5fd2021a.initialized)
	x.HasPreferredX = (byte)(x.ref5fd2021a.has_preferred_x)
	x.SingleLine = (byte)(x.ref5fd2021a.single_line)
	x.Active = (byte)(x.ref5fd2021a.active)
	x.Padding1 = (byte)(x.ref5fd2021a.padding1)
	x.PreferredX = (float32)(x.ref5fd2021a.preferred_x)
	x.Undo = *NewTextUndoStateRef(unsafe.Pointer(&x.ref5fd2021a.undo))
}

// allocStructNkImageMemory allocates memory for type C.struct_nk_image in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkImageMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkImageValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkImageValue = unsafe.Sizeof([1]C.struct_nk_image{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Image) Ref() *C.struct_nk_image {
	if x == nil {
		return nil
	}
	return x.ref530204c9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Image) Free() {
	if x != nil && x.allocs530204c9 != nil {
		x.allocs530204c9.(*cgoAllocMap).Free()
		x.ref530204c9 = nil
	}
}

// NewImageRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageRef(ref unsafe.Pointer) *Image {
	if ref == nil {
		return nil
	}
	obj := new(Image)
	obj.ref530204c9 = (*C.struct_nk_image)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Image) PassRef() (*C.struct_nk_image, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref530204c9 != nil {
		return x.ref530204c9, nil
	}
	mem530204c9 := allocStructNkImageMemory(1)
	ref530204c9 := (*C.struct_nk_image)(mem530204c9)
	allocs530204c9 := new(cgoAllocMap)
	var chandle_allocs *cgoAllocMap
	ref530204c9.handle, chandle_allocs = *(*C.nk_handle)(unsafe.Pointer(&x.Handle)), cgoAllocsUnknown
	allocs530204c9.Borrow(chandle_allocs)

	var cw_allocs *cgoAllocMap
	ref530204c9.w, cw_allocs = (C.ushort)(x.W), cgoAllocsUnknown
	allocs530204c9.Borrow(cw_allocs)

	var ch_allocs *cgoAllocMap
	ref530204c9.h, ch_allocs = (C.ushort)(x.H), cgoAllocsUnknown
	allocs530204c9.Borrow(ch_allocs)

	var cregion_allocs *cgoAllocMap
	ref530204c9.region, cregion_allocs = *(*[4]C.ushort)(unsafe.Pointer(&x.Region)), cgoAllocsUnknown
	allocs530204c9.Borrow(cregion_allocs)

	x.ref530204c9 = ref530204c9
	x.allocs530204c9 = allocs530204c9
	return ref530204c9, allocs530204c9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Image) PassValue() (C.struct_nk_image, *cgoAllocMap) {
	if x.ref530204c9 != nil {
		return *x.ref530204c9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Image) Deref() {
	if x.ref530204c9 == nil {
		return
	}
	x.Handle = *(*Handle)(unsafe.Pointer(&x.ref530204c9.handle))
	x.W = (uint16)(x.ref530204c9.w)
	x.H = (uint16)(x.ref530204c9.h)
	x.Region = *(*[4]uint16)(unsafe.Pointer(&x.ref530204c9.region))
}

// allocStructNkCommandRectMultiColorMemory allocates memory for type C.struct_nk_command_rect_multi_color in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkCommandRectMultiColorMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkCommandRectMultiColorValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkCommandRectMultiColorValue = unsafe.Sizeof([1]C.struct_nk_command_rect_multi_color{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CommandRectMultiColor) Ref() *C.struct_nk_command_rect_multi_color {
	if x == nil {
		return nil
	}
	return x.ref49471261
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CommandRectMultiColor) Free() {
	if x != nil && x.allocs49471261 != nil {
		x.allocs49471261.(*cgoAllocMap).Free()
		x.ref49471261 = nil
	}
}

// NewCommandRectMultiColorRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCommandRectMultiColorRef(ref unsafe.Pointer) *CommandRectMultiColor {
	if ref == nil {
		return nil
	}
	obj := new(CommandRectMultiColor)
	obj.ref49471261 = (*C.struct_nk_command_rect_multi_color)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CommandRectMultiColor) PassRef() (*C.struct_nk_command_rect_multi_color, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref49471261 != nil {
		return x.ref49471261, nil
	}
	mem49471261 := allocStructNkCommandRectMultiColorMemory(1)
	ref49471261 := (*C.struct_nk_command_rect_multi_color)(mem49471261)
	allocs49471261 := new(cgoAllocMap)
	var cheader_allocs *cgoAllocMap
	ref49471261.header, cheader_allocs = x.Header.PassValue()
	allocs49471261.Borrow(cheader_allocs)

	var cx_allocs *cgoAllocMap
	ref49471261.x, cx_allocs = (C.short)(x.X), cgoAllocsUnknown
	allocs49471261.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	ref49471261.y, cy_allocs = (C.short)(x.Y), cgoAllocsUnknown
	allocs49471261.Borrow(cy_allocs)

	var cw_allocs *cgoAllocMap
	ref49471261.w, cw_allocs = (C.ushort)(x.W), cgoAllocsUnknown
	allocs49471261.Borrow(cw_allocs)

	var ch_allocs *cgoAllocMap
	ref49471261.h, ch_allocs = (C.ushort)(x.H), cgoAllocsUnknown
	allocs49471261.Borrow(ch_allocs)

	var cleft_allocs *cgoAllocMap
	ref49471261.left, cleft_allocs = x.Left.PassValue()
	allocs49471261.Borrow(cleft_allocs)

	var ctop_allocs *cgoAllocMap
	ref49471261.top, ctop_allocs = x.Top.PassValue()
	allocs49471261.Borrow(ctop_allocs)

	var cbottom_allocs *cgoAllocMap
	ref49471261.bottom, cbottom_allocs = x.Bottom.PassValue()
	allocs49471261.Borrow(cbottom_allocs)

	var cright_allocs *cgoAllocMap
	ref49471261.right, cright_allocs = x.Right.PassValue()
	allocs49471261.Borrow(cright_allocs)

	x.ref49471261 = ref49471261
	x.allocs49471261 = allocs49471261
	return ref49471261, allocs49471261

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CommandRectMultiColor) PassValue() (C.struct_nk_command_rect_multi_color, *cgoAllocMap) {
	if x.ref49471261 != nil {
		return *x.ref49471261, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CommandRectMultiColor) Deref() {
	if x.ref49471261 == nil {
		return
	}
	x.Header = *NewCommandRef(unsafe.Pointer(&x.ref49471261.header))
	x.X = (int16)(x.ref49471261.x)
	x.Y = (int16)(x.ref49471261.y)
	x.W = (uint16)(x.ref49471261.w)
	x.H = (uint16)(x.ref49471261.h)
	x.Left = *NewColorRef(unsafe.Pointer(&x.ref49471261.left))
	x.Top = *NewColorRef(unsafe.Pointer(&x.ref49471261.top))
	x.Bottom = *NewColorRef(unsafe.Pointer(&x.ref49471261.bottom))
	x.Right = *NewColorRef(unsafe.Pointer(&x.ref49471261.right))
}

// allocStructNkColorfMemory allocates memory for type C.struct_nk_colorf in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkColorfMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkColorfValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkColorfValue = unsafe.Sizeof([1]C.struct_nk_colorf{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Colorf) Ref() *C.struct_nk_colorf {
	if x == nil {
		return nil
	}
	return x.refb6992e05
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Colorf) Free() {
	if x != nil && x.allocsb6992e05 != nil {
		x.allocsb6992e05.(*cgoAllocMap).Free()
		x.refb6992e05 = nil
	}
}

// NewColorfRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewColorfRef(ref unsafe.Pointer) *Colorf {
	if ref == nil {
		return nil
	}
	obj := new(Colorf)
	obj.refb6992e05 = (*C.struct_nk_colorf)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Colorf) PassRef() (*C.struct_nk_colorf, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb6992e05 != nil {
		return x.refb6992e05, nil
	}
	memb6992e05 := allocStructNkColorfMemory(1)
	refb6992e05 := (*C.struct_nk_colorf)(memb6992e05)
	allocsb6992e05 := new(cgoAllocMap)
	var cr_allocs *cgoAllocMap
	refb6992e05.r, cr_allocs = (C.float)(x.R), cgoAllocsUnknown
	allocsb6992e05.Borrow(cr_allocs)

	var cg_allocs *cgoAllocMap
	refb6992e05.g, cg_allocs = (C.float)(x.G), cgoAllocsUnknown
	allocsb6992e05.Borrow(cg_allocs)

	var cb_allocs *cgoAllocMap
	refb6992e05.b, cb_allocs = (C.float)(x.B), cgoAllocsUnknown
	allocsb6992e05.Borrow(cb_allocs)

	var ca_allocs *cgoAllocMap
	refb6992e05.a, ca_allocs = (C.float)(x.A), cgoAllocsUnknown
	allocsb6992e05.Borrow(ca_allocs)

	x.refb6992e05 = refb6992e05
	x.allocsb6992e05 = allocsb6992e05
	return refb6992e05, allocsb6992e05

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Colorf) PassValue() (C.struct_nk_colorf, *cgoAllocMap) {
	if x.refb6992e05 != nil {
		return *x.refb6992e05, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Colorf) Deref() {
	if x.refb6992e05 == nil {
		return
	}
	x.R = (float32)(x.refb6992e05.r)
	x.G = (float32)(x.refb6992e05.g)
	x.B = (float32)(x.refb6992e05.b)
	x.A = (float32)(x.refb6992e05.a)
}

// allocStructNkConfigStackStyleItemElementMemory allocates memory for type C.struct_nk_config_stack_style_item_element in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkConfigStackStyleItemElementMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkConfigStackStyleItemElementValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkConfigStackStyleItemElementValue = unsafe.Sizeof([1]C.struct_nk_config_stack_style_item_element{})

// unpackSStyleItem transforms a sliced Go data structure into plain C format.
func unpackSStyleItem(x []StyleItem) (unpacked *C.struct_nk_style_item, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.struct_nk_style_item) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocStructNkStyleItemMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_nk_style_item)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_nk_style_item)(unsafe.Pointer(h.Data))
	return
}

// packSStyleItem reads sliced Go data structure out from plain C format.
func packSStyleItem(v []StyleItem, ptr0 *C.struct_nk_style_item) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStructNkStyleItemValue]C.struct_nk_style_item)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewStyleItemRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ConfigStackStyleItemElement) Ref() *C.struct_nk_config_stack_style_item_element {
	if x == nil {
		return nil
	}
	return x.ref3797a13d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ConfigStackStyleItemElement) Free() {
	if x != nil && x.allocs3797a13d != nil {
		x.allocs3797a13d.(*cgoAllocMap).Free()
		x.ref3797a13d = nil
	}
}

// NewConfigStackStyleItemElementRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewConfigStackStyleItemElementRef(ref unsafe.Pointer) *ConfigStackStyleItemElement {
	if ref == nil {
		return nil
	}
	obj := new(ConfigStackStyleItemElement)
	obj.ref3797a13d = (*C.struct_nk_config_stack_style_item_element)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ConfigStackStyleItemElement) PassRef() (*C.struct_nk_config_stack_style_item_element, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3797a13d != nil {
		return x.ref3797a13d, nil
	}
	mem3797a13d := allocStructNkConfigStackStyleItemElementMemory(1)
	ref3797a13d := (*C.struct_nk_config_stack_style_item_element)(mem3797a13d)
	allocs3797a13d := new(cgoAllocMap)
	var caddress_allocs *cgoAllocMap
	ref3797a13d.address, caddress_allocs = unpackSStyleItem(x.Address)
	allocs3797a13d.Borrow(caddress_allocs)

	var cold_value_allocs *cgoAllocMap
	ref3797a13d.old_value, cold_value_allocs = x.OldValue.PassValue()
	allocs3797a13d.Borrow(cold_value_allocs)

	x.ref3797a13d = ref3797a13d
	x.allocs3797a13d = allocs3797a13d
	return ref3797a13d, allocs3797a13d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ConfigStackStyleItemElement) PassValue() (C.struct_nk_config_stack_style_item_element, *cgoAllocMap) {
	if x.ref3797a13d != nil {
		return *x.ref3797a13d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ConfigStackStyleItemElement) Deref() {
	if x.ref3797a13d == nil {
		return
	}
	packSStyleItem(x.Address, x.ref3797a13d.address)
	x.OldValue = *NewStyleItemRef(unsafe.Pointer(&x.ref3797a13d.old_value))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Scroll) Ref() *C.struct_nk_scroll {
	if x == nil {
		return nil
	}
	return x.reff4ed37f2
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Scroll) Free() {
	if x != nil && x.allocsf4ed37f2 != nil {
		x.allocsf4ed37f2.(*cgoAllocMap).Free()
		x.reff4ed37f2 = nil
	}
}

// NewScrollRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewScrollRef(ref unsafe.Pointer) *Scroll {
	if ref == nil {
		return nil
	}
	obj := new(Scroll)
	obj.reff4ed37f2 = (*C.struct_nk_scroll)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Scroll) PassRef() (*C.struct_nk_scroll, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff4ed37f2 != nil {
		return x.reff4ed37f2, nil
	}
	memf4ed37f2 := allocStructNkScrollMemory(1)
	reff4ed37f2 := (*C.struct_nk_scroll)(memf4ed37f2)
	allocsf4ed37f2 := new(cgoAllocMap)
	var cx_allocs *cgoAllocMap
	reff4ed37f2.x, cx_allocs = (C.ushort)(x.X), cgoAllocsUnknown
	allocsf4ed37f2.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	reff4ed37f2.y, cy_allocs = (C.ushort)(x.Y), cgoAllocsUnknown
	allocsf4ed37f2.Borrow(cy_allocs)

	x.reff4ed37f2 = reff4ed37f2
	x.allocsf4ed37f2 = allocsf4ed37f2
	return reff4ed37f2, allocsf4ed37f2

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Scroll) PassValue() (C.struct_nk_scroll, *cgoAllocMap) {
	if x.reff4ed37f2 != nil {
		return *x.reff4ed37f2, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Scroll) Deref() {
	if x.reff4ed37f2 == nil {
		return
	}
	x.X = (uint16)(x.reff4ed37f2.x)
	x.Y = (uint16)(x.reff4ed37f2.y)
}

// allocStructNkCommandPolygonFilledMemory allocates memory for type C.struct_nk_command_polygon_filled in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkCommandPolygonFilledMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkCommandPolygonFilledValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkCommandPolygonFilledValue = unsafe.Sizeof([1]C.struct_nk_command_polygon_filled{})

// allocA1StructNkVec2iMemory allocates memory for type [1]C.struct_nk_vec2i in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA1StructNkVec2iMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfA1StructNkVec2iValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfA1StructNkVec2iValue = unsafe.Sizeof([1][1]C.struct_nk_vec2i{})

// unpackA1Vec2i transforms a sliced Go data structure into plain C format.
func unpackA1Vec2i(x [1]Vec2i) (unpacked [1]C.struct_nk_vec2i, allocs *cgoAllocMap) {
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(*[1]C.struct_nk_vec2i) {
		go allocs.Free()
	})

	mem0 := allocA1StructNkVec2iMemory(1)
	allocs.Add(mem0)
	v0 := (*[1]C.struct_nk_vec2i)(mem0)
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	unpacked = *(*[1]C.struct_nk_vec2i)(mem0)
	return
}

// packA1Vec2i reads sliced Go data structure out from plain C format.
func packA1Vec2i(v *[1]Vec2i, ptr0 *[1]C.struct_nk_vec2i) {
	for i0 := range v {
		ptr1 := ptr0[i0]
		v[i0] = *NewVec2iRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CommandPolygonFilled) Ref() *C.struct_nk_command_polygon_filled {
	if x == nil {
		return nil
	}
	return x.ref5893ac22
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CommandPolygonFilled) Free() {
	if x != nil && x.allocs5893ac22 != nil {
		x.allocs5893ac22.(*cgoAllocMap).Free()
		x.ref5893ac22 = nil
	}
}

// NewCommandPolygonFilledRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCommandPolygonFilledRef(ref unsafe.Pointer) *CommandPolygonFilled {
	if ref == nil {
		return nil
	}
	obj := new(CommandPolygonFilled)
	obj.ref5893ac22 = (*C.struct_nk_command_polygon_filled)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CommandPolygonFilled) PassRef() (*C.struct_nk_command_polygon_filled, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5893ac22 != nil {
		return x.ref5893ac22, nil
	}
	mem5893ac22 := allocStructNkCommandPolygonFilledMemory(1)
	ref5893ac22 := (*C.struct_nk_command_polygon_filled)(mem5893ac22)
	allocs5893ac22 := new(cgoAllocMap)
	var cheader_allocs *cgoAllocMap
	ref5893ac22.header, cheader_allocs = x.Header.PassValue()
	allocs5893ac22.Borrow(cheader_allocs)

	var ccolor_allocs *cgoAllocMap
	ref5893ac22.color, ccolor_allocs = x.Color.PassValue()
	allocs5893ac22.Borrow(ccolor_allocs)

	var cpoint_count_allocs *cgoAllocMap
	ref5893ac22.point_count, cpoint_count_allocs = (C.ushort)(x.PointCount), cgoAllocsUnknown
	allocs5893ac22.Borrow(cpoint_count_allocs)

	var cpoints_allocs *cgoAllocMap
	ref5893ac22.points, cpoints_allocs = unpackA1Vec2i(x.Points)
	allocs5893ac22.Borrow(cpoints_allocs)

	x.ref5893ac22 = ref5893ac22
	x.allocs5893ac22 = allocs5893ac22
	return ref5893ac22, allocs5893ac22

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CommandPolygonFilled) PassValue() (C.struct_nk_command_polygon_filled, *cgoAllocMap) {
	if x.ref5893ac22 != nil {
		return *x.ref5893ac22, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CommandPolygonFilled) Deref() {
	if x.ref5893ac22 == nil {
		return
	}
	x.Header = *NewCommandRef(unsafe.Pointer(&x.ref5893ac22.header))
	x.Color = *NewColorRef(unsafe.Pointer(&x.ref5893ac22.color))
	x.PointCount = (uint16)(x.ref5893ac22.point_count)
	packA1Vec2i(&x.Points, (*[1]C.struct_nk_vec2i)(unsafe.Pointer(&x.ref5893ac22.points)))
}

// allocStructNkTableMemory allocates memory for type C.struct_nk_table in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkTableMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkTableValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkTableValue = unsafe.Sizeof([1]C.struct_nk_table{})

// unpackSTable transforms a sliced Go data structure into plain C format.
func unpackSTable(x []Table) (unpacked *C.struct_nk_table, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.struct_nk_table) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocStructNkTableMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_nk_table)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_nk_table)(unsafe.Pointer(h.Data))
	return
}

// packSTable reads sliced Go data structure out from plain C format.
func packSTable(v []Table, ptr0 *C.struct_nk_table) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStructNkTableValue]C.struct_nk_table)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTableRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Table) Ref() *C.struct_nk_table {
	if x == nil {
		return nil
	}
	return x.ref60168fd0
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Table) Free() {
	if x != nil && x.allocs60168fd0 != nil {
		x.allocs60168fd0.(*cgoAllocMap).Free()
		x.ref60168fd0 = nil
	}
}

// NewTableRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTableRef(ref unsafe.Pointer) *Table {
	if ref == nil {
		return nil
	}
	obj := new(Table)
	obj.ref60168fd0 = (*C.struct_nk_table)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Table) PassRef() (*C.struct_nk_table, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref60168fd0 != nil {
		return x.ref60168fd0, nil
	}
	mem60168fd0 := allocStructNkTableMemory(1)
	ref60168fd0 := (*C.struct_nk_table)(mem60168fd0)
	allocs60168fd0 := new(cgoAllocMap)
	var cseq_allocs *cgoAllocMap
	ref60168fd0.seq, cseq_allocs = (C.uint)(x.Seq), cgoAllocsUnknown
	allocs60168fd0.Borrow(cseq_allocs)

	var ckeys_allocs *cgoAllocMap
	ref60168fd0.keys, ckeys_allocs = *(*[52]C.nk_hash)(unsafe.Pointer(&x.Keys)), cgoAllocsUnknown
	allocs60168fd0.Borrow(ckeys_allocs)

	var cvalues_allocs *cgoAllocMap
	ref60168fd0.values, cvalues_allocs = *(*[52]C.nk_uint)(unsafe.Pointer(&x.Values)), cgoAllocsUnknown
	allocs60168fd0.Borrow(cvalues_allocs)

	var cnext_allocs *cgoAllocMap
	ref60168fd0.next, cnext_allocs = unpackSTable(x.Next)
	allocs60168fd0.Borrow(cnext_allocs)

	var cprev_allocs *cgoAllocMap
	ref60168fd0.prev, cprev_allocs = unpackSTable(x.Prev)
	allocs60168fd0.Borrow(cprev_allocs)

	x.ref60168fd0 = ref60168fd0
	x.allocs60168fd0 = allocs60168fd0
	return ref60168fd0, allocs60168fd0

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Table) PassValue() (C.struct_nk_table, *cgoAllocMap) {
	if x.ref60168fd0 != nil {
		return *x.ref60168fd0, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Table) Deref() {
	if x.ref60168fd0 == nil {
		return
	}
	x.Seq = (uint32)(x.ref60168fd0.seq)
	x.Keys = *(*[52]Hash)(unsafe.Pointer(&x.ref60168fd0.keys))
	x.Values = *(*[52]Uint)(unsafe.Pointer(&x.ref60168fd0.values))
	packSTable(x.Next, x.ref60168fd0.next)
	packSTable(x.Prev, x.ref60168fd0.prev)
}

// Ref returns a reference to C object as it is.
func (x *DrawList) Ref() *C.struct_nk_draw_list {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_draw_list)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *DrawList) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewDrawListRef converts the C object reference into a raw struct reference without wrapping.
func NewDrawListRef(ref *C.struct_nk_draw_list) *DrawList {
	return (*DrawList)(unsafe.Pointer(ref))
}

// NewDrawList allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewDrawList() *DrawList {
	return (*DrawList)(allocStructNkDrawListMemory(1))
}

// allocStructNkDrawListMemory allocates memory for type C.struct_nk_draw_list in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkDrawListMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkDrawListValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkDrawListValue = unsafe.Sizeof([1]C.struct_nk_draw_list{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *DrawList) PassRef() *C.struct_nk_draw_list {
	if x == nil {
		x = (*DrawList)(allocStructNkDrawListMemory(1))
	}
	return (*C.struct_nk_draw_list)(unsafe.Pointer(x))
}

// allocStructNkStyleChartMemory allocates memory for type C.struct_nk_style_chart in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkStyleChartMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkStyleChartValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkStyleChartValue = unsafe.Sizeof([1]C.struct_nk_style_chart{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *StyleChart) Ref() *C.struct_nk_style_chart {
	if x == nil {
		return nil
	}
	return x.refb56abd3a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *StyleChart) Free() {
	if x != nil && x.allocsb56abd3a != nil {
		x.allocsb56abd3a.(*cgoAllocMap).Free()
		x.refb56abd3a = nil
	}
}

// NewStyleChartRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewStyleChartRef(ref unsafe.Pointer) *StyleChart {
	if ref == nil {
		return nil
	}
	obj := new(StyleChart)
	obj.refb56abd3a = (*C.struct_nk_style_chart)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *StyleChart) PassRef() (*C.struct_nk_style_chart, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb56abd3a != nil {
		return x.refb56abd3a, nil
	}
	memb56abd3a := allocStructNkStyleChartMemory(1)
	refb56abd3a := (*C.struct_nk_style_chart)(memb56abd3a)
	allocsb56abd3a := new(cgoAllocMap)
	var cbackground_allocs *cgoAllocMap
	refb56abd3a.background, cbackground_allocs = x.Background.PassValue()
	allocsb56abd3a.Borrow(cbackground_allocs)

	var cborder_color_allocs *cgoAllocMap
	refb56abd3a.border_color, cborder_color_allocs = x.BorderColor.PassValue()
	allocsb56abd3a.Borrow(cborder_color_allocs)

	var cselected_color_allocs *cgoAllocMap
	refb56abd3a.selected_color, cselected_color_allocs = x.SelectedColor.PassValue()
	allocsb56abd3a.Borrow(cselected_color_allocs)

	var ccolor_allocs *cgoAllocMap
	refb56abd3a.color, ccolor_allocs = x.Color.PassValue()
	allocsb56abd3a.Borrow(ccolor_allocs)

	var cborder_allocs *cgoAllocMap
	refb56abd3a.border, cborder_allocs = (C.float)(x.Border), cgoAllocsUnknown
	allocsb56abd3a.Borrow(cborder_allocs)

	var crounding_allocs *cgoAllocMap
	refb56abd3a.rounding, crounding_allocs = (C.float)(x.Rounding), cgoAllocsUnknown
	allocsb56abd3a.Borrow(crounding_allocs)

	var cpadding_allocs *cgoAllocMap
	refb56abd3a.padding, cpadding_allocs = x.Padding.PassValue()
	allocsb56abd3a.Borrow(cpadding_allocs)

	x.refb56abd3a = refb56abd3a
	x.allocsb56abd3a = allocsb56abd3a
	return refb56abd3a, allocsb56abd3a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x StyleChart) PassValue() (C.struct_nk_style_chart, *cgoAllocMap) {
	if x.refb56abd3a != nil {
		return *x.refb56abd3a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *StyleChart) Deref() {
	if x.refb56abd3a == nil {
		return
	}
	x.Background = *NewStyleItemRef(unsafe.Pointer(&x.refb56abd3a.background))
	x.BorderColor = *NewColorRef(unsafe.Pointer(&x.refb56abd3a.border_color))
	x.SelectedColor = *NewColorRef(unsafe.Pointer(&x.refb56abd3a.selected_color))
	x.Color = *NewColorRef(unsafe.Pointer(&x.refb56abd3a.color))
	x.Border = (float32)(x.refb56abd3a.border)
	x.Rounding = (float32)(x.refb56abd3a.rounding)
	x.Padding = *NewVec2Ref(unsafe.Pointer(&x.refb56abd3a.padding))
}

// allocStructNkPopupBufferMemory allocates memory for type C.struct_nk_popup_buffer in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkPopupBufferMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkPopupBufferValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkPopupBufferValue = unsafe.Sizeof([1]C.struct_nk_popup_buffer{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PopupBuffer) Ref() *C.struct_nk_popup_buffer {
	if x == nil {
		return nil
	}
	return x.ref1ed9add1
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PopupBuffer) Free() {
	if x != nil && x.allocs1ed9add1 != nil {
		x.allocs1ed9add1.(*cgoAllocMap).Free()
		x.ref1ed9add1 = nil
	}
}

// NewPopupBufferRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPopupBufferRef(ref unsafe.Pointer) *PopupBuffer {
	if ref == nil {
		return nil
	}
	obj := new(PopupBuffer)
	obj.ref1ed9add1 = (*C.struct_nk_popup_buffer)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PopupBuffer) PassRef() (*C.struct_nk_popup_buffer, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1ed9add1 != nil {
		return x.ref1ed9add1, nil
	}
	mem1ed9add1 := allocStructNkPopupBufferMemory(1)
	ref1ed9add1 := (*C.struct_nk_popup_buffer)(mem1ed9add1)
	allocs1ed9add1 := new(cgoAllocMap)
	var cbegin_allocs *cgoAllocMap
	ref1ed9add1.begin, cbegin_allocs = (C.nk_size)(x.Begin), cgoAllocsUnknown
	allocs1ed9add1.Borrow(cbegin_allocs)

	var cparent_allocs *cgoAllocMap
	ref1ed9add1.parent, cparent_allocs = (C.nk_size)(x.Parent), cgoAllocsUnknown
	allocs1ed9add1.Borrow(cparent_allocs)

	var clast_allocs *cgoAllocMap
	ref1ed9add1.last, clast_allocs = (C.nk_size)(x.Last), cgoAllocsUnknown
	allocs1ed9add1.Borrow(clast_allocs)

	var cend_allocs *cgoAllocMap
	ref1ed9add1.end, cend_allocs = (C.nk_size)(x.End), cgoAllocsUnknown
	allocs1ed9add1.Borrow(cend_allocs)

	var cactive_allocs *cgoAllocMap
	ref1ed9add1.active, cactive_allocs = (C.int)(x.Active), cgoAllocsUnknown
	allocs1ed9add1.Borrow(cactive_allocs)

	x.ref1ed9add1 = ref1ed9add1
	x.allocs1ed9add1 = allocs1ed9add1
	return ref1ed9add1, allocs1ed9add1

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PopupBuffer) PassValue() (C.struct_nk_popup_buffer, *cgoAllocMap) {
	if x.ref1ed9add1 != nil {
		return *x.ref1ed9add1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PopupBuffer) Deref() {
	if x.ref1ed9add1 == nil {
		return
	}
	x.Begin = (Size)(x.ref1ed9add1.begin)
	x.Parent = (Size)(x.ref1ed9add1.parent)
	x.Last = (Size)(x.ref1ed9add1.last)
	x.End = (Size)(x.ref1ed9add1.end)
	x.Active = (int32)(x.ref1ed9add1.active)
}

// allocStructNkStyleComboMemory allocates memory for type C.struct_nk_style_combo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkStyleComboMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkStyleComboValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkStyleComboValue = unsafe.Sizeof([1]C.struct_nk_style_combo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *StyleCombo) Ref() *C.struct_nk_style_combo {
	if x == nil {
		return nil
	}
	return x.refe100a75a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *StyleCombo) Free() {
	if x != nil && x.allocse100a75a != nil {
		x.allocse100a75a.(*cgoAllocMap).Free()
		x.refe100a75a = nil
	}
}

// NewStyleComboRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewStyleComboRef(ref unsafe.Pointer) *StyleCombo {
	if ref == nil {
		return nil
	}
	obj := new(StyleCombo)
	obj.refe100a75a = (*C.struct_nk_style_combo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *StyleCombo) PassRef() (*C.struct_nk_style_combo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe100a75a != nil {
		return x.refe100a75a, nil
	}
	meme100a75a := allocStructNkStyleComboMemory(1)
	refe100a75a := (*C.struct_nk_style_combo)(meme100a75a)
	allocse100a75a := new(cgoAllocMap)
	var cnormal_allocs *cgoAllocMap
	refe100a75a.normal, cnormal_allocs = x.Normal.PassValue()
	allocse100a75a.Borrow(cnormal_allocs)

	var chover_allocs *cgoAllocMap
	refe100a75a.hover, chover_allocs = x.Hover.PassValue()
	allocse100a75a.Borrow(chover_allocs)

	var cactive_allocs *cgoAllocMap
	refe100a75a.active, cactive_allocs = x.Active.PassValue()
	allocse100a75a.Borrow(cactive_allocs)

	var cborder_color_allocs *cgoAllocMap
	refe100a75a.border_color, cborder_color_allocs = x.BorderColor.PassValue()
	allocse100a75a.Borrow(cborder_color_allocs)

	var clabel_normal_allocs *cgoAllocMap
	refe100a75a.label_normal, clabel_normal_allocs = x.LabelNormal.PassValue()
	allocse100a75a.Borrow(clabel_normal_allocs)

	var clabel_hover_allocs *cgoAllocMap
	refe100a75a.label_hover, clabel_hover_allocs = x.LabelHover.PassValue()
	allocse100a75a.Borrow(clabel_hover_allocs)

	var clabel_active_allocs *cgoAllocMap
	refe100a75a.label_active, clabel_active_allocs = x.LabelActive.PassValue()
	allocse100a75a.Borrow(clabel_active_allocs)

	var csymbol_normal_allocs *cgoAllocMap
	refe100a75a.symbol_normal, csymbol_normal_allocs = x.SymbolNormal.PassValue()
	allocse100a75a.Borrow(csymbol_normal_allocs)

	var csymbol_hover_allocs *cgoAllocMap
	refe100a75a.symbol_hover, csymbol_hover_allocs = x.SymbolHover.PassValue()
	allocse100a75a.Borrow(csymbol_hover_allocs)

	var csymbol_active_allocs *cgoAllocMap
	refe100a75a.symbol_active, csymbol_active_allocs = x.SymbolActive.PassValue()
	allocse100a75a.Borrow(csymbol_active_allocs)

	var cbutton_allocs *cgoAllocMap
	refe100a75a.button, cbutton_allocs = x.Button.PassValue()
	allocse100a75a.Borrow(cbutton_allocs)

	var csym_normal_allocs *cgoAllocMap
	refe100a75a.sym_normal, csym_normal_allocs = (C.enum_nk_symbol_type)(x.SymNormal), cgoAllocsUnknown
	allocse100a75a.Borrow(csym_normal_allocs)

	var csym_hover_allocs *cgoAllocMap
	refe100a75a.sym_hover, csym_hover_allocs = (C.enum_nk_symbol_type)(x.SymHover), cgoAllocsUnknown
	allocse100a75a.Borrow(csym_hover_allocs)

	var csym_active_allocs *cgoAllocMap
	refe100a75a.sym_active, csym_active_allocs = (C.enum_nk_symbol_type)(x.SymActive), cgoAllocsUnknown
	allocse100a75a.Borrow(csym_active_allocs)

	var cborder_allocs *cgoAllocMap
	refe100a75a.border, cborder_allocs = (C.float)(x.Border), cgoAllocsUnknown
	allocse100a75a.Borrow(cborder_allocs)

	var crounding_allocs *cgoAllocMap
	refe100a75a.rounding, crounding_allocs = (C.float)(x.Rounding), cgoAllocsUnknown
	allocse100a75a.Borrow(crounding_allocs)

	var ccontent_padding_allocs *cgoAllocMap
	refe100a75a.content_padding, ccontent_padding_allocs = x.ContentPadding.PassValue()
	allocse100a75a.Borrow(ccontent_padding_allocs)

	var cbutton_padding_allocs *cgoAllocMap
	refe100a75a.button_padding, cbutton_padding_allocs = x.ButtonPadding.PassValue()
	allocse100a75a.Borrow(cbutton_padding_allocs)

	var cspacing_allocs *cgoAllocMap
	refe100a75a.spacing, cspacing_allocs = x.Spacing.PassValue()
	allocse100a75a.Borrow(cspacing_allocs)

	x.refe100a75a = refe100a75a
	x.allocse100a75a = allocse100a75a
	return refe100a75a, allocse100a75a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x StyleCombo) PassValue() (C.struct_nk_style_combo, *cgoAllocMap) {
	if x.refe100a75a != nil {
		return *x.refe100a75a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *StyleCombo) Deref() {
	if x.refe100a75a == nil {
		return
	}
	x.Normal = *NewStyleItemRef(unsafe.Pointer(&x.refe100a75a.normal))
	x.Hover = *NewStyleItemRef(unsafe.Pointer(&x.refe100a75a.hover))
	x.Active = *NewStyleItemRef(unsafe.Pointer(&x.refe100a75a.active))
	x.BorderColor = *NewColorRef(unsafe.Pointer(&x.refe100a75a.border_color))
	x.LabelNormal = *NewColorRef(unsafe.Pointer(&x.refe100a75a.label_normal))
	x.LabelHover = *NewColorRef(unsafe.Pointer(&x.refe100a75a.label_hover))
	x.LabelActive = *NewColorRef(unsafe.Pointer(&x.refe100a75a.label_active))
	x.SymbolNormal = *NewColorRef(unsafe.Pointer(&x.refe100a75a.symbol_normal))
	x.SymbolHover = *NewColorRef(unsafe.Pointer(&x.refe100a75a.symbol_hover))
	x.SymbolActive = *NewColorRef(unsafe.Pointer(&x.refe100a75a.symbol_active))
	x.Button = *NewStyleButtonRef(unsafe.Pointer(&x.refe100a75a.button))
	x.SymNormal = (SymbolType)(x.refe100a75a.sym_normal)
	x.SymHover = (SymbolType)(x.refe100a75a.sym_hover)
	x.SymActive = (SymbolType)(x.refe100a75a.sym_active)
	x.Border = (float32)(x.refe100a75a.border)
	x.Rounding = (float32)(x.refe100a75a.rounding)
	x.ContentPadding = *NewVec2Ref(unsafe.Pointer(&x.refe100a75a.content_padding))
	x.ButtonPadding = *NewVec2Ref(unsafe.Pointer(&x.refe100a75a.button_padding))
	x.Spacing = *NewVec2Ref(unsafe.Pointer(&x.refe100a75a.spacing))
}

// allocStructNkRowLayoutMemory allocates memory for type C.struct_nk_row_layout in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkRowLayoutMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkRowLayoutValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkRowLayoutValue = unsafe.Sizeof([1]C.struct_nk_row_layout{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RowLayout) Ref() *C.struct_nk_row_layout {
	if x == nil {
		return nil
	}
	return x.ref3c76e5b1
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RowLayout) Free() {
	if x != nil && x.allocs3c76e5b1 != nil {
		x.allocs3c76e5b1.(*cgoAllocMap).Free()
		x.ref3c76e5b1 = nil
	}
}

// NewRowLayoutRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRowLayoutRef(ref unsafe.Pointer) *RowLayout {
	if ref == nil {
		return nil
	}
	obj := new(RowLayout)
	obj.ref3c76e5b1 = (*C.struct_nk_row_layout)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RowLayout) PassRef() (*C.struct_nk_row_layout, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3c76e5b1 != nil {
		return x.ref3c76e5b1, nil
	}
	mem3c76e5b1 := allocStructNkRowLayoutMemory(1)
	ref3c76e5b1 := (*C.struct_nk_row_layout)(mem3c76e5b1)
	allocs3c76e5b1 := new(cgoAllocMap)
	var c_type_allocs *cgoAllocMap
	ref3c76e5b1._type, c_type_allocs = (C.int)(x.Type), cgoAllocsUnknown
	allocs3c76e5b1.Borrow(c_type_allocs)

	var cindex_allocs *cgoAllocMap
	ref3c76e5b1.index, cindex_allocs = (C.int)(x.Index), cgoAllocsUnknown
	allocs3c76e5b1.Borrow(cindex_allocs)

	var cheight_allocs *cgoAllocMap
	ref3c76e5b1.height, cheight_allocs = (C.float)(x.Height), cgoAllocsUnknown
	allocs3c76e5b1.Borrow(cheight_allocs)

	var ccolumns_allocs *cgoAllocMap
	ref3c76e5b1.columns, ccolumns_allocs = (C.int)(x.Columns), cgoAllocsUnknown
	allocs3c76e5b1.Borrow(ccolumns_allocs)

	var cratio_allocs *cgoAllocMap
	ref3c76e5b1.ratio, cratio_allocs = (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Ratio)).Data)), cgoAllocsUnknown
	allocs3c76e5b1.Borrow(cratio_allocs)

	var citem_width_allocs *cgoAllocMap
	ref3c76e5b1.item_width, citem_width_allocs = (C.float)(x.ItemWidth), cgoAllocsUnknown
	allocs3c76e5b1.Borrow(citem_width_allocs)

	var citem_height_allocs *cgoAllocMap
	ref3c76e5b1.item_height, citem_height_allocs = (C.float)(x.ItemHeight), cgoAllocsUnknown
	allocs3c76e5b1.Borrow(citem_height_allocs)

	var citem_offset_allocs *cgoAllocMap
	ref3c76e5b1.item_offset, citem_offset_allocs = (C.float)(x.ItemOffset), cgoAllocsUnknown
	allocs3c76e5b1.Borrow(citem_offset_allocs)

	var cfilled_allocs *cgoAllocMap
	ref3c76e5b1.filled, cfilled_allocs = (C.float)(x.Filled), cgoAllocsUnknown
	allocs3c76e5b1.Borrow(cfilled_allocs)

	var citem_allocs *cgoAllocMap
	ref3c76e5b1.item, citem_allocs = x.Item.PassValue()
	allocs3c76e5b1.Borrow(citem_allocs)

	var ctree_depth_allocs *cgoAllocMap
	ref3c76e5b1.tree_depth, ctree_depth_allocs = (C.int)(x.TreeDepth), cgoAllocsUnknown
	allocs3c76e5b1.Borrow(ctree_depth_allocs)

	x.ref3c76e5b1 = ref3c76e5b1
	x.allocs3c76e5b1 = allocs3c76e5b1
	return ref3c76e5b1, allocs3c76e5b1

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RowLayout) PassValue() (C.struct_nk_row_layout, *cgoAllocMap) {
	if x.ref3c76e5b1 != nil {
		return *x.ref3c76e5b1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RowLayout) Deref() {
	if x.ref3c76e5b1 == nil {
		return
	}
	x.Type = (int32)(x.ref3c76e5b1._type)
	x.Index = (int32)(x.ref3c76e5b1.index)
	x.Height = (float32)(x.ref3c76e5b1.height)
	x.Columns = (int32)(x.ref3c76e5b1.columns)
	hxff2234b := (*sliceHeader)(unsafe.Pointer(&x.Ratio))
	hxff2234b.Data = uintptr(unsafe.Pointer(x.ref3c76e5b1.ratio))
	hxff2234b.Cap = 0x7fffffff
	// hxff2234b.Len = ?

	x.ItemWidth = (float32)(x.ref3c76e5b1.item_width)
	x.ItemHeight = (float32)(x.ref3c76e5b1.item_height)
	x.ItemOffset = (float32)(x.ref3c76e5b1.item_offset)
	x.Filled = (float32)(x.ref3c76e5b1.filled)
	x.Item = *NewRectRef(unsafe.Pointer(&x.ref3c76e5b1.item))
	x.TreeDepth = (int32)(x.ref3c76e5b1.tree_depth)
}

// allocStructNkMemoryMemory allocates memory for type C.struct_nk_memory in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkMemoryMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkMemoryValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkMemoryValue = unsafe.Sizeof([1]C.struct_nk_memory{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Memory) Ref() *C.struct_nk_memory {
	if x == nil {
		return nil
	}
	return x.reff3973d44
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Memory) Free() {
	if x != nil && x.allocsf3973d44 != nil {
		x.allocsf3973d44.(*cgoAllocMap).Free()
		x.reff3973d44 = nil
	}
}

// NewMemoryRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMemoryRef(ref unsafe.Pointer) *Memory {
	if ref == nil {
		return nil
	}
	obj := new(Memory)
	obj.reff3973d44 = (*C.struct_nk_memory)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Memory) PassRef() (*C.struct_nk_memory, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff3973d44 != nil {
		return x.reff3973d44, nil
	}
	memf3973d44 := allocStructNkMemoryMemory(1)
	reff3973d44 := (*C.struct_nk_memory)(memf3973d44)
	allocsf3973d44 := new(cgoAllocMap)
	var cptr_allocs *cgoAllocMap
	reff3973d44.ptr, cptr_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.Ptr)), cgoAllocsUnknown
	allocsf3973d44.Borrow(cptr_allocs)

	var csize_allocs *cgoAllocMap
	reff3973d44.size, csize_allocs = (C.nk_size)(x.Size), cgoAllocsUnknown
	allocsf3973d44.Borrow(csize_allocs)

	x.reff3973d44 = reff3973d44
	x.allocsf3973d44 = allocsf3973d44
	return reff3973d44, allocsf3973d44

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Memory) PassValue() (C.struct_nk_memory, *cgoAllocMap) {
	if x.reff3973d44 != nil {
		return *x.reff3973d44, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Memory) Deref() {
	if x.reff3973d44 == nil {
		return
	}
	x.Ptr = (unsafe.Pointer)(unsafe.Pointer(x.reff3973d44.ptr))
	x.Size = (Size)(x.reff3973d44.size)
}

// allocStructNkStyleWindowMemory allocates memory for type C.struct_nk_style_window in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkStyleWindowMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkStyleWindowValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkStyleWindowValue = unsafe.Sizeof([1]C.struct_nk_style_window{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *StyleWindow) Ref() *C.struct_nk_style_window {
	if x == nil {
		return nil
	}
	return x.ref9603d52e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *StyleWindow) Free() {
	if x != nil && x.allocs9603d52e != nil {
		x.allocs9603d52e.(*cgoAllocMap).Free()
		x.ref9603d52e = nil
	}
}

// NewStyleWindowRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewStyleWindowRef(ref unsafe.Pointer) *StyleWindow {
	if ref == nil {
		return nil
	}
	obj := new(StyleWindow)
	obj.ref9603d52e = (*C.struct_nk_style_window)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *StyleWindow) PassRef() (*C.struct_nk_style_window, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9603d52e != nil {
		return x.ref9603d52e, nil
	}
	mem9603d52e := allocStructNkStyleWindowMemory(1)
	ref9603d52e := (*C.struct_nk_style_window)(mem9603d52e)
	allocs9603d52e := new(cgoAllocMap)
	var cheader_allocs *cgoAllocMap
	ref9603d52e.header, cheader_allocs = x.Header.PassValue()
	allocs9603d52e.Borrow(cheader_allocs)

	var cfixed_background_allocs *cgoAllocMap
	ref9603d52e.fixed_background, cfixed_background_allocs = x.FixedBackground.PassValue()
	allocs9603d52e.Borrow(cfixed_background_allocs)

	var cbackground_allocs *cgoAllocMap
	ref9603d52e.background, cbackground_allocs = x.Background.PassValue()
	allocs9603d52e.Borrow(cbackground_allocs)

	var cborder_color_allocs *cgoAllocMap
	ref9603d52e.border_color, cborder_color_allocs = x.BorderColor.PassValue()
	allocs9603d52e.Borrow(cborder_color_allocs)

	var cpopup_border_color_allocs *cgoAllocMap
	ref9603d52e.popup_border_color, cpopup_border_color_allocs = x.PopupBorderColor.PassValue()
	allocs9603d52e.Borrow(cpopup_border_color_allocs)

	var ccombo_border_color_allocs *cgoAllocMap
	ref9603d52e.combo_border_color, ccombo_border_color_allocs = x.ComboBorderColor.PassValue()
	allocs9603d52e.Borrow(ccombo_border_color_allocs)

	var ccontextual_border_color_allocs *cgoAllocMap
	ref9603d52e.contextual_border_color, ccontextual_border_color_allocs = x.ContextualBorderColor.PassValue()
	allocs9603d52e.Borrow(ccontextual_border_color_allocs)

	var cmenu_border_color_allocs *cgoAllocMap
	ref9603d52e.menu_border_color, cmenu_border_color_allocs = x.MenuBorderColor.PassValue()
	allocs9603d52e.Borrow(cmenu_border_color_allocs)

	var cgroup_border_color_allocs *cgoAllocMap
	ref9603d52e.group_border_color, cgroup_border_color_allocs = x.GroupBorderColor.PassValue()
	allocs9603d52e.Borrow(cgroup_border_color_allocs)

	var ctooltip_border_color_allocs *cgoAllocMap
	ref9603d52e.tooltip_border_color, ctooltip_border_color_allocs = x.TooltipBorderColor.PassValue()
	allocs9603d52e.Borrow(ctooltip_border_color_allocs)

	var cscaler_allocs *cgoAllocMap
	ref9603d52e.scaler, cscaler_allocs = x.Scaler.PassValue()
	allocs9603d52e.Borrow(cscaler_allocs)

	var cborder_allocs *cgoAllocMap
	ref9603d52e.border, cborder_allocs = (C.float)(x.Border), cgoAllocsUnknown
	allocs9603d52e.Borrow(cborder_allocs)

	var ccombo_border_allocs *cgoAllocMap
	ref9603d52e.combo_border, ccombo_border_allocs = (C.float)(x.ComboBorder), cgoAllocsUnknown
	allocs9603d52e.Borrow(ccombo_border_allocs)

	var ccontextual_border_allocs *cgoAllocMap
	ref9603d52e.contextual_border, ccontextual_border_allocs = (C.float)(x.ContextualBorder), cgoAllocsUnknown
	allocs9603d52e.Borrow(ccontextual_border_allocs)

	var cmenu_border_allocs *cgoAllocMap
	ref9603d52e.menu_border, cmenu_border_allocs = (C.float)(x.MenuBorder), cgoAllocsUnknown
	allocs9603d52e.Borrow(cmenu_border_allocs)

	var cgroup_border_allocs *cgoAllocMap
	ref9603d52e.group_border, cgroup_border_allocs = (C.float)(x.GroupBorder), cgoAllocsUnknown
	allocs9603d52e.Borrow(cgroup_border_allocs)

	var ctooltip_border_allocs *cgoAllocMap
	ref9603d52e.tooltip_border, ctooltip_border_allocs = (C.float)(x.TooltipBorder), cgoAllocsUnknown
	allocs9603d52e.Borrow(ctooltip_border_allocs)

	var cpopup_border_allocs *cgoAllocMap
	ref9603d52e.popup_border, cpopup_border_allocs = (C.float)(x.PopupBorder), cgoAllocsUnknown
	allocs9603d52e.Borrow(cpopup_border_allocs)

	var crounding_allocs *cgoAllocMap
	ref9603d52e.rounding, crounding_allocs = (C.float)(x.Rounding), cgoAllocsUnknown
	allocs9603d52e.Borrow(crounding_allocs)

	var cspacing_allocs *cgoAllocMap
	ref9603d52e.spacing, cspacing_allocs = x.Spacing.PassValue()
	allocs9603d52e.Borrow(cspacing_allocs)

	var cscrollbar_size_allocs *cgoAllocMap
	ref9603d52e.scrollbar_size, cscrollbar_size_allocs = x.ScrollbarSize.PassValue()
	allocs9603d52e.Borrow(cscrollbar_size_allocs)

	var cmin_size_allocs *cgoAllocMap
	ref9603d52e.min_size, cmin_size_allocs = x.MinSize.PassValue()
	allocs9603d52e.Borrow(cmin_size_allocs)

	var cpadding_allocs *cgoAllocMap
	ref9603d52e.padding, cpadding_allocs = x.Padding.PassValue()
	allocs9603d52e.Borrow(cpadding_allocs)

	var cgroup_padding_allocs *cgoAllocMap
	ref9603d52e.group_padding, cgroup_padding_allocs = x.GroupPadding.PassValue()
	allocs9603d52e.Borrow(cgroup_padding_allocs)

	var cpopup_padding_allocs *cgoAllocMap
	ref9603d52e.popup_padding, cpopup_padding_allocs = x.PopupPadding.PassValue()
	allocs9603d52e.Borrow(cpopup_padding_allocs)

	var ccombo_padding_allocs *cgoAllocMap
	ref9603d52e.combo_padding, ccombo_padding_allocs = x.ComboPadding.PassValue()
	allocs9603d52e.Borrow(ccombo_padding_allocs)

	var ccontextual_padding_allocs *cgoAllocMap
	ref9603d52e.contextual_padding, ccontextual_padding_allocs = x.ContextualPadding.PassValue()
	allocs9603d52e.Borrow(ccontextual_padding_allocs)

	var cmenu_padding_allocs *cgoAllocMap
	ref9603d52e.menu_padding, cmenu_padding_allocs = x.MenuPadding.PassValue()
	allocs9603d52e.Borrow(cmenu_padding_allocs)

	var ctooltip_padding_allocs *cgoAllocMap
	ref9603d52e.tooltip_padding, ctooltip_padding_allocs = x.TooltipPadding.PassValue()
	allocs9603d52e.Borrow(ctooltip_padding_allocs)

	x.ref9603d52e = ref9603d52e
	x.allocs9603d52e = allocs9603d52e
	return ref9603d52e, allocs9603d52e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x StyleWindow) PassValue() (C.struct_nk_style_window, *cgoAllocMap) {
	if x.ref9603d52e != nil {
		return *x.ref9603d52e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *StyleWindow) Deref() {
	if x.ref9603d52e == nil {
		return
	}
	x.Header = *NewStyleWindowHeaderRef(unsafe.Pointer(&x.ref9603d52e.header))
	x.FixedBackground = *NewStyleItemRef(unsafe.Pointer(&x.ref9603d52e.fixed_background))
	x.Background = *NewColorRef(unsafe.Pointer(&x.ref9603d52e.background))
	x.BorderColor = *NewColorRef(unsafe.Pointer(&x.ref9603d52e.border_color))
	x.PopupBorderColor = *NewColorRef(unsafe.Pointer(&x.ref9603d52e.popup_border_color))
	x.ComboBorderColor = *NewColorRef(unsafe.Pointer(&x.ref9603d52e.combo_border_color))
	x.ContextualBorderColor = *NewColorRef(unsafe.Pointer(&x.ref9603d52e.contextual_border_color))
	x.MenuBorderColor = *NewColorRef(unsafe.Pointer(&x.ref9603d52e.menu_border_color))
	x.GroupBorderColor = *NewColorRef(unsafe.Pointer(&x.ref9603d52e.group_border_color))
	x.TooltipBorderColor = *NewColorRef(unsafe.Pointer(&x.ref9603d52e.tooltip_border_color))
	x.Scaler = *NewStyleItemRef(unsafe.Pointer(&x.ref9603d52e.scaler))
	x.Border = (float32)(x.ref9603d52e.border)
	x.ComboBorder = (float32)(x.ref9603d52e.combo_border)
	x.ContextualBorder = (float32)(x.ref9603d52e.contextual_border)
	x.MenuBorder = (float32)(x.ref9603d52e.menu_border)
	x.GroupBorder = (float32)(x.ref9603d52e.group_border)
	x.TooltipBorder = (float32)(x.ref9603d52e.tooltip_border)
	x.PopupBorder = (float32)(x.ref9603d52e.popup_border)
	x.Rounding = (float32)(x.ref9603d52e.rounding)
	x.Spacing = *NewVec2Ref(unsafe.Pointer(&x.ref9603d52e.spacing))
	x.ScrollbarSize = *NewVec2Ref(unsafe.Pointer(&x.ref9603d52e.scrollbar_size))
	x.MinSize = *NewVec2Ref(unsafe.Pointer(&x.ref9603d52e.min_size))
	x.Padding = *NewVec2Ref(unsafe.Pointer(&x.ref9603d52e.padding))
	x.GroupPadding = *NewVec2Ref(unsafe.Pointer(&x.ref9603d52e.group_padding))
	x.PopupPadding = *NewVec2Ref(unsafe.Pointer(&x.ref9603d52e.popup_padding))
	x.ComboPadding = *NewVec2Ref(unsafe.Pointer(&x.ref9603d52e.combo_padding))
	x.ContextualPadding = *NewVec2Ref(unsafe.Pointer(&x.ref9603d52e.contextual_padding))
	x.MenuPadding = *NewVec2Ref(unsafe.Pointer(&x.ref9603d52e.menu_padding))
	x.TooltipPadding = *NewVec2Ref(unsafe.Pointer(&x.ref9603d52e.tooltip_padding))
}

// allocStructNkCommandCircleFilledMemory allocates memory for type C.struct_nk_command_circle_filled in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkCommandCircleFilledMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkCommandCircleFilledValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkCommandCircleFilledValue = unsafe.Sizeof([1]C.struct_nk_command_circle_filled{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CommandCircleFilled) Ref() *C.struct_nk_command_circle_filled {
	if x == nil {
		return nil
	}
	return x.reff3c944cd
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CommandCircleFilled) Free() {
	if x != nil && x.allocsf3c944cd != nil {
		x.allocsf3c944cd.(*cgoAllocMap).Free()
		x.reff3c944cd = nil
	}
}

// NewCommandCircleFilledRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCommandCircleFilledRef(ref unsafe.Pointer) *CommandCircleFilled {
	if ref == nil {
		return nil
	}
	obj := new(CommandCircleFilled)
	obj.reff3c944cd = (*C.struct_nk_command_circle_filled)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CommandCircleFilled) PassRef() (*C.struct_nk_command_circle_filled, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff3c944cd != nil {
		return x.reff3c944cd, nil
	}
	memf3c944cd := allocStructNkCommandCircleFilledMemory(1)
	reff3c944cd := (*C.struct_nk_command_circle_filled)(memf3c944cd)
	allocsf3c944cd := new(cgoAllocMap)
	var cheader_allocs *cgoAllocMap
	reff3c944cd.header, cheader_allocs = x.Header.PassValue()
	allocsf3c944cd.Borrow(cheader_allocs)

	var cx_allocs *cgoAllocMap
	reff3c944cd.x, cx_allocs = (C.short)(x.X), cgoAllocsUnknown
	allocsf3c944cd.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	reff3c944cd.y, cy_allocs = (C.short)(x.Y), cgoAllocsUnknown
	allocsf3c944cd.Borrow(cy_allocs)

	var cw_allocs *cgoAllocMap
	reff3c944cd.w, cw_allocs = (C.ushort)(x.W), cgoAllocsUnknown
	allocsf3c944cd.Borrow(cw_allocs)

	var ch_allocs *cgoAllocMap
	reff3c944cd.h, ch_allocs = (C.ushort)(x.H), cgoAllocsUnknown
	allocsf3c944cd.Borrow(ch_allocs)

	var ccolor_allocs *cgoAllocMap
	reff3c944cd.color, ccolor_allocs = x.Color.PassValue()
	allocsf3c944cd.Borrow(ccolor_allocs)

	x.reff3c944cd = reff3c944cd
	x.allocsf3c944cd = allocsf3c944cd
	return reff3c944cd, allocsf3c944cd

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CommandCircleFilled) PassValue() (C.struct_nk_command_circle_filled, *cgoAllocMap) {
	if x.reff3c944cd != nil {
		return *x.reff3c944cd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CommandCircleFilled) Deref() {
	if x.reff3c944cd == nil {
		return
	}
	x.Header = *NewCommandRef(unsafe.Pointer(&x.reff3c944cd.header))
	x.X = (int16)(x.reff3c944cd.x)
	x.Y = (int16)(x.reff3c944cd.y)
	x.W = (uint16)(x.reff3c944cd.w)
	x.H = (uint16)(x.reff3c944cd.h)
	x.Color = *NewColorRef(unsafe.Pointer(&x.reff3c944cd.color))
}

// allocStructNkInputMemory allocates memory for type C.struct_nk_input in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkInputMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkInputValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkInputValue = unsafe.Sizeof([1]C.struct_nk_input{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Input) Ref() *C.struct_nk_input {
	if x == nil {
		return nil
	}
	return x.ref4e173241
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Input) Free() {
	if x != nil && x.allocs4e173241 != nil {
		x.allocs4e173241.(*cgoAllocMap).Free()
		x.ref4e173241 = nil
	}
}

// NewInputRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewInputRef(ref unsafe.Pointer) *Input {
	if ref == nil {
		return nil
	}
	obj := new(Input)
	obj.ref4e173241 = (*C.struct_nk_input)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Input) PassRef() (*C.struct_nk_input, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4e173241 != nil {
		return x.ref4e173241, nil
	}
	mem4e173241 := allocStructNkInputMemory(1)
	ref4e173241 := (*C.struct_nk_input)(mem4e173241)
	allocs4e173241 := new(cgoAllocMap)
	var ckeyboard_allocs *cgoAllocMap
	ref4e173241.keyboard, ckeyboard_allocs = x.Keyboard.PassValue()
	allocs4e173241.Borrow(ckeyboard_allocs)

	var cmouse_allocs *cgoAllocMap
	ref4e173241.mouse, cmouse_allocs = x.Mouse.PassValue()
	allocs4e173241.Borrow(cmouse_allocs)

	x.ref4e173241 = ref4e173241
	x.allocs4e173241 = allocs4e173241
	return ref4e173241, allocs4e173241

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Input) PassValue() (C.struct_nk_input, *cgoAllocMap) {
	if x.ref4e173241 != nil {
		return *x.ref4e173241, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Input) Deref() {
	if x.ref4e173241 == nil {
		return
	}
	x.Keyboard = *NewKeyboardRef(unsafe.Pointer(&x.ref4e173241.keyboard))
	x.Mouse = *NewMouseRef(unsafe.Pointer(&x.ref4e173241.mouse))
}

// allocStructNkCommandPolygonMemory allocates memory for type C.struct_nk_command_polygon in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkCommandPolygonMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkCommandPolygonValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkCommandPolygonValue = unsafe.Sizeof([1]C.struct_nk_command_polygon{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CommandPolygon) Ref() *C.struct_nk_command_polygon {
	if x == nil {
		return nil
	}
	return x.ref348e8888
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CommandPolygon) Free() {
	if x != nil && x.allocs348e8888 != nil {
		x.allocs348e8888.(*cgoAllocMap).Free()
		x.ref348e8888 = nil
	}
}

// NewCommandPolygonRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCommandPolygonRef(ref unsafe.Pointer) *CommandPolygon {
	if ref == nil {
		return nil
	}
	obj := new(CommandPolygon)
	obj.ref348e8888 = (*C.struct_nk_command_polygon)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CommandPolygon) PassRef() (*C.struct_nk_command_polygon, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref348e8888 != nil {
		return x.ref348e8888, nil
	}
	mem348e8888 := allocStructNkCommandPolygonMemory(1)
	ref348e8888 := (*C.struct_nk_command_polygon)(mem348e8888)
	allocs348e8888 := new(cgoAllocMap)
	var cheader_allocs *cgoAllocMap
	ref348e8888.header, cheader_allocs = x.Header.PassValue()
	allocs348e8888.Borrow(cheader_allocs)

	var ccolor_allocs *cgoAllocMap
	ref348e8888.color, ccolor_allocs = x.Color.PassValue()
	allocs348e8888.Borrow(ccolor_allocs)

	var cline_thickness_allocs *cgoAllocMap
	ref348e8888.line_thickness, cline_thickness_allocs = (C.ushort)(x.LineThickness), cgoAllocsUnknown
	allocs348e8888.Borrow(cline_thickness_allocs)

	var cpoint_count_allocs *cgoAllocMap
	ref348e8888.point_count, cpoint_count_allocs = (C.ushort)(x.PointCount), cgoAllocsUnknown
	allocs348e8888.Borrow(cpoint_count_allocs)

	var cpoints_allocs *cgoAllocMap
	ref348e8888.points, cpoints_allocs = unpackA1Vec2i(x.Points)
	allocs348e8888.Borrow(cpoints_allocs)

	x.ref348e8888 = ref348e8888
	x.allocs348e8888 = allocs348e8888
	return ref348e8888, allocs348e8888

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CommandPolygon) PassValue() (C.struct_nk_command_polygon, *cgoAllocMap) {
	if x.ref348e8888 != nil {
		return *x.ref348e8888, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CommandPolygon) Deref() {
	if x.ref348e8888 == nil {
		return
	}
	x.Header = *NewCommandRef(unsafe.Pointer(&x.ref348e8888.header))
	x.Color = *NewColorRef(unsafe.Pointer(&x.ref348e8888.color))
	x.LineThickness = (uint16)(x.ref348e8888.line_thickness)
	x.PointCount = (uint16)(x.ref348e8888.point_count)
	packA1Vec2i(&x.Points, (*[1]C.struct_nk_vec2i)(unsafe.Pointer(&x.ref348e8888.points)))
}

// Ref returns a reference to C object as it is.
func (x *Allocator) Ref() *C.struct_nk_allocator {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_allocator)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Allocator) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewAllocatorRef converts the C object reference into a raw struct reference without wrapping.
func NewAllocatorRef(ref *C.struct_nk_allocator) *Allocator {
	return (*Allocator)(unsafe.Pointer(ref))
}

// NewAllocator allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewAllocator() *Allocator {
	return (*Allocator)(allocStructNkAllocatorMemory(1))
}

// allocStructNkAllocatorMemory allocates memory for type C.struct_nk_allocator in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkAllocatorMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkAllocatorValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkAllocatorValue = unsafe.Sizeof([1]C.struct_nk_allocator{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Allocator) PassRef() *C.struct_nk_allocator {
	if x == nil {
		x = (*Allocator)(allocStructNkAllocatorMemory(1))
	}
	return (*C.struct_nk_allocator)(unsafe.Pointer(x))
}

// allocStructNkStyleProgressMemory allocates memory for type C.struct_nk_style_progress in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkStyleProgressMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkStyleProgressValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkStyleProgressValue = unsafe.Sizeof([1]C.struct_nk_style_progress{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *StyleProgress) Ref() *C.struct_nk_style_progress {
	if x == nil {
		return nil
	}
	return x.ref2f48313c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *StyleProgress) Free() {
	if x != nil && x.allocs2f48313c != nil {
		x.allocs2f48313c.(*cgoAllocMap).Free()
		x.ref2f48313c = nil
	}
}

// NewStyleProgressRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewStyleProgressRef(ref unsafe.Pointer) *StyleProgress {
	if ref == nil {
		return nil
	}
	obj := new(StyleProgress)
	obj.ref2f48313c = (*C.struct_nk_style_progress)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *StyleProgress) PassRef() (*C.struct_nk_style_progress, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2f48313c != nil {
		return x.ref2f48313c, nil
	}
	mem2f48313c := allocStructNkStyleProgressMemory(1)
	ref2f48313c := (*C.struct_nk_style_progress)(mem2f48313c)
	allocs2f48313c := new(cgoAllocMap)
	var cnormal_allocs *cgoAllocMap
	ref2f48313c.normal, cnormal_allocs = x.Normal.PassValue()
	allocs2f48313c.Borrow(cnormal_allocs)

	var chover_allocs *cgoAllocMap
	ref2f48313c.hover, chover_allocs = x.Hover.PassValue()
	allocs2f48313c.Borrow(chover_allocs)

	var cactive_allocs *cgoAllocMap
	ref2f48313c.active, cactive_allocs = x.Active.PassValue()
	allocs2f48313c.Borrow(cactive_allocs)

	var cborder_color_allocs *cgoAllocMap
	ref2f48313c.border_color, cborder_color_allocs = x.BorderColor.PassValue()
	allocs2f48313c.Borrow(cborder_color_allocs)

	var ccursor_normal_allocs *cgoAllocMap
	ref2f48313c.cursor_normal, ccursor_normal_allocs = x.CursorNormal.PassValue()
	allocs2f48313c.Borrow(ccursor_normal_allocs)

	var ccursor_hover_allocs *cgoAllocMap
	ref2f48313c.cursor_hover, ccursor_hover_allocs = x.CursorHover.PassValue()
	allocs2f48313c.Borrow(ccursor_hover_allocs)

	var ccursor_active_allocs *cgoAllocMap
	ref2f48313c.cursor_active, ccursor_active_allocs = x.CursorActive.PassValue()
	allocs2f48313c.Borrow(ccursor_active_allocs)

	var ccursor_border_color_allocs *cgoAllocMap
	ref2f48313c.cursor_border_color, ccursor_border_color_allocs = x.CursorBorderColor.PassValue()
	allocs2f48313c.Borrow(ccursor_border_color_allocs)

	var crounding_allocs *cgoAllocMap
	ref2f48313c.rounding, crounding_allocs = (C.float)(x.Rounding), cgoAllocsUnknown
	allocs2f48313c.Borrow(crounding_allocs)

	var cborder_allocs *cgoAllocMap
	ref2f48313c.border, cborder_allocs = (C.float)(x.Border), cgoAllocsUnknown
	allocs2f48313c.Borrow(cborder_allocs)

	var ccursor_border_allocs *cgoAllocMap
	ref2f48313c.cursor_border, ccursor_border_allocs = (C.float)(x.CursorBorder), cgoAllocsUnknown
	allocs2f48313c.Borrow(ccursor_border_allocs)

	var ccursor_rounding_allocs *cgoAllocMap
	ref2f48313c.cursor_rounding, ccursor_rounding_allocs = (C.float)(x.CursorRounding), cgoAllocsUnknown
	allocs2f48313c.Borrow(ccursor_rounding_allocs)

	var cpadding_allocs *cgoAllocMap
	ref2f48313c.padding, cpadding_allocs = x.Padding.PassValue()
	allocs2f48313c.Borrow(cpadding_allocs)

	var cuserdata_allocs *cgoAllocMap
	ref2f48313c.userdata, cuserdata_allocs = *(*C.nk_handle)(unsafe.Pointer(&x.Userdata)), cgoAllocsUnknown
	allocs2f48313c.Borrow(cuserdata_allocs)

	var cdraw_begin_allocs *cgoAllocMap
	ref2f48313c.draw_begin, cdraw_begin_allocs = (*[0]byte)(unsafe.Pointer(x.DrawBegin)), cgoAllocsUnknown
	allocs2f48313c.Borrow(cdraw_begin_allocs)

	var cdraw_end_allocs *cgoAllocMap
	ref2f48313c.draw_end, cdraw_end_allocs = (*[0]byte)(unsafe.Pointer(x.DrawEnd)), cgoAllocsUnknown
	allocs2f48313c.Borrow(cdraw_end_allocs)

	x.ref2f48313c = ref2f48313c
	x.allocs2f48313c = allocs2f48313c
	return ref2f48313c, allocs2f48313c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x StyleProgress) PassValue() (C.struct_nk_style_progress, *cgoAllocMap) {
	if x.ref2f48313c != nil {
		return *x.ref2f48313c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *StyleProgress) Deref() {
	if x.ref2f48313c == nil {
		return
	}
	x.Normal = *NewStyleItemRef(unsafe.Pointer(&x.ref2f48313c.normal))
	x.Hover = *NewStyleItemRef(unsafe.Pointer(&x.ref2f48313c.hover))
	x.Active = *NewStyleItemRef(unsafe.Pointer(&x.ref2f48313c.active))
	x.BorderColor = *NewColorRef(unsafe.Pointer(&x.ref2f48313c.border_color))
	x.CursorNormal = *NewStyleItemRef(unsafe.Pointer(&x.ref2f48313c.cursor_normal))
	x.CursorHover = *NewStyleItemRef(unsafe.Pointer(&x.ref2f48313c.cursor_hover))
	x.CursorActive = *NewStyleItemRef(unsafe.Pointer(&x.ref2f48313c.cursor_active))
	x.CursorBorderColor = *NewColorRef(unsafe.Pointer(&x.ref2f48313c.cursor_border_color))
	x.Rounding = (float32)(x.ref2f48313c.rounding)
	x.Border = (float32)(x.ref2f48313c.border)
	x.CursorBorder = (float32)(x.ref2f48313c.cursor_border)
	x.CursorRounding = (float32)(x.ref2f48313c.cursor_rounding)
	x.Padding = *NewVec2Ref(unsafe.Pointer(&x.ref2f48313c.padding))
	x.Userdata = *(*Handle)(unsafe.Pointer(&x.ref2f48313c.userdata))
	// x.DrawBegin is a callback func
	// x.DrawEnd is a callback func
}

// allocStructNkRectMemory allocates memory for type C.struct_nk_rect in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkRectMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkRectValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkRectValue = unsafe.Sizeof([1]C.struct_nk_rect{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Rect) Ref() *C.struct_nk_rect {
	if x == nil {
		return nil
	}
	return x.ref817e2bcb
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Rect) Free() {
	if x != nil && x.allocs817e2bcb != nil {
		x.allocs817e2bcb.(*cgoAllocMap).Free()
		x.ref817e2bcb = nil
	}
}

// NewRectRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRectRef(ref unsafe.Pointer) *Rect {
	if ref == nil {
		return nil
	}
	obj := new(Rect)
	obj.ref817e2bcb = (*C.struct_nk_rect)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Rect) PassRef() (*C.struct_nk_rect, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref817e2bcb != nil {
		return x.ref817e2bcb, nil
	}
	mem817e2bcb := allocStructNkRectMemory(1)
	ref817e2bcb := (*C.struct_nk_rect)(mem817e2bcb)
	allocs817e2bcb := new(cgoAllocMap)
	var cx_allocs *cgoAllocMap
	ref817e2bcb.x, cx_allocs = (C.float)(x.X), cgoAllocsUnknown
	allocs817e2bcb.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	ref817e2bcb.y, cy_allocs = (C.float)(x.Y), cgoAllocsUnknown
	allocs817e2bcb.Borrow(cy_allocs)

	var cw_allocs *cgoAllocMap
	ref817e2bcb.w, cw_allocs = (C.float)(x.W), cgoAllocsUnknown
	allocs817e2bcb.Borrow(cw_allocs)

	var ch_allocs *cgoAllocMap
	ref817e2bcb.h, ch_allocs = (C.float)(x.H), cgoAllocsUnknown
	allocs817e2bcb.Borrow(ch_allocs)

	x.ref817e2bcb = ref817e2bcb
	x.allocs817e2bcb = allocs817e2bcb
	return ref817e2bcb, allocs817e2bcb

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Rect) PassValue() (C.struct_nk_rect, *cgoAllocMap) {
	if x.ref817e2bcb != nil {
		return *x.ref817e2bcb, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Rect) Deref() {
	if x.ref817e2bcb == nil {
		return
	}
	x.X = (float32)(x.ref817e2bcb.x)
	x.Y = (float32)(x.ref817e2bcb.y)
	x.W = (float32)(x.ref817e2bcb.w)
	x.H = (float32)(x.ref817e2bcb.h)
}

// allocStructNkCommandArcMemory allocates memory for type C.struct_nk_command_arc in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkCommandArcMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkCommandArcValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkCommandArcValue = unsafe.Sizeof([1]C.struct_nk_command_arc{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CommandArc) Ref() *C.struct_nk_command_arc {
	if x == nil {
		return nil
	}
	return x.ref9e3279d9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CommandArc) Free() {
	if x != nil && x.allocs9e3279d9 != nil {
		x.allocs9e3279d9.(*cgoAllocMap).Free()
		x.ref9e3279d9 = nil
	}
}

// NewCommandArcRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCommandArcRef(ref unsafe.Pointer) *CommandArc {
	if ref == nil {
		return nil
	}
	obj := new(CommandArc)
	obj.ref9e3279d9 = (*C.struct_nk_command_arc)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CommandArc) PassRef() (*C.struct_nk_command_arc, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9e3279d9 != nil {
		return x.ref9e3279d9, nil
	}
	mem9e3279d9 := allocStructNkCommandArcMemory(1)
	ref9e3279d9 := (*C.struct_nk_command_arc)(mem9e3279d9)
	allocs9e3279d9 := new(cgoAllocMap)
	var cheader_allocs *cgoAllocMap
	ref9e3279d9.header, cheader_allocs = x.Header.PassValue()
	allocs9e3279d9.Borrow(cheader_allocs)

	var ccx_allocs *cgoAllocMap
	ref9e3279d9.cx, ccx_allocs = (C.short)(x.Cx), cgoAllocsUnknown
	allocs9e3279d9.Borrow(ccx_allocs)

	var ccy_allocs *cgoAllocMap
	ref9e3279d9.cy, ccy_allocs = (C.short)(x.Cy), cgoAllocsUnknown
	allocs9e3279d9.Borrow(ccy_allocs)

	var cr_allocs *cgoAllocMap
	ref9e3279d9.r, cr_allocs = (C.ushort)(x.R), cgoAllocsUnknown
	allocs9e3279d9.Borrow(cr_allocs)

	var cline_thickness_allocs *cgoAllocMap
	ref9e3279d9.line_thickness, cline_thickness_allocs = (C.ushort)(x.LineThickness), cgoAllocsUnknown
	allocs9e3279d9.Borrow(cline_thickness_allocs)

	var ca_allocs *cgoAllocMap
	ref9e3279d9.a, ca_allocs = *(*[2]C.float)(unsafe.Pointer(&x.A)), cgoAllocsUnknown
	allocs9e3279d9.Borrow(ca_allocs)

	var ccolor_allocs *cgoAllocMap
	ref9e3279d9.color, ccolor_allocs = x.Color.PassValue()
	allocs9e3279d9.Borrow(ccolor_allocs)

	x.ref9e3279d9 = ref9e3279d9
	x.allocs9e3279d9 = allocs9e3279d9
	return ref9e3279d9, allocs9e3279d9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CommandArc) PassValue() (C.struct_nk_command_arc, *cgoAllocMap) {
	if x.ref9e3279d9 != nil {
		return *x.ref9e3279d9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CommandArc) Deref() {
	if x.ref9e3279d9 == nil {
		return
	}
	x.Header = *NewCommandRef(unsafe.Pointer(&x.ref9e3279d9.header))
	x.Cx = (int16)(x.ref9e3279d9.cx)
	x.Cy = (int16)(x.ref9e3279d9.cy)
	x.R = (uint16)(x.ref9e3279d9.r)
	x.LineThickness = (uint16)(x.ref9e3279d9.line_thickness)
	x.A = *(*[2]float32)(unsafe.Pointer(&x.ref9e3279d9.a))
	x.Color = *NewColorRef(unsafe.Pointer(&x.ref9e3279d9.color))
}

// allocStructNkVec2Memory allocates memory for type C.struct_nk_vec2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkVec2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkVec2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkVec2Value = unsafe.Sizeof([1]C.struct_nk_vec2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Vec2) Ref() *C.struct_nk_vec2 {
	if x == nil {
		return nil
	}
	return x.ref91a35839
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Vec2) Free() {
	if x != nil && x.allocs91a35839 != nil {
		x.allocs91a35839.(*cgoAllocMap).Free()
		x.ref91a35839 = nil
	}
}

// NewVec2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewVec2Ref(ref unsafe.Pointer) *Vec2 {
	if ref == nil {
		return nil
	}
	obj := new(Vec2)
	obj.ref91a35839 = (*C.struct_nk_vec2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Vec2) PassRef() (*C.struct_nk_vec2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref91a35839 != nil {
		return x.ref91a35839, nil
	}
	mem91a35839 := allocStructNkVec2Memory(1)
	ref91a35839 := (*C.struct_nk_vec2)(mem91a35839)
	allocs91a35839 := new(cgoAllocMap)
	var cx_allocs *cgoAllocMap
	ref91a35839.x, cx_allocs = (C.float)(x.X), cgoAllocsUnknown
	allocs91a35839.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	ref91a35839.y, cy_allocs = (C.float)(x.Y), cgoAllocsUnknown
	allocs91a35839.Borrow(cy_allocs)

	x.ref91a35839 = ref91a35839
	x.allocs91a35839 = allocs91a35839
	return ref91a35839, allocs91a35839

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Vec2) PassValue() (C.struct_nk_vec2, *cgoAllocMap) {
	if x.ref91a35839 != nil {
		return *x.ref91a35839, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Vec2) Deref() {
	if x.ref91a35839 == nil {
		return
	}
	x.X = (float32)(x.ref91a35839.x)
	x.Y = (float32)(x.ref91a35839.y)
}

// allocStructNkConfigStackFlagsElementMemory allocates memory for type C.struct_nk_config_stack_flags_element in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkConfigStackFlagsElementMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkConfigStackFlagsElementValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkConfigStackFlagsElementValue = unsafe.Sizeof([1]C.struct_nk_config_stack_flags_element{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ConfigStackFlagsElement) Ref() *C.struct_nk_config_stack_flags_element {
	if x == nil {
		return nil
	}
	return x.ref3f8db22a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ConfigStackFlagsElement) Free() {
	if x != nil && x.allocs3f8db22a != nil {
		x.allocs3f8db22a.(*cgoAllocMap).Free()
		x.ref3f8db22a = nil
	}
}

// NewConfigStackFlagsElementRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewConfigStackFlagsElementRef(ref unsafe.Pointer) *ConfigStackFlagsElement {
	if ref == nil {
		return nil
	}
	obj := new(ConfigStackFlagsElement)
	obj.ref3f8db22a = (*C.struct_nk_config_stack_flags_element)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ConfigStackFlagsElement) PassRef() (*C.struct_nk_config_stack_flags_element, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3f8db22a != nil {
		return x.ref3f8db22a, nil
	}
	mem3f8db22a := allocStructNkConfigStackFlagsElementMemory(1)
	ref3f8db22a := (*C.struct_nk_config_stack_flags_element)(mem3f8db22a)
	allocs3f8db22a := new(cgoAllocMap)
	var caddress_allocs *cgoAllocMap
	ref3f8db22a.address, caddress_allocs = (*C.nk_flags)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Address)).Data)), cgoAllocsUnknown
	allocs3f8db22a.Borrow(caddress_allocs)

	var cold_value_allocs *cgoAllocMap
	ref3f8db22a.old_value, cold_value_allocs = (C.nk_flags)(x.OldValue), cgoAllocsUnknown
	allocs3f8db22a.Borrow(cold_value_allocs)

	x.ref3f8db22a = ref3f8db22a
	x.allocs3f8db22a = allocs3f8db22a
	return ref3f8db22a, allocs3f8db22a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ConfigStackFlagsElement) PassValue() (C.struct_nk_config_stack_flags_element, *cgoAllocMap) {
	if x.ref3f8db22a != nil {
		return *x.ref3f8db22a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ConfigStackFlagsElement) Deref() {
	if x.ref3f8db22a == nil {
		return
	}
	hxff73280 := (*sliceHeader)(unsafe.Pointer(&x.Address))
	hxff73280.Data = uintptr(unsafe.Pointer(x.ref3f8db22a.address))
	hxff73280.Cap = 0x7fffffff
	// hxff73280.Len = ?

	x.OldValue = (Flags)(x.ref3f8db22a.old_value)
}

// allocStructNkCommandRectMemory allocates memory for type C.struct_nk_command_rect in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkCommandRectMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkCommandRectValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkCommandRectValue = unsafe.Sizeof([1]C.struct_nk_command_rect{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CommandRect) Ref() *C.struct_nk_command_rect {
	if x == nil {
		return nil
	}
	return x.ref213e4f25
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CommandRect) Free() {
	if x != nil && x.allocs213e4f25 != nil {
		x.allocs213e4f25.(*cgoAllocMap).Free()
		x.ref213e4f25 = nil
	}
}

// NewCommandRectRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCommandRectRef(ref unsafe.Pointer) *CommandRect {
	if ref == nil {
		return nil
	}
	obj := new(CommandRect)
	obj.ref213e4f25 = (*C.struct_nk_command_rect)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CommandRect) PassRef() (*C.struct_nk_command_rect, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref213e4f25 != nil {
		return x.ref213e4f25, nil
	}
	mem213e4f25 := allocStructNkCommandRectMemory(1)
	ref213e4f25 := (*C.struct_nk_command_rect)(mem213e4f25)
	allocs213e4f25 := new(cgoAllocMap)
	var cheader_allocs *cgoAllocMap
	ref213e4f25.header, cheader_allocs = x.Header.PassValue()
	allocs213e4f25.Borrow(cheader_allocs)

	var crounding_allocs *cgoAllocMap
	ref213e4f25.rounding, crounding_allocs = (C.ushort)(x.Rounding), cgoAllocsUnknown
	allocs213e4f25.Borrow(crounding_allocs)

	var cline_thickness_allocs *cgoAllocMap
	ref213e4f25.line_thickness, cline_thickness_allocs = (C.ushort)(x.LineThickness), cgoAllocsUnknown
	allocs213e4f25.Borrow(cline_thickness_allocs)

	var cx_allocs *cgoAllocMap
	ref213e4f25.x, cx_allocs = (C.short)(x.X), cgoAllocsUnknown
	allocs213e4f25.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	ref213e4f25.y, cy_allocs = (C.short)(x.Y), cgoAllocsUnknown
	allocs213e4f25.Borrow(cy_allocs)

	var cw_allocs *cgoAllocMap
	ref213e4f25.w, cw_allocs = (C.ushort)(x.W), cgoAllocsUnknown
	allocs213e4f25.Borrow(cw_allocs)

	var ch_allocs *cgoAllocMap
	ref213e4f25.h, ch_allocs = (C.ushort)(x.H), cgoAllocsUnknown
	allocs213e4f25.Borrow(ch_allocs)

	var ccolor_allocs *cgoAllocMap
	ref213e4f25.color, ccolor_allocs = x.Color.PassValue()
	allocs213e4f25.Borrow(ccolor_allocs)

	x.ref213e4f25 = ref213e4f25
	x.allocs213e4f25 = allocs213e4f25
	return ref213e4f25, allocs213e4f25

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CommandRect) PassValue() (C.struct_nk_command_rect, *cgoAllocMap) {
	if x.ref213e4f25 != nil {
		return *x.ref213e4f25, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CommandRect) Deref() {
	if x.ref213e4f25 == nil {
		return
	}
	x.Header = *NewCommandRef(unsafe.Pointer(&x.ref213e4f25.header))
	x.Rounding = (uint16)(x.ref213e4f25.rounding)
	x.LineThickness = (uint16)(x.ref213e4f25.line_thickness)
	x.X = (int16)(x.ref213e4f25.x)
	x.Y = (int16)(x.ref213e4f25.y)
	x.W = (uint16)(x.ref213e4f25.w)
	x.H = (uint16)(x.ref213e4f25.h)
	x.Color = *NewColorRef(unsafe.Pointer(&x.ref213e4f25.color))
}

// allocStructNkChartSlotMemory allocates memory for type C.struct_nk_chart_slot in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkChartSlotMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkChartSlotValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkChartSlotValue = unsafe.Sizeof([1]C.struct_nk_chart_slot{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ChartSlot) Ref() *C.struct_nk_chart_slot {
	if x == nil {
		return nil
	}
	return x.refa88720a9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ChartSlot) Free() {
	if x != nil && x.allocsa88720a9 != nil {
		x.allocsa88720a9.(*cgoAllocMap).Free()
		x.refa88720a9 = nil
	}
}

// NewChartSlotRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewChartSlotRef(ref unsafe.Pointer) *ChartSlot {
	if ref == nil {
		return nil
	}
	obj := new(ChartSlot)
	obj.refa88720a9 = (*C.struct_nk_chart_slot)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ChartSlot) PassRef() (*C.struct_nk_chart_slot, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa88720a9 != nil {
		return x.refa88720a9, nil
	}
	mema88720a9 := allocStructNkChartSlotMemory(1)
	refa88720a9 := (*C.struct_nk_chart_slot)(mema88720a9)
	allocsa88720a9 := new(cgoAllocMap)
	var c_type_allocs *cgoAllocMap
	refa88720a9._type, c_type_allocs = (C.enum_nk_chart_type)(x.Type), cgoAllocsUnknown
	allocsa88720a9.Borrow(c_type_allocs)

	var ccolor_allocs *cgoAllocMap
	refa88720a9.color, ccolor_allocs = x.Color.PassValue()
	allocsa88720a9.Borrow(ccolor_allocs)

	var chighlight_allocs *cgoAllocMap
	refa88720a9.highlight, chighlight_allocs = x.Highlight.PassValue()
	allocsa88720a9.Borrow(chighlight_allocs)

	var cmin_allocs *cgoAllocMap
	refa88720a9.min, cmin_allocs = (C.float)(x.Min), cgoAllocsUnknown
	allocsa88720a9.Borrow(cmin_allocs)

	var cmax_allocs *cgoAllocMap
	refa88720a9.max, cmax_allocs = (C.float)(x.Max), cgoAllocsUnknown
	allocsa88720a9.Borrow(cmax_allocs)

	var c_range_allocs *cgoAllocMap
	refa88720a9._range, c_range_allocs = (C.float)(x.Range), cgoAllocsUnknown
	allocsa88720a9.Borrow(c_range_allocs)

	var ccount_allocs *cgoAllocMap
	refa88720a9.count, ccount_allocs = (C.int)(x.Count), cgoAllocsUnknown
	allocsa88720a9.Borrow(ccount_allocs)

	var clast_allocs *cgoAllocMap
	refa88720a9.last, clast_allocs = x.Last.PassValue()
	allocsa88720a9.Borrow(clast_allocs)

	var cindex_allocs *cgoAllocMap
	refa88720a9.index, cindex_allocs = (C.int)(x.Index), cgoAllocsUnknown
	allocsa88720a9.Borrow(cindex_allocs)

	x.refa88720a9 = refa88720a9
	x.allocsa88720a9 = allocsa88720a9
	return refa88720a9, allocsa88720a9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ChartSlot) PassValue() (C.struct_nk_chart_slot, *cgoAllocMap) {
	if x.refa88720a9 != nil {
		return *x.refa88720a9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ChartSlot) Deref() {
	if x.refa88720a9 == nil {
		return
	}
	x.Type = (ChartType)(x.refa88720a9._type)
	x.Color = *NewColorRef(unsafe.Pointer(&x.refa88720a9.color))
	x.Highlight = *NewColorRef(unsafe.Pointer(&x.refa88720a9.highlight))
	x.Min = (float32)(x.refa88720a9.min)
	x.Max = (float32)(x.refa88720a9.max)
	x.Range = (float32)(x.refa88720a9._range)
	x.Count = (int32)(x.refa88720a9.count)
	x.Last = *NewVec2Ref(unsafe.Pointer(&x.refa88720a9.last))
	x.Index = (int32)(x.refa88720a9.index)
}

// allocStructNkMouseMemory allocates memory for type C.struct_nk_mouse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkMouseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkMouseValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkMouseValue = unsafe.Sizeof([1]C.struct_nk_mouse{})

// allocA3StructNkMouseButtonMemory allocates memory for type [3]C.struct_nk_mouse_button in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA3StructNkMouseButtonMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfA3StructNkMouseButtonValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfA3StructNkMouseButtonValue = unsafe.Sizeof([1][3]C.struct_nk_mouse_button{})

// unpackA3MouseButton transforms a sliced Go data structure into plain C format.
func unpackA3MouseButton(x [3]MouseButton) (unpacked [3]C.struct_nk_mouse_button, allocs *cgoAllocMap) {
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(*[3]C.struct_nk_mouse_button) {
		go allocs.Free()
	})

	mem0 := allocA3StructNkMouseButtonMemory(1)
	allocs.Add(mem0)
	v0 := (*[3]C.struct_nk_mouse_button)(mem0)
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	unpacked = *(*[3]C.struct_nk_mouse_button)(mem0)
	return
}

// packA3MouseButton reads sliced Go data structure out from plain C format.
func packA3MouseButton(v *[3]MouseButton, ptr0 *[3]C.struct_nk_mouse_button) {
	for i0 := range v {
		ptr1 := ptr0[i0]
		v[i0] = *NewMouseButtonRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Mouse) Ref() *C.struct_nk_mouse {
	if x == nil {
		return nil
	}
	return x.ref390ab67b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Mouse) Free() {
	if x != nil && x.allocs390ab67b != nil {
		x.allocs390ab67b.(*cgoAllocMap).Free()
		x.ref390ab67b = nil
	}
}

// NewMouseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMouseRef(ref unsafe.Pointer) *Mouse {
	if ref == nil {
		return nil
	}
	obj := new(Mouse)
	obj.ref390ab67b = (*C.struct_nk_mouse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Mouse) PassRef() (*C.struct_nk_mouse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref390ab67b != nil {
		return x.ref390ab67b, nil
	}
	mem390ab67b := allocStructNkMouseMemory(1)
	ref390ab67b := (*C.struct_nk_mouse)(mem390ab67b)
	allocs390ab67b := new(cgoAllocMap)
	var cbuttons_allocs *cgoAllocMap
	ref390ab67b.buttons, cbuttons_allocs = unpackA3MouseButton(x.Buttons)
	allocs390ab67b.Borrow(cbuttons_allocs)

	var cpos_allocs *cgoAllocMap
	ref390ab67b.pos, cpos_allocs = x.Pos.PassValue()
	allocs390ab67b.Borrow(cpos_allocs)

	var cprev_allocs *cgoAllocMap
	ref390ab67b.prev, cprev_allocs = x.Prev.PassValue()
	allocs390ab67b.Borrow(cprev_allocs)

	var cdelta_allocs *cgoAllocMap
	ref390ab67b.delta, cdelta_allocs = x.Delta.PassValue()
	allocs390ab67b.Borrow(cdelta_allocs)

	var cscroll_delta_allocs *cgoAllocMap
	ref390ab67b.scroll_delta, cscroll_delta_allocs = (C.float)(x.ScrollDelta), cgoAllocsUnknown
	allocs390ab67b.Borrow(cscroll_delta_allocs)

	var cgrab_allocs *cgoAllocMap
	ref390ab67b.grab, cgrab_allocs = (C.uchar)(x.Grab), cgoAllocsUnknown
	allocs390ab67b.Borrow(cgrab_allocs)

	var cgrabbed_allocs *cgoAllocMap
	ref390ab67b.grabbed, cgrabbed_allocs = (C.uchar)(x.Grabbed), cgoAllocsUnknown
	allocs390ab67b.Borrow(cgrabbed_allocs)

	var cungrab_allocs *cgoAllocMap
	ref390ab67b.ungrab, cungrab_allocs = (C.uchar)(x.Ungrab), cgoAllocsUnknown
	allocs390ab67b.Borrow(cungrab_allocs)

	x.ref390ab67b = ref390ab67b
	x.allocs390ab67b = allocs390ab67b
	return ref390ab67b, allocs390ab67b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Mouse) PassValue() (C.struct_nk_mouse, *cgoAllocMap) {
	if x.ref390ab67b != nil {
		return *x.ref390ab67b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Mouse) Deref() {
	if x.ref390ab67b == nil {
		return
	}
	packA3MouseButton(&x.Buttons, (*[3]C.struct_nk_mouse_button)(unsafe.Pointer(&x.ref390ab67b.buttons)))
	x.Pos = *NewVec2Ref(unsafe.Pointer(&x.ref390ab67b.pos))
	x.Prev = *NewVec2Ref(unsafe.Pointer(&x.ref390ab67b.prev))
	x.Delta = *NewVec2Ref(unsafe.Pointer(&x.ref390ab67b.delta))
	x.ScrollDelta = (float32)(x.ref390ab67b.scroll_delta)
	x.Grab = (byte)(x.ref390ab67b.grab)
	x.Grabbed = (byte)(x.ref390ab67b.grabbed)
	x.Ungrab = (byte)(x.ref390ab67b.ungrab)
}

// allocStructNkStylePropertyMemory allocates memory for type C.struct_nk_style_property in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkStylePropertyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkStylePropertyValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkStylePropertyValue = unsafe.Sizeof([1]C.struct_nk_style_property{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *StyleProperty) Ref() *C.struct_nk_style_property {
	if x == nil {
		return nil
	}
	return x.ref86bbdfa4
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *StyleProperty) Free() {
	if x != nil && x.allocs86bbdfa4 != nil {
		x.allocs86bbdfa4.(*cgoAllocMap).Free()
		x.ref86bbdfa4 = nil
	}
}

// NewStylePropertyRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewStylePropertyRef(ref unsafe.Pointer) *StyleProperty {
	if ref == nil {
		return nil
	}
	obj := new(StyleProperty)
	obj.ref86bbdfa4 = (*C.struct_nk_style_property)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *StyleProperty) PassRef() (*C.struct_nk_style_property, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref86bbdfa4 != nil {
		return x.ref86bbdfa4, nil
	}
	mem86bbdfa4 := allocStructNkStylePropertyMemory(1)
	ref86bbdfa4 := (*C.struct_nk_style_property)(mem86bbdfa4)
	allocs86bbdfa4 := new(cgoAllocMap)
	var cnormal_allocs *cgoAllocMap
	ref86bbdfa4.normal, cnormal_allocs = x.Normal.PassValue()
	allocs86bbdfa4.Borrow(cnormal_allocs)

	var chover_allocs *cgoAllocMap
	ref86bbdfa4.hover, chover_allocs = x.Hover.PassValue()
	allocs86bbdfa4.Borrow(chover_allocs)

	var cactive_allocs *cgoAllocMap
	ref86bbdfa4.active, cactive_allocs = x.Active.PassValue()
	allocs86bbdfa4.Borrow(cactive_allocs)

	var cborder_color_allocs *cgoAllocMap
	ref86bbdfa4.border_color, cborder_color_allocs = x.BorderColor.PassValue()
	allocs86bbdfa4.Borrow(cborder_color_allocs)

	var clabel_normal_allocs *cgoAllocMap
	ref86bbdfa4.label_normal, clabel_normal_allocs = x.LabelNormal.PassValue()
	allocs86bbdfa4.Borrow(clabel_normal_allocs)

	var clabel_hover_allocs *cgoAllocMap
	ref86bbdfa4.label_hover, clabel_hover_allocs = x.LabelHover.PassValue()
	allocs86bbdfa4.Borrow(clabel_hover_allocs)

	var clabel_active_allocs *cgoAllocMap
	ref86bbdfa4.label_active, clabel_active_allocs = x.LabelActive.PassValue()
	allocs86bbdfa4.Borrow(clabel_active_allocs)

	var csym_left_allocs *cgoAllocMap
	ref86bbdfa4.sym_left, csym_left_allocs = (C.enum_nk_symbol_type)(x.SymLeft), cgoAllocsUnknown
	allocs86bbdfa4.Borrow(csym_left_allocs)

	var csym_right_allocs *cgoAllocMap
	ref86bbdfa4.sym_right, csym_right_allocs = (C.enum_nk_symbol_type)(x.SymRight), cgoAllocsUnknown
	allocs86bbdfa4.Borrow(csym_right_allocs)

	var cborder_allocs *cgoAllocMap
	ref86bbdfa4.border, cborder_allocs = (C.float)(x.Border), cgoAllocsUnknown
	allocs86bbdfa4.Borrow(cborder_allocs)

	var crounding_allocs *cgoAllocMap
	ref86bbdfa4.rounding, crounding_allocs = (C.float)(x.Rounding), cgoAllocsUnknown
	allocs86bbdfa4.Borrow(crounding_allocs)

	var cpadding_allocs *cgoAllocMap
	ref86bbdfa4.padding, cpadding_allocs = x.Padding.PassValue()
	allocs86bbdfa4.Borrow(cpadding_allocs)

	var cedit_allocs *cgoAllocMap
	ref86bbdfa4.edit, cedit_allocs = x.Edit.PassValue()
	allocs86bbdfa4.Borrow(cedit_allocs)

	var cinc_button_allocs *cgoAllocMap
	ref86bbdfa4.inc_button, cinc_button_allocs = x.IncButton.PassValue()
	allocs86bbdfa4.Borrow(cinc_button_allocs)

	var cdec_button_allocs *cgoAllocMap
	ref86bbdfa4.dec_button, cdec_button_allocs = x.DecButton.PassValue()
	allocs86bbdfa4.Borrow(cdec_button_allocs)

	var cuserdata_allocs *cgoAllocMap
	ref86bbdfa4.userdata, cuserdata_allocs = *(*C.nk_handle)(unsafe.Pointer(&x.Userdata)), cgoAllocsUnknown
	allocs86bbdfa4.Borrow(cuserdata_allocs)

	var cdraw_begin_allocs *cgoAllocMap
	ref86bbdfa4.draw_begin, cdraw_begin_allocs = (*[0]byte)(unsafe.Pointer(x.DrawBegin)), cgoAllocsUnknown
	allocs86bbdfa4.Borrow(cdraw_begin_allocs)

	var cdraw_end_allocs *cgoAllocMap
	ref86bbdfa4.draw_end, cdraw_end_allocs = (*[0]byte)(unsafe.Pointer(x.DrawEnd)), cgoAllocsUnknown
	allocs86bbdfa4.Borrow(cdraw_end_allocs)

	x.ref86bbdfa4 = ref86bbdfa4
	x.allocs86bbdfa4 = allocs86bbdfa4
	return ref86bbdfa4, allocs86bbdfa4

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x StyleProperty) PassValue() (C.struct_nk_style_property, *cgoAllocMap) {
	if x.ref86bbdfa4 != nil {
		return *x.ref86bbdfa4, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *StyleProperty) Deref() {
	if x.ref86bbdfa4 == nil {
		return
	}
	x.Normal = *NewStyleItemRef(unsafe.Pointer(&x.ref86bbdfa4.normal))
	x.Hover = *NewStyleItemRef(unsafe.Pointer(&x.ref86bbdfa4.hover))
	x.Active = *NewStyleItemRef(unsafe.Pointer(&x.ref86bbdfa4.active))
	x.BorderColor = *NewColorRef(unsafe.Pointer(&x.ref86bbdfa4.border_color))
	x.LabelNormal = *NewColorRef(unsafe.Pointer(&x.ref86bbdfa4.label_normal))
	x.LabelHover = *NewColorRef(unsafe.Pointer(&x.ref86bbdfa4.label_hover))
	x.LabelActive = *NewColorRef(unsafe.Pointer(&x.ref86bbdfa4.label_active))
	x.SymLeft = (SymbolType)(x.ref86bbdfa4.sym_left)
	x.SymRight = (SymbolType)(x.ref86bbdfa4.sym_right)
	x.Border = (float32)(x.ref86bbdfa4.border)
	x.Rounding = (float32)(x.ref86bbdfa4.rounding)
	x.Padding = *NewVec2Ref(unsafe.Pointer(&x.ref86bbdfa4.padding))
	x.Edit = *NewStyleEditRef(unsafe.Pointer(&x.ref86bbdfa4.edit))
	x.IncButton = *NewStyleButtonRef(unsafe.Pointer(&x.ref86bbdfa4.inc_button))
	x.DecButton = *NewStyleButtonRef(unsafe.Pointer(&x.ref86bbdfa4.dec_button))
	x.Userdata = *(*Handle)(unsafe.Pointer(&x.ref86bbdfa4.userdata))
	// x.DrawBegin is a callback func
	// x.DrawEnd is a callback func
}

// allocStructNkConfigStackColorElementMemory allocates memory for type C.struct_nk_config_stack_color_element in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkConfigStackColorElementMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkConfigStackColorElementValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkConfigStackColorElementValue = unsafe.Sizeof([1]C.struct_nk_config_stack_color_element{})

// unpackSColor transforms a sliced Go data structure into plain C format.
func unpackSColor(x []Color) (unpacked *C.struct_nk_color, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.struct_nk_color) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocStructNkColorMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_nk_color)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_nk_color)(unsafe.Pointer(h.Data))
	return
}

// packSColor reads sliced Go data structure out from plain C format.
func packSColor(v []Color, ptr0 *C.struct_nk_color) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStructNkColorValue]C.struct_nk_color)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewColorRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ConfigStackColorElement) Ref() *C.struct_nk_config_stack_color_element {
	if x == nil {
		return nil
	}
	return x.ref9a04ca79
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ConfigStackColorElement) Free() {
	if x != nil && x.allocs9a04ca79 != nil {
		x.allocs9a04ca79.(*cgoAllocMap).Free()
		x.ref9a04ca79 = nil
	}
}

// NewConfigStackColorElementRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewConfigStackColorElementRef(ref unsafe.Pointer) *ConfigStackColorElement {
	if ref == nil {
		return nil
	}
	obj := new(ConfigStackColorElement)
	obj.ref9a04ca79 = (*C.struct_nk_config_stack_color_element)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ConfigStackColorElement) PassRef() (*C.struct_nk_config_stack_color_element, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9a04ca79 != nil {
		return x.ref9a04ca79, nil
	}
	mem9a04ca79 := allocStructNkConfigStackColorElementMemory(1)
	ref9a04ca79 := (*C.struct_nk_config_stack_color_element)(mem9a04ca79)
	allocs9a04ca79 := new(cgoAllocMap)
	var caddress_allocs *cgoAllocMap
	ref9a04ca79.address, caddress_allocs = unpackSColor(x.Address)
	allocs9a04ca79.Borrow(caddress_allocs)

	var cold_value_allocs *cgoAllocMap
	ref9a04ca79.old_value, cold_value_allocs = x.OldValue.PassValue()
	allocs9a04ca79.Borrow(cold_value_allocs)

	x.ref9a04ca79 = ref9a04ca79
	x.allocs9a04ca79 = allocs9a04ca79
	return ref9a04ca79, allocs9a04ca79

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ConfigStackColorElement) PassValue() (C.struct_nk_config_stack_color_element, *cgoAllocMap) {
	if x.ref9a04ca79 != nil {
		return *x.ref9a04ca79, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ConfigStackColorElement) Deref() {
	if x.ref9a04ca79 == nil {
		return
	}
	packSColor(x.Address, x.ref9a04ca79.address)
	x.OldValue = *NewColorRef(unsafe.Pointer(&x.ref9a04ca79.old_value))
}

// allocStructNkConfigStackFlagsMemory allocates memory for type C.struct_nk_config_stack_flags in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkConfigStackFlagsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkConfigStackFlagsValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkConfigStackFlagsValue = unsafe.Sizeof([1]C.struct_nk_config_stack_flags{})

// allocA32StructNkConfigStackFlagsElementMemory allocates memory for type [32]C.struct_nk_config_stack_flags_element in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA32StructNkConfigStackFlagsElementMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfA32StructNkConfigStackFlagsElementValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfA32StructNkConfigStackFlagsElementValue = unsafe.Sizeof([1][32]C.struct_nk_config_stack_flags_element{})

// unpackA32ConfigStackFlagsElement transforms a sliced Go data structure into plain C format.
func unpackA32ConfigStackFlagsElement(x [32]ConfigStackFlagsElement) (unpacked [32]C.struct_nk_config_stack_flags_element, allocs *cgoAllocMap) {
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(*[32]C.struct_nk_config_stack_flags_element) {
		go allocs.Free()
	})

	mem0 := allocA32StructNkConfigStackFlagsElementMemory(1)
	allocs.Add(mem0)
	v0 := (*[32]C.struct_nk_config_stack_flags_element)(mem0)
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	unpacked = *(*[32]C.struct_nk_config_stack_flags_element)(mem0)
	return
}

// packA32ConfigStackFlagsElement reads sliced Go data structure out from plain C format.
func packA32ConfigStackFlagsElement(v *[32]ConfigStackFlagsElement, ptr0 *[32]C.struct_nk_config_stack_flags_element) {
	for i0 := range v {
		ptr1 := ptr0[i0]
		v[i0] = *NewConfigStackFlagsElementRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ConfigStackFlags) Ref() *C.struct_nk_config_stack_flags {
	if x == nil {
		return nil
	}
	return x.ref4e2d11da
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ConfigStackFlags) Free() {
	if x != nil && x.allocs4e2d11da != nil {
		x.allocs4e2d11da.(*cgoAllocMap).Free()
		x.ref4e2d11da = nil
	}
}

// NewConfigStackFlagsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewConfigStackFlagsRef(ref unsafe.Pointer) *ConfigStackFlags {
	if ref == nil {
		return nil
	}
	obj := new(ConfigStackFlags)
	obj.ref4e2d11da = (*C.struct_nk_config_stack_flags)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ConfigStackFlags) PassRef() (*C.struct_nk_config_stack_flags, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4e2d11da != nil {
		return x.ref4e2d11da, nil
	}
	mem4e2d11da := allocStructNkConfigStackFlagsMemory(1)
	ref4e2d11da := (*C.struct_nk_config_stack_flags)(mem4e2d11da)
	allocs4e2d11da := new(cgoAllocMap)
	var chead_allocs *cgoAllocMap
	ref4e2d11da.head, chead_allocs = (C.int)(x.Head), cgoAllocsUnknown
	allocs4e2d11da.Borrow(chead_allocs)

	var celements_allocs *cgoAllocMap
	ref4e2d11da.elements, celements_allocs = unpackA32ConfigStackFlagsElement(x.Elements)
	allocs4e2d11da.Borrow(celements_allocs)

	x.ref4e2d11da = ref4e2d11da
	x.allocs4e2d11da = allocs4e2d11da
	return ref4e2d11da, allocs4e2d11da

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ConfigStackFlags) PassValue() (C.struct_nk_config_stack_flags, *cgoAllocMap) {
	if x.ref4e2d11da != nil {
		return *x.ref4e2d11da, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ConfigStackFlags) Deref() {
	if x.ref4e2d11da == nil {
		return
	}
	x.Head = (int32)(x.ref4e2d11da.head)
	packA32ConfigStackFlagsElement(&x.Elements, (*[32]C.struct_nk_config_stack_flags_element)(unsafe.Pointer(&x.ref4e2d11da.elements)))
}

// allocStructNkCommandImageMemory allocates memory for type C.struct_nk_command_image in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkCommandImageMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkCommandImageValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkCommandImageValue = unsafe.Sizeof([1]C.struct_nk_command_image{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CommandImage) Ref() *C.struct_nk_command_image {
	if x == nil {
		return nil
	}
	return x.ref14108bd2
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CommandImage) Free() {
	if x != nil && x.allocs14108bd2 != nil {
		x.allocs14108bd2.(*cgoAllocMap).Free()
		x.ref14108bd2 = nil
	}
}

// NewCommandImageRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCommandImageRef(ref unsafe.Pointer) *CommandImage {
	if ref == nil {
		return nil
	}
	obj := new(CommandImage)
	obj.ref14108bd2 = (*C.struct_nk_command_image)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CommandImage) PassRef() (*C.struct_nk_command_image, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref14108bd2 != nil {
		return x.ref14108bd2, nil
	}
	mem14108bd2 := allocStructNkCommandImageMemory(1)
	ref14108bd2 := (*C.struct_nk_command_image)(mem14108bd2)
	allocs14108bd2 := new(cgoAllocMap)
	var cheader_allocs *cgoAllocMap
	ref14108bd2.header, cheader_allocs = x.Header.PassValue()
	allocs14108bd2.Borrow(cheader_allocs)

	var cx_allocs *cgoAllocMap
	ref14108bd2.x, cx_allocs = (C.short)(x.X), cgoAllocsUnknown
	allocs14108bd2.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	ref14108bd2.y, cy_allocs = (C.short)(x.Y), cgoAllocsUnknown
	allocs14108bd2.Borrow(cy_allocs)

	var cw_allocs *cgoAllocMap
	ref14108bd2.w, cw_allocs = (C.ushort)(x.W), cgoAllocsUnknown
	allocs14108bd2.Borrow(cw_allocs)

	var ch_allocs *cgoAllocMap
	ref14108bd2.h, ch_allocs = (C.ushort)(x.H), cgoAllocsUnknown
	allocs14108bd2.Borrow(ch_allocs)

	var cimg_allocs *cgoAllocMap
	ref14108bd2.img, cimg_allocs = x.Img.PassValue()
	allocs14108bd2.Borrow(cimg_allocs)

	var ccol_allocs *cgoAllocMap
	ref14108bd2.col, ccol_allocs = x.Col.PassValue()
	allocs14108bd2.Borrow(ccol_allocs)

	x.ref14108bd2 = ref14108bd2
	x.allocs14108bd2 = allocs14108bd2
	return ref14108bd2, allocs14108bd2

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CommandImage) PassValue() (C.struct_nk_command_image, *cgoAllocMap) {
	if x.ref14108bd2 != nil {
		return *x.ref14108bd2, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CommandImage) Deref() {
	if x.ref14108bd2 == nil {
		return
	}
	x.Header = *NewCommandRef(unsafe.Pointer(&x.ref14108bd2.header))
	x.X = (int16)(x.ref14108bd2.x)
	x.Y = (int16)(x.ref14108bd2.y)
	x.W = (uint16)(x.ref14108bd2.w)
	x.H = (uint16)(x.ref14108bd2.h)
	x.Img = *NewImageRef(unsafe.Pointer(&x.ref14108bd2.img))
	x.Col = *NewColorRef(unsafe.Pointer(&x.ref14108bd2.col))
}

// allocStructNkConfigStackUserFontElementMemory allocates memory for type C.struct_nk_config_stack_user_font_element in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkConfigStackUserFontElementMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkConfigStackUserFontElementValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkConfigStackUserFontElementValue = unsafe.Sizeof([1]C.struct_nk_config_stack_user_font_element{})

// allocPStructNkUserFontMemory allocates memory for type *C.struct_nk_user_font in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPStructNkUserFontMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPStructNkUserFontValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPStructNkUserFontValue = unsafe.Sizeof([1]*C.struct_nk_user_font{})

// unpackSSUserFont transforms a sliced Go data structure into plain C format.
func unpackSSUserFont(x [][]UserFont) (unpacked **C.struct_nk_user_font, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.struct_nk_user_font) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPStructNkUserFontMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.struct_nk_user_font)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocStructNkUserFontMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: uintptr(mem1),
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.struct_nk_user_font)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			v1[i1], _ = x[i0][i1].PassValue()
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.struct_nk_user_font)(unsafe.Pointer(h.Data))
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.struct_nk_user_font)(unsafe.Pointer(h.Data))
	return
}

// packSSUserFont reads sliced Go data structure out from plain C format.
func packSSUserFont(v [][]UserFont, ptr0 **C.struct_nk_user_font) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.struct_nk_user_font)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfStructNkUserFontValue]C.struct_nk_user_font)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewUserFontRef(unsafe.Pointer(&ptr2))
		}
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ConfigStackUserFontElement) Ref() *C.struct_nk_config_stack_user_font_element {
	if x == nil {
		return nil
	}
	return x.ref5572630c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ConfigStackUserFontElement) Free() {
	if x != nil && x.allocs5572630c != nil {
		x.allocs5572630c.(*cgoAllocMap).Free()
		x.ref5572630c = nil
	}
}

// NewConfigStackUserFontElementRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewConfigStackUserFontElementRef(ref unsafe.Pointer) *ConfigStackUserFontElement {
	if ref == nil {
		return nil
	}
	obj := new(ConfigStackUserFontElement)
	obj.ref5572630c = (*C.struct_nk_config_stack_user_font_element)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ConfigStackUserFontElement) PassRef() (*C.struct_nk_config_stack_user_font_element, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5572630c != nil {
		return x.ref5572630c, nil
	}
	mem5572630c := allocStructNkConfigStackUserFontElementMemory(1)
	ref5572630c := (*C.struct_nk_config_stack_user_font_element)(mem5572630c)
	allocs5572630c := new(cgoAllocMap)
	var caddress_allocs *cgoAllocMap
	ref5572630c.address, caddress_allocs = unpackSSUserFont(x.Address)
	allocs5572630c.Borrow(caddress_allocs)

	var cold_value_allocs *cgoAllocMap
	ref5572630c.old_value, cold_value_allocs = unpackSUserFont(x.OldValue)
	allocs5572630c.Borrow(cold_value_allocs)

	x.ref5572630c = ref5572630c
	x.allocs5572630c = allocs5572630c
	return ref5572630c, allocs5572630c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ConfigStackUserFontElement) PassValue() (C.struct_nk_config_stack_user_font_element, *cgoAllocMap) {
	if x.ref5572630c != nil {
		return *x.ref5572630c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ConfigStackUserFontElement) Deref() {
	if x.ref5572630c == nil {
		return
	}
	packSSUserFont(x.Address, x.ref5572630c.address)
	packSUserFont(x.OldValue, x.ref5572630c.old_value)
}

// allocStructNkCommandScissorMemory allocates memory for type C.struct_nk_command_scissor in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkCommandScissorMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkCommandScissorValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkCommandScissorValue = unsafe.Sizeof([1]C.struct_nk_command_scissor{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CommandScissor) Ref() *C.struct_nk_command_scissor {
	if x == nil {
		return nil
	}
	return x.refdad76a99
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CommandScissor) Free() {
	if x != nil && x.allocsdad76a99 != nil {
		x.allocsdad76a99.(*cgoAllocMap).Free()
		x.refdad76a99 = nil
	}
}

// NewCommandScissorRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCommandScissorRef(ref unsafe.Pointer) *CommandScissor {
	if ref == nil {
		return nil
	}
	obj := new(CommandScissor)
	obj.refdad76a99 = (*C.struct_nk_command_scissor)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CommandScissor) PassRef() (*C.struct_nk_command_scissor, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refdad76a99 != nil {
		return x.refdad76a99, nil
	}
	memdad76a99 := allocStructNkCommandScissorMemory(1)
	refdad76a99 := (*C.struct_nk_command_scissor)(memdad76a99)
	allocsdad76a99 := new(cgoAllocMap)
	var cheader_allocs *cgoAllocMap
	refdad76a99.header, cheader_allocs = x.Header.PassValue()
	allocsdad76a99.Borrow(cheader_allocs)

	var cx_allocs *cgoAllocMap
	refdad76a99.x, cx_allocs = (C.short)(x.X), cgoAllocsUnknown
	allocsdad76a99.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	refdad76a99.y, cy_allocs = (C.short)(x.Y), cgoAllocsUnknown
	allocsdad76a99.Borrow(cy_allocs)

	var cw_allocs *cgoAllocMap
	refdad76a99.w, cw_allocs = (C.ushort)(x.W), cgoAllocsUnknown
	allocsdad76a99.Borrow(cw_allocs)

	var ch_allocs *cgoAllocMap
	refdad76a99.h, ch_allocs = (C.ushort)(x.H), cgoAllocsUnknown
	allocsdad76a99.Borrow(ch_allocs)

	x.refdad76a99 = refdad76a99
	x.allocsdad76a99 = allocsdad76a99
	return refdad76a99, allocsdad76a99

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CommandScissor) PassValue() (C.struct_nk_command_scissor, *cgoAllocMap) {
	if x.refdad76a99 != nil {
		return *x.refdad76a99, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CommandScissor) Deref() {
	if x.refdad76a99 == nil {
		return
	}
	x.Header = *NewCommandRef(unsafe.Pointer(&x.refdad76a99.header))
	x.X = (int16)(x.refdad76a99.x)
	x.Y = (int16)(x.refdad76a99.y)
	x.W = (uint16)(x.refdad76a99.w)
	x.H = (uint16)(x.refdad76a99.h)
}

// allocStructNkCommandCircleMemory allocates memory for type C.struct_nk_command_circle in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkCommandCircleMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkCommandCircleValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkCommandCircleValue = unsafe.Sizeof([1]C.struct_nk_command_circle{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CommandCircle) Ref() *C.struct_nk_command_circle {
	if x == nil {
		return nil
	}
	return x.ref476fb76b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CommandCircle) Free() {
	if x != nil && x.allocs476fb76b != nil {
		x.allocs476fb76b.(*cgoAllocMap).Free()
		x.ref476fb76b = nil
	}
}

// NewCommandCircleRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCommandCircleRef(ref unsafe.Pointer) *CommandCircle {
	if ref == nil {
		return nil
	}
	obj := new(CommandCircle)
	obj.ref476fb76b = (*C.struct_nk_command_circle)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CommandCircle) PassRef() (*C.struct_nk_command_circle, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref476fb76b != nil {
		return x.ref476fb76b, nil
	}
	mem476fb76b := allocStructNkCommandCircleMemory(1)
	ref476fb76b := (*C.struct_nk_command_circle)(mem476fb76b)
	allocs476fb76b := new(cgoAllocMap)
	var cheader_allocs *cgoAllocMap
	ref476fb76b.header, cheader_allocs = x.Header.PassValue()
	allocs476fb76b.Borrow(cheader_allocs)

	var cx_allocs *cgoAllocMap
	ref476fb76b.x, cx_allocs = (C.short)(x.X), cgoAllocsUnknown
	allocs476fb76b.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	ref476fb76b.y, cy_allocs = (C.short)(x.Y), cgoAllocsUnknown
	allocs476fb76b.Borrow(cy_allocs)

	var cline_thickness_allocs *cgoAllocMap
	ref476fb76b.line_thickness, cline_thickness_allocs = (C.ushort)(x.LineThickness), cgoAllocsUnknown
	allocs476fb76b.Borrow(cline_thickness_allocs)

	var cw_allocs *cgoAllocMap
	ref476fb76b.w, cw_allocs = (C.ushort)(x.W), cgoAllocsUnknown
	allocs476fb76b.Borrow(cw_allocs)

	var ch_allocs *cgoAllocMap
	ref476fb76b.h, ch_allocs = (C.ushort)(x.H), cgoAllocsUnknown
	allocs476fb76b.Borrow(ch_allocs)

	var ccolor_allocs *cgoAllocMap
	ref476fb76b.color, ccolor_allocs = x.Color.PassValue()
	allocs476fb76b.Borrow(ccolor_allocs)

	x.ref476fb76b = ref476fb76b
	x.allocs476fb76b = allocs476fb76b
	return ref476fb76b, allocs476fb76b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CommandCircle) PassValue() (C.struct_nk_command_circle, *cgoAllocMap) {
	if x.ref476fb76b != nil {
		return *x.ref476fb76b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CommandCircle) Deref() {
	if x.ref476fb76b == nil {
		return
	}
	x.Header = *NewCommandRef(unsafe.Pointer(&x.ref476fb76b.header))
	x.X = (int16)(x.ref476fb76b.x)
	x.Y = (int16)(x.ref476fb76b.y)
	x.LineThickness = (uint16)(x.ref476fb76b.line_thickness)
	x.W = (uint16)(x.ref476fb76b.w)
	x.H = (uint16)(x.ref476fb76b.h)
	x.Color = *NewColorRef(unsafe.Pointer(&x.ref476fb76b.color))
}

// allocStructNkStyleWindowHeaderMemory allocates memory for type C.struct_nk_style_window_header in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkStyleWindowHeaderMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkStyleWindowHeaderValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkStyleWindowHeaderValue = unsafe.Sizeof([1]C.struct_nk_style_window_header{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *StyleWindowHeader) Ref() *C.struct_nk_style_window_header {
	if x == nil {
		return nil
	}
	return x.ref95bb44b7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *StyleWindowHeader) Free() {
	if x != nil && x.allocs95bb44b7 != nil {
		x.allocs95bb44b7.(*cgoAllocMap).Free()
		x.ref95bb44b7 = nil
	}
}

// NewStyleWindowHeaderRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewStyleWindowHeaderRef(ref unsafe.Pointer) *StyleWindowHeader {
	if ref == nil {
		return nil
	}
	obj := new(StyleWindowHeader)
	obj.ref95bb44b7 = (*C.struct_nk_style_window_header)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *StyleWindowHeader) PassRef() (*C.struct_nk_style_window_header, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref95bb44b7 != nil {
		return x.ref95bb44b7, nil
	}
	mem95bb44b7 := allocStructNkStyleWindowHeaderMemory(1)
	ref95bb44b7 := (*C.struct_nk_style_window_header)(mem95bb44b7)
	allocs95bb44b7 := new(cgoAllocMap)
	var cnormal_allocs *cgoAllocMap
	ref95bb44b7.normal, cnormal_allocs = x.Normal.PassValue()
	allocs95bb44b7.Borrow(cnormal_allocs)

	var chover_allocs *cgoAllocMap
	ref95bb44b7.hover, chover_allocs = x.Hover.PassValue()
	allocs95bb44b7.Borrow(chover_allocs)

	var cactive_allocs *cgoAllocMap
	ref95bb44b7.active, cactive_allocs = x.Active.PassValue()
	allocs95bb44b7.Borrow(cactive_allocs)

	var cclose_button_allocs *cgoAllocMap
	ref95bb44b7.close_button, cclose_button_allocs = x.CloseButton.PassValue()
	allocs95bb44b7.Borrow(cclose_button_allocs)

	var cminimize_button_allocs *cgoAllocMap
	ref95bb44b7.minimize_button, cminimize_button_allocs = x.MinimizeButton.PassValue()
	allocs95bb44b7.Borrow(cminimize_button_allocs)

	var cclose_symbol_allocs *cgoAllocMap
	ref95bb44b7.close_symbol, cclose_symbol_allocs = (C.enum_nk_symbol_type)(x.CloseSymbol), cgoAllocsUnknown
	allocs95bb44b7.Borrow(cclose_symbol_allocs)

	var cminimize_symbol_allocs *cgoAllocMap
	ref95bb44b7.minimize_symbol, cminimize_symbol_allocs = (C.enum_nk_symbol_type)(x.MinimizeSymbol), cgoAllocsUnknown
	allocs95bb44b7.Borrow(cminimize_symbol_allocs)

	var cmaximize_symbol_allocs *cgoAllocMap
	ref95bb44b7.maximize_symbol, cmaximize_symbol_allocs = (C.enum_nk_symbol_type)(x.MaximizeSymbol), cgoAllocsUnknown
	allocs95bb44b7.Borrow(cmaximize_symbol_allocs)

	var clabel_normal_allocs *cgoAllocMap
	ref95bb44b7.label_normal, clabel_normal_allocs = x.LabelNormal.PassValue()
	allocs95bb44b7.Borrow(clabel_normal_allocs)

	var clabel_hover_allocs *cgoAllocMap
	ref95bb44b7.label_hover, clabel_hover_allocs = x.LabelHover.PassValue()
	allocs95bb44b7.Borrow(clabel_hover_allocs)

	var clabel_active_allocs *cgoAllocMap
	ref95bb44b7.label_active, clabel_active_allocs = x.LabelActive.PassValue()
	allocs95bb44b7.Borrow(clabel_active_allocs)

	var calign_allocs *cgoAllocMap
	ref95bb44b7.align, calign_allocs = (C.enum_nk_style_header_align)(x.Align), cgoAllocsUnknown
	allocs95bb44b7.Borrow(calign_allocs)

	var cpadding_allocs *cgoAllocMap
	ref95bb44b7.padding, cpadding_allocs = x.Padding.PassValue()
	allocs95bb44b7.Borrow(cpadding_allocs)

	var clabel_padding_allocs *cgoAllocMap
	ref95bb44b7.label_padding, clabel_padding_allocs = x.LabelPadding.PassValue()
	allocs95bb44b7.Borrow(clabel_padding_allocs)

	var cspacing_allocs *cgoAllocMap
	ref95bb44b7.spacing, cspacing_allocs = x.Spacing.PassValue()
	allocs95bb44b7.Borrow(cspacing_allocs)

	x.ref95bb44b7 = ref95bb44b7
	x.allocs95bb44b7 = allocs95bb44b7
	return ref95bb44b7, allocs95bb44b7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x StyleWindowHeader) PassValue() (C.struct_nk_style_window_header, *cgoAllocMap) {
	if x.ref95bb44b7 != nil {
		return *x.ref95bb44b7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *StyleWindowHeader) Deref() {
	if x.ref95bb44b7 == nil {
		return
	}
	x.Normal = *NewStyleItemRef(unsafe.Pointer(&x.ref95bb44b7.normal))
	x.Hover = *NewStyleItemRef(unsafe.Pointer(&x.ref95bb44b7.hover))
	x.Active = *NewStyleItemRef(unsafe.Pointer(&x.ref95bb44b7.active))
	x.CloseButton = *NewStyleButtonRef(unsafe.Pointer(&x.ref95bb44b7.close_button))
	x.MinimizeButton = *NewStyleButtonRef(unsafe.Pointer(&x.ref95bb44b7.minimize_button))
	x.CloseSymbol = (SymbolType)(x.ref95bb44b7.close_symbol)
	x.MinimizeSymbol = (SymbolType)(x.ref95bb44b7.minimize_symbol)
	x.MaximizeSymbol = (SymbolType)(x.ref95bb44b7.maximize_symbol)
	x.LabelNormal = *NewColorRef(unsafe.Pointer(&x.ref95bb44b7.label_normal))
	x.LabelHover = *NewColorRef(unsafe.Pointer(&x.ref95bb44b7.label_hover))
	x.LabelActive = *NewColorRef(unsafe.Pointer(&x.ref95bb44b7.label_active))
	x.Align = (StyleHeaderAlign)(x.ref95bb44b7.align)
	x.Padding = *NewVec2Ref(unsafe.Pointer(&x.ref95bb44b7.padding))
	x.LabelPadding = *NewVec2Ref(unsafe.Pointer(&x.ref95bb44b7.label_padding))
	x.Spacing = *NewVec2Ref(unsafe.Pointer(&x.ref95bb44b7.spacing))
}

// allocStructNkTextUndoStateMemory allocates memory for type C.struct_nk_text_undo_state in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkTextUndoStateMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkTextUndoStateValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkTextUndoStateValue = unsafe.Sizeof([1]C.struct_nk_text_undo_state{})

// allocA99StructNkTextUndoRecordMemory allocates memory for type [99]C.struct_nk_text_undo_record in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA99StructNkTextUndoRecordMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfA99StructNkTextUndoRecordValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfA99StructNkTextUndoRecordValue = unsafe.Sizeof([1][99]C.struct_nk_text_undo_record{})

// unpackA99TextUndoRecord transforms a sliced Go data structure into plain C format.
func unpackA99TextUndoRecord(x [99]TextUndoRecord) (unpacked [99]C.struct_nk_text_undo_record, allocs *cgoAllocMap) {
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(*[99]C.struct_nk_text_undo_record) {
		go allocs.Free()
	})

	mem0 := allocA99StructNkTextUndoRecordMemory(1)
	allocs.Add(mem0)
	v0 := (*[99]C.struct_nk_text_undo_record)(mem0)
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	unpacked = *(*[99]C.struct_nk_text_undo_record)(mem0)
	return
}

// packA99TextUndoRecord reads sliced Go data structure out from plain C format.
func packA99TextUndoRecord(v *[99]TextUndoRecord, ptr0 *[99]C.struct_nk_text_undo_record) {
	for i0 := range v {
		ptr1 := ptr0[i0]
		v[i0] = *NewTextUndoRecordRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TextUndoState) Ref() *C.struct_nk_text_undo_state {
	if x == nil {
		return nil
	}
	return x.ref56c782f6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TextUndoState) Free() {
	if x != nil && x.allocs56c782f6 != nil {
		x.allocs56c782f6.(*cgoAllocMap).Free()
		x.ref56c782f6 = nil
	}
}

// NewTextUndoStateRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTextUndoStateRef(ref unsafe.Pointer) *TextUndoState {
	if ref == nil {
		return nil
	}
	obj := new(TextUndoState)
	obj.ref56c782f6 = (*C.struct_nk_text_undo_state)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TextUndoState) PassRef() (*C.struct_nk_text_undo_state, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref56c782f6 != nil {
		return x.ref56c782f6, nil
	}
	mem56c782f6 := allocStructNkTextUndoStateMemory(1)
	ref56c782f6 := (*C.struct_nk_text_undo_state)(mem56c782f6)
	allocs56c782f6 := new(cgoAllocMap)
	var cundo_rec_allocs *cgoAllocMap
	ref56c782f6.undo_rec, cundo_rec_allocs = unpackA99TextUndoRecord(x.UndoRec)
	allocs56c782f6.Borrow(cundo_rec_allocs)

	var cundo_char_allocs *cgoAllocMap
	ref56c782f6.undo_char, cundo_char_allocs = *(*[999]C.nk_rune)(unsafe.Pointer(&x.UndoChar)), cgoAllocsUnknown
	allocs56c782f6.Borrow(cundo_char_allocs)

	var cundo_point_allocs *cgoAllocMap
	ref56c782f6.undo_point, cundo_point_allocs = (C.short)(x.UndoPoint), cgoAllocsUnknown
	allocs56c782f6.Borrow(cundo_point_allocs)

	var credo_point_allocs *cgoAllocMap
	ref56c782f6.redo_point, credo_point_allocs = (C.short)(x.RedoPoint), cgoAllocsUnknown
	allocs56c782f6.Borrow(credo_point_allocs)

	var cundo_char_point_allocs *cgoAllocMap
	ref56c782f6.undo_char_point, cundo_char_point_allocs = (C.short)(x.UndoCharPoint), cgoAllocsUnknown
	allocs56c782f6.Borrow(cundo_char_point_allocs)

	var credo_char_point_allocs *cgoAllocMap
	ref56c782f6.redo_char_point, credo_char_point_allocs = (C.short)(x.RedoCharPoint), cgoAllocsUnknown
	allocs56c782f6.Borrow(credo_char_point_allocs)

	x.ref56c782f6 = ref56c782f6
	x.allocs56c782f6 = allocs56c782f6
	return ref56c782f6, allocs56c782f6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TextUndoState) PassValue() (C.struct_nk_text_undo_state, *cgoAllocMap) {
	if x.ref56c782f6 != nil {
		return *x.ref56c782f6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TextUndoState) Deref() {
	if x.ref56c782f6 == nil {
		return
	}
	packA99TextUndoRecord(&x.UndoRec, (*[99]C.struct_nk_text_undo_record)(unsafe.Pointer(&x.ref56c782f6.undo_rec)))
	x.UndoChar = *(*[999]Rune)(unsafe.Pointer(&x.ref56c782f6.undo_char))
	x.UndoPoint = (int16)(x.ref56c782f6.undo_point)
	x.RedoPoint = (int16)(x.ref56c782f6.redo_point)
	x.UndoCharPoint = (int16)(x.ref56c782f6.undo_char_point)
	x.RedoCharPoint = (int16)(x.ref56c782f6.redo_char_point)
}

// allocStructNkConfigStackVec2Memory allocates memory for type C.struct_nk_config_stack_vec2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkConfigStackVec2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkConfigStackVec2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkConfigStackVec2Value = unsafe.Sizeof([1]C.struct_nk_config_stack_vec2{})

// allocA16StructNkConfigStackVec2ElementMemory allocates memory for type [16]C.struct_nk_config_stack_vec2_element in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA16StructNkConfigStackVec2ElementMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfA16StructNkConfigStackVec2ElementValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfA16StructNkConfigStackVec2ElementValue = unsafe.Sizeof([1][16]C.struct_nk_config_stack_vec2_element{})

// unpackA16ConfigStackVec2Element transforms a sliced Go data structure into plain C format.
func unpackA16ConfigStackVec2Element(x [16]ConfigStackVec2Element) (unpacked [16]C.struct_nk_config_stack_vec2_element, allocs *cgoAllocMap) {
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(*[16]C.struct_nk_config_stack_vec2_element) {
		go allocs.Free()
	})

	mem0 := allocA16StructNkConfigStackVec2ElementMemory(1)
	allocs.Add(mem0)
	v0 := (*[16]C.struct_nk_config_stack_vec2_element)(mem0)
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	unpacked = *(*[16]C.struct_nk_config_stack_vec2_element)(mem0)
	return
}

// packA16ConfigStackVec2Element reads sliced Go data structure out from plain C format.
func packA16ConfigStackVec2Element(v *[16]ConfigStackVec2Element, ptr0 *[16]C.struct_nk_config_stack_vec2_element) {
	for i0 := range v {
		ptr1 := ptr0[i0]
		v[i0] = *NewConfigStackVec2ElementRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ConfigStackVec2) Ref() *C.struct_nk_config_stack_vec2 {
	if x == nil {
		return nil
	}
	return x.ref5007555e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ConfigStackVec2) Free() {
	if x != nil && x.allocs5007555e != nil {
		x.allocs5007555e.(*cgoAllocMap).Free()
		x.ref5007555e = nil
	}
}

// NewConfigStackVec2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewConfigStackVec2Ref(ref unsafe.Pointer) *ConfigStackVec2 {
	if ref == nil {
		return nil
	}
	obj := new(ConfigStackVec2)
	obj.ref5007555e = (*C.struct_nk_config_stack_vec2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ConfigStackVec2) PassRef() (*C.struct_nk_config_stack_vec2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5007555e != nil {
		return x.ref5007555e, nil
	}
	mem5007555e := allocStructNkConfigStackVec2Memory(1)
	ref5007555e := (*C.struct_nk_config_stack_vec2)(mem5007555e)
	allocs5007555e := new(cgoAllocMap)
	var chead_allocs *cgoAllocMap
	ref5007555e.head, chead_allocs = (C.int)(x.Head), cgoAllocsUnknown
	allocs5007555e.Borrow(chead_allocs)

	var celements_allocs *cgoAllocMap
	ref5007555e.elements, celements_allocs = unpackA16ConfigStackVec2Element(x.Elements)
	allocs5007555e.Borrow(celements_allocs)

	x.ref5007555e = ref5007555e
	x.allocs5007555e = allocs5007555e
	return ref5007555e, allocs5007555e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ConfigStackVec2) PassValue() (C.struct_nk_config_stack_vec2, *cgoAllocMap) {
	if x.ref5007555e != nil {
		return *x.ref5007555e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ConfigStackVec2) Deref() {
	if x.ref5007555e == nil {
		return
	}
	x.Head = (int32)(x.ref5007555e.head)
	packA16ConfigStackVec2Element(&x.Elements, (*[16]C.struct_nk_config_stack_vec2_element)(unsafe.Pointer(&x.ref5007555e.elements)))
}

// allocStructNkVec2iMemory allocates memory for type C.struct_nk_vec2i in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkVec2iMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkVec2iValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkVec2iValue = unsafe.Sizeof([1]C.struct_nk_vec2i{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Vec2i) Ref() *C.struct_nk_vec2i {
	if x == nil {
		return nil
	}
	return x.refb9f81d21
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Vec2i) Free() {
	if x != nil && x.allocsb9f81d21 != nil {
		x.allocsb9f81d21.(*cgoAllocMap).Free()
		x.refb9f81d21 = nil
	}
}

// NewVec2iRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewVec2iRef(ref unsafe.Pointer) *Vec2i {
	if ref == nil {
		return nil
	}
	obj := new(Vec2i)
	obj.refb9f81d21 = (*C.struct_nk_vec2i)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Vec2i) PassRef() (*C.struct_nk_vec2i, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb9f81d21 != nil {
		return x.refb9f81d21, nil
	}
	memb9f81d21 := allocStructNkVec2iMemory(1)
	refb9f81d21 := (*C.struct_nk_vec2i)(memb9f81d21)
	allocsb9f81d21 := new(cgoAllocMap)
	var cx_allocs *cgoAllocMap
	refb9f81d21.x, cx_allocs = (C.short)(x.X), cgoAllocsUnknown
	allocsb9f81d21.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	refb9f81d21.y, cy_allocs = (C.short)(x.Y), cgoAllocsUnknown
	allocsb9f81d21.Borrow(cy_allocs)

	x.refb9f81d21 = refb9f81d21
	x.allocsb9f81d21 = allocsb9f81d21
	return refb9f81d21, allocsb9f81d21

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Vec2i) PassValue() (C.struct_nk_vec2i, *cgoAllocMap) {
	if x.refb9f81d21 != nil {
		return *x.refb9f81d21, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Vec2i) Deref() {
	if x.refb9f81d21 == nil {
		return
	}
	x.X = (int16)(x.refb9f81d21.x)
	x.Y = (int16)(x.refb9f81d21.y)
}

// allocStructNkMouseButtonMemory allocates memory for type C.struct_nk_mouse_button in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkMouseButtonMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkMouseButtonValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkMouseButtonValue = unsafe.Sizeof([1]C.struct_nk_mouse_button{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MouseButton) Ref() *C.struct_nk_mouse_button {
	if x == nil {
		return nil
	}
	return x.ref265a908d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MouseButton) Free() {
	if x != nil && x.allocs265a908d != nil {
		x.allocs265a908d.(*cgoAllocMap).Free()
		x.ref265a908d = nil
	}
}

// NewMouseButtonRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMouseButtonRef(ref unsafe.Pointer) *MouseButton {
	if ref == nil {
		return nil
	}
	obj := new(MouseButton)
	obj.ref265a908d = (*C.struct_nk_mouse_button)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MouseButton) PassRef() (*C.struct_nk_mouse_button, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref265a908d != nil {
		return x.ref265a908d, nil
	}
	mem265a908d := allocStructNkMouseButtonMemory(1)
	ref265a908d := (*C.struct_nk_mouse_button)(mem265a908d)
	allocs265a908d := new(cgoAllocMap)
	var cdown_allocs *cgoAllocMap
	ref265a908d.down, cdown_allocs = (C.int)(x.Down), cgoAllocsUnknown
	allocs265a908d.Borrow(cdown_allocs)

	var cclicked_allocs *cgoAllocMap
	ref265a908d.clicked, cclicked_allocs = (C.uint)(x.Clicked), cgoAllocsUnknown
	allocs265a908d.Borrow(cclicked_allocs)

	var cclicked_pos_allocs *cgoAllocMap
	ref265a908d.clicked_pos, cclicked_pos_allocs = x.ClickedPos.PassValue()
	allocs265a908d.Borrow(cclicked_pos_allocs)

	x.ref265a908d = ref265a908d
	x.allocs265a908d = allocs265a908d
	return ref265a908d, allocs265a908d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MouseButton) PassValue() (C.struct_nk_mouse_button, *cgoAllocMap) {
	if x.ref265a908d != nil {
		return *x.ref265a908d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *MouseButton) Deref() {
	if x.ref265a908d == nil {
		return
	}
	x.Down = (int32)(x.ref265a908d.down)
	x.Clicked = (uint32)(x.ref265a908d.clicked)
	x.ClickedPos = *NewVec2Ref(unsafe.Pointer(&x.ref265a908d.clicked_pos))
}

// allocStructNkConfigStackButtonBehaviorMemory allocates memory for type C.struct_nk_config_stack_button_behavior in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkConfigStackButtonBehaviorMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkConfigStackButtonBehaviorValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkConfigStackButtonBehaviorValue = unsafe.Sizeof([1]C.struct_nk_config_stack_button_behavior{})

// allocA8StructNkConfigStackButtonBehaviorElementMemory allocates memory for type [8]C.struct_nk_config_stack_button_behavior_element in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA8StructNkConfigStackButtonBehaviorElementMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfA8StructNkConfigStackButtonBehaviorElementValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfA8StructNkConfigStackButtonBehaviorElementValue = unsafe.Sizeof([1][8]C.struct_nk_config_stack_button_behavior_element{})

// unpackA8ConfigStackButtonBehaviorElement transforms a sliced Go data structure into plain C format.
func unpackA8ConfigStackButtonBehaviorElement(x [8]ConfigStackButtonBehaviorElement) (unpacked [8]C.struct_nk_config_stack_button_behavior_element, allocs *cgoAllocMap) {
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(*[8]C.struct_nk_config_stack_button_behavior_element) {
		go allocs.Free()
	})

	mem0 := allocA8StructNkConfigStackButtonBehaviorElementMemory(1)
	allocs.Add(mem0)
	v0 := (*[8]C.struct_nk_config_stack_button_behavior_element)(mem0)
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	unpacked = *(*[8]C.struct_nk_config_stack_button_behavior_element)(mem0)
	return
}

// packA8ConfigStackButtonBehaviorElement reads sliced Go data structure out from plain C format.
func packA8ConfigStackButtonBehaviorElement(v *[8]ConfigStackButtonBehaviorElement, ptr0 *[8]C.struct_nk_config_stack_button_behavior_element) {
	for i0 := range v {
		ptr1 := ptr0[i0]
		v[i0] = *NewConfigStackButtonBehaviorElementRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ConfigStackButtonBehavior) Ref() *C.struct_nk_config_stack_button_behavior {
	if x == nil {
		return nil
	}
	return x.ref6ed3475c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ConfigStackButtonBehavior) Free() {
	if x != nil && x.allocs6ed3475c != nil {
		x.allocs6ed3475c.(*cgoAllocMap).Free()
		x.ref6ed3475c = nil
	}
}

// NewConfigStackButtonBehaviorRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewConfigStackButtonBehaviorRef(ref unsafe.Pointer) *ConfigStackButtonBehavior {
	if ref == nil {
		return nil
	}
	obj := new(ConfigStackButtonBehavior)
	obj.ref6ed3475c = (*C.struct_nk_config_stack_button_behavior)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ConfigStackButtonBehavior) PassRef() (*C.struct_nk_config_stack_button_behavior, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6ed3475c != nil {
		return x.ref6ed3475c, nil
	}
	mem6ed3475c := allocStructNkConfigStackButtonBehaviorMemory(1)
	ref6ed3475c := (*C.struct_nk_config_stack_button_behavior)(mem6ed3475c)
	allocs6ed3475c := new(cgoAllocMap)
	var chead_allocs *cgoAllocMap
	ref6ed3475c.head, chead_allocs = (C.int)(x.Head), cgoAllocsUnknown
	allocs6ed3475c.Borrow(chead_allocs)

	var celements_allocs *cgoAllocMap
	ref6ed3475c.elements, celements_allocs = unpackA8ConfigStackButtonBehaviorElement(x.Elements)
	allocs6ed3475c.Borrow(celements_allocs)

	x.ref6ed3475c = ref6ed3475c
	x.allocs6ed3475c = allocs6ed3475c
	return ref6ed3475c, allocs6ed3475c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ConfigStackButtonBehavior) PassValue() (C.struct_nk_config_stack_button_behavior, *cgoAllocMap) {
	if x.ref6ed3475c != nil {
		return *x.ref6ed3475c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ConfigStackButtonBehavior) Deref() {
	if x.ref6ed3475c == nil {
		return
	}
	x.Head = (int32)(x.ref6ed3475c.head)
	packA8ConfigStackButtonBehaviorElement(&x.Elements, (*[8]C.struct_nk_config_stack_button_behavior_element)(unsafe.Pointer(&x.ref6ed3475c.elements)))
}

// allocStructNkStyleButtonMemory allocates memory for type C.struct_nk_style_button in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkStyleButtonMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkStyleButtonValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkStyleButtonValue = unsafe.Sizeof([1]C.struct_nk_style_button{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *StyleButton) Ref() *C.struct_nk_style_button {
	if x == nil {
		return nil
	}
	return x.ref27e180ce
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *StyleButton) Free() {
	if x != nil && x.allocs27e180ce != nil {
		x.allocs27e180ce.(*cgoAllocMap).Free()
		x.ref27e180ce = nil
	}
}

// NewStyleButtonRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewStyleButtonRef(ref unsafe.Pointer) *StyleButton {
	if ref == nil {
		return nil
	}
	obj := new(StyleButton)
	obj.ref27e180ce = (*C.struct_nk_style_button)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *StyleButton) PassRef() (*C.struct_nk_style_button, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref27e180ce != nil {
		return x.ref27e180ce, nil
	}
	mem27e180ce := allocStructNkStyleButtonMemory(1)
	ref27e180ce := (*C.struct_nk_style_button)(mem27e180ce)
	allocs27e180ce := new(cgoAllocMap)
	var cnormal_allocs *cgoAllocMap
	ref27e180ce.normal, cnormal_allocs = x.Normal.PassValue()
	allocs27e180ce.Borrow(cnormal_allocs)

	var chover_allocs *cgoAllocMap
	ref27e180ce.hover, chover_allocs = x.Hover.PassValue()
	allocs27e180ce.Borrow(chover_allocs)

	var cactive_allocs *cgoAllocMap
	ref27e180ce.active, cactive_allocs = x.Active.PassValue()
	allocs27e180ce.Borrow(cactive_allocs)

	var cborder_color_allocs *cgoAllocMap
	ref27e180ce.border_color, cborder_color_allocs = x.BorderColor.PassValue()
	allocs27e180ce.Borrow(cborder_color_allocs)

	var ctext_background_allocs *cgoAllocMap
	ref27e180ce.text_background, ctext_background_allocs = x.TextBackground.PassValue()
	allocs27e180ce.Borrow(ctext_background_allocs)

	var ctext_normal_allocs *cgoAllocMap
	ref27e180ce.text_normal, ctext_normal_allocs = x.TextNormal.PassValue()
	allocs27e180ce.Borrow(ctext_normal_allocs)

	var ctext_hover_allocs *cgoAllocMap
	ref27e180ce.text_hover, ctext_hover_allocs = x.TextHover.PassValue()
	allocs27e180ce.Borrow(ctext_hover_allocs)

	var ctext_active_allocs *cgoAllocMap
	ref27e180ce.text_active, ctext_active_allocs = x.TextActive.PassValue()
	allocs27e180ce.Borrow(ctext_active_allocs)

	var ctext_alignment_allocs *cgoAllocMap
	ref27e180ce.text_alignment, ctext_alignment_allocs = (C.nk_flags)(x.TextAlignment), cgoAllocsUnknown
	allocs27e180ce.Borrow(ctext_alignment_allocs)

	var cborder_allocs *cgoAllocMap
	ref27e180ce.border, cborder_allocs = (C.float)(x.Border), cgoAllocsUnknown
	allocs27e180ce.Borrow(cborder_allocs)

	var crounding_allocs *cgoAllocMap
	ref27e180ce.rounding, crounding_allocs = (C.float)(x.Rounding), cgoAllocsUnknown
	allocs27e180ce.Borrow(crounding_allocs)

	var cpadding_allocs *cgoAllocMap
	ref27e180ce.padding, cpadding_allocs = x.Padding.PassValue()
	allocs27e180ce.Borrow(cpadding_allocs)

	var cimage_padding_allocs *cgoAllocMap
	ref27e180ce.image_padding, cimage_padding_allocs = x.ImagePadding.PassValue()
	allocs27e180ce.Borrow(cimage_padding_allocs)

	var ctouch_padding_allocs *cgoAllocMap
	ref27e180ce.touch_padding, ctouch_padding_allocs = x.TouchPadding.PassValue()
	allocs27e180ce.Borrow(ctouch_padding_allocs)

	var cuserdata_allocs *cgoAllocMap
	ref27e180ce.userdata, cuserdata_allocs = *(*C.nk_handle)(unsafe.Pointer(&x.Userdata)), cgoAllocsUnknown
	allocs27e180ce.Borrow(cuserdata_allocs)

	var cdraw_begin_allocs *cgoAllocMap
	ref27e180ce.draw_begin, cdraw_begin_allocs = (*[0]byte)(unsafe.Pointer(x.DrawBegin)), cgoAllocsUnknown
	allocs27e180ce.Borrow(cdraw_begin_allocs)

	var cdraw_end_allocs *cgoAllocMap
	ref27e180ce.draw_end, cdraw_end_allocs = (*[0]byte)(unsafe.Pointer(x.DrawEnd)), cgoAllocsUnknown
	allocs27e180ce.Borrow(cdraw_end_allocs)

	x.ref27e180ce = ref27e180ce
	x.allocs27e180ce = allocs27e180ce
	return ref27e180ce, allocs27e180ce

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x StyleButton) PassValue() (C.struct_nk_style_button, *cgoAllocMap) {
	if x.ref27e180ce != nil {
		return *x.ref27e180ce, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *StyleButton) Deref() {
	if x.ref27e180ce == nil {
		return
	}
	x.Normal = *NewStyleItemRef(unsafe.Pointer(&x.ref27e180ce.normal))
	x.Hover = *NewStyleItemRef(unsafe.Pointer(&x.ref27e180ce.hover))
	x.Active = *NewStyleItemRef(unsafe.Pointer(&x.ref27e180ce.active))
	x.BorderColor = *NewColorRef(unsafe.Pointer(&x.ref27e180ce.border_color))
	x.TextBackground = *NewColorRef(unsafe.Pointer(&x.ref27e180ce.text_background))
	x.TextNormal = *NewColorRef(unsafe.Pointer(&x.ref27e180ce.text_normal))
	x.TextHover = *NewColorRef(unsafe.Pointer(&x.ref27e180ce.text_hover))
	x.TextActive = *NewColorRef(unsafe.Pointer(&x.ref27e180ce.text_active))
	x.TextAlignment = (Flags)(x.ref27e180ce.text_alignment)
	x.Border = (float32)(x.ref27e180ce.border)
	x.Rounding = (float32)(x.ref27e180ce.rounding)
	x.Padding = *NewVec2Ref(unsafe.Pointer(&x.ref27e180ce.padding))
	x.ImagePadding = *NewVec2Ref(unsafe.Pointer(&x.ref27e180ce.image_padding))
	x.TouchPadding = *NewVec2Ref(unsafe.Pointer(&x.ref27e180ce.touch_padding))
	x.Userdata = *(*Handle)(unsafe.Pointer(&x.ref27e180ce.userdata))
	// x.DrawBegin is a callback func
	// x.DrawEnd is a callback func
}

// allocStructNkConfigStackFloatElementMemory allocates memory for type C.struct_nk_config_stack_float_element in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkConfigStackFloatElementMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkConfigStackFloatElementValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkConfigStackFloatElementValue = unsafe.Sizeof([1]C.struct_nk_config_stack_float_element{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ConfigStackFloatElement) Ref() *C.struct_nk_config_stack_float_element {
	if x == nil {
		return nil
	}
	return x.ref48484a2
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ConfigStackFloatElement) Free() {
	if x != nil && x.allocs48484a2 != nil {
		x.allocs48484a2.(*cgoAllocMap).Free()
		x.ref48484a2 = nil
	}
}

// NewConfigStackFloatElementRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewConfigStackFloatElementRef(ref unsafe.Pointer) *ConfigStackFloatElement {
	if ref == nil {
		return nil
	}
	obj := new(ConfigStackFloatElement)
	obj.ref48484a2 = (*C.struct_nk_config_stack_float_element)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ConfigStackFloatElement) PassRef() (*C.struct_nk_config_stack_float_element, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref48484a2 != nil {
		return x.ref48484a2, nil
	}
	mem48484a2 := allocStructNkConfigStackFloatElementMemory(1)
	ref48484a2 := (*C.struct_nk_config_stack_float_element)(mem48484a2)
	allocs48484a2 := new(cgoAllocMap)
	var caddress_allocs *cgoAllocMap
	ref48484a2.address, caddress_allocs = (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Address)).Data)), cgoAllocsUnknown
	allocs48484a2.Borrow(caddress_allocs)

	var cold_value_allocs *cgoAllocMap
	ref48484a2.old_value, cold_value_allocs = (C.float)(x.OldValue), cgoAllocsUnknown
	allocs48484a2.Borrow(cold_value_allocs)

	x.ref48484a2 = ref48484a2
	x.allocs48484a2 = allocs48484a2
	return ref48484a2, allocs48484a2

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ConfigStackFloatElement) PassValue() (C.struct_nk_config_stack_float_element, *cgoAllocMap) {
	if x.ref48484a2 != nil {
		return *x.ref48484a2, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ConfigStackFloatElement) Deref() {
	if x.ref48484a2 == nil {
		return
	}
	hxfa9955c := (*sliceHeader)(unsafe.Pointer(&x.Address))
	hxfa9955c.Data = uintptr(unsafe.Pointer(x.ref48484a2.address))
	hxfa9955c.Cap = 0x7fffffff
	// hxfa9955c.Len = ?

	x.OldValue = (float32)(x.ref48484a2.old_value)
}

// allocStructNkCommandRectFilledMemory allocates memory for type C.struct_nk_command_rect_filled in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkCommandRectFilledMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkCommandRectFilledValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkCommandRectFilledValue = unsafe.Sizeof([1]C.struct_nk_command_rect_filled{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CommandRectFilled) Ref() *C.struct_nk_command_rect_filled {
	if x == nil {
		return nil
	}
	return x.ref5029f39
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CommandRectFilled) Free() {
	if x != nil && x.allocs5029f39 != nil {
		x.allocs5029f39.(*cgoAllocMap).Free()
		x.ref5029f39 = nil
	}
}

// NewCommandRectFilledRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCommandRectFilledRef(ref unsafe.Pointer) *CommandRectFilled {
	if ref == nil {
		return nil
	}
	obj := new(CommandRectFilled)
	obj.ref5029f39 = (*C.struct_nk_command_rect_filled)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CommandRectFilled) PassRef() (*C.struct_nk_command_rect_filled, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5029f39 != nil {
		return x.ref5029f39, nil
	}
	mem5029f39 := allocStructNkCommandRectFilledMemory(1)
	ref5029f39 := (*C.struct_nk_command_rect_filled)(mem5029f39)
	allocs5029f39 := new(cgoAllocMap)
	var cheader_allocs *cgoAllocMap
	ref5029f39.header, cheader_allocs = x.Header.PassValue()
	allocs5029f39.Borrow(cheader_allocs)

	var crounding_allocs *cgoAllocMap
	ref5029f39.rounding, crounding_allocs = (C.ushort)(x.Rounding), cgoAllocsUnknown
	allocs5029f39.Borrow(crounding_allocs)

	var cx_allocs *cgoAllocMap
	ref5029f39.x, cx_allocs = (C.short)(x.X), cgoAllocsUnknown
	allocs5029f39.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	ref5029f39.y, cy_allocs = (C.short)(x.Y), cgoAllocsUnknown
	allocs5029f39.Borrow(cy_allocs)

	var cw_allocs *cgoAllocMap
	ref5029f39.w, cw_allocs = (C.ushort)(x.W), cgoAllocsUnknown
	allocs5029f39.Borrow(cw_allocs)

	var ch_allocs *cgoAllocMap
	ref5029f39.h, ch_allocs = (C.ushort)(x.H), cgoAllocsUnknown
	allocs5029f39.Borrow(ch_allocs)

	var ccolor_allocs *cgoAllocMap
	ref5029f39.color, ccolor_allocs = x.Color.PassValue()
	allocs5029f39.Borrow(ccolor_allocs)

	x.ref5029f39 = ref5029f39
	x.allocs5029f39 = allocs5029f39
	return ref5029f39, allocs5029f39

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CommandRectFilled) PassValue() (C.struct_nk_command_rect_filled, *cgoAllocMap) {
	if x.ref5029f39 != nil {
		return *x.ref5029f39, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CommandRectFilled) Deref() {
	if x.ref5029f39 == nil {
		return
	}
	x.Header = *NewCommandRef(unsafe.Pointer(&x.ref5029f39.header))
	x.Rounding = (uint16)(x.ref5029f39.rounding)
	x.X = (int16)(x.ref5029f39.x)
	x.Y = (int16)(x.ref5029f39.y)
	x.W = (uint16)(x.ref5029f39.w)
	x.H = (uint16)(x.ref5029f39.h)
	x.Color = *NewColorRef(unsafe.Pointer(&x.ref5029f39.color))
}

// allocStructNkStyleSliderMemory allocates memory for type C.struct_nk_style_slider in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkStyleSliderMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkStyleSliderValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkStyleSliderValue = unsafe.Sizeof([1]C.struct_nk_style_slider{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *StyleSlider) Ref() *C.struct_nk_style_slider {
	if x == nil {
		return nil
	}
	return x.refd2203cf4
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *StyleSlider) Free() {
	if x != nil && x.allocsd2203cf4 != nil {
		x.allocsd2203cf4.(*cgoAllocMap).Free()
		x.refd2203cf4 = nil
	}
}

// NewStyleSliderRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewStyleSliderRef(ref unsafe.Pointer) *StyleSlider {
	if ref == nil {
		return nil
	}
	obj := new(StyleSlider)
	obj.refd2203cf4 = (*C.struct_nk_style_slider)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *StyleSlider) PassRef() (*C.struct_nk_style_slider, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd2203cf4 != nil {
		return x.refd2203cf4, nil
	}
	memd2203cf4 := allocStructNkStyleSliderMemory(1)
	refd2203cf4 := (*C.struct_nk_style_slider)(memd2203cf4)
	allocsd2203cf4 := new(cgoAllocMap)
	var cnormal_allocs *cgoAllocMap
	refd2203cf4.normal, cnormal_allocs = x.Normal.PassValue()
	allocsd2203cf4.Borrow(cnormal_allocs)

	var chover_allocs *cgoAllocMap
	refd2203cf4.hover, chover_allocs = x.Hover.PassValue()
	allocsd2203cf4.Borrow(chover_allocs)

	var cactive_allocs *cgoAllocMap
	refd2203cf4.active, cactive_allocs = x.Active.PassValue()
	allocsd2203cf4.Borrow(cactive_allocs)

	var cborder_color_allocs *cgoAllocMap
	refd2203cf4.border_color, cborder_color_allocs = x.BorderColor.PassValue()
	allocsd2203cf4.Borrow(cborder_color_allocs)

	var cbar_normal_allocs *cgoAllocMap
	refd2203cf4.bar_normal, cbar_normal_allocs = x.BarNormal.PassValue()
	allocsd2203cf4.Borrow(cbar_normal_allocs)

	var cbar_hover_allocs *cgoAllocMap
	refd2203cf4.bar_hover, cbar_hover_allocs = x.BarHover.PassValue()
	allocsd2203cf4.Borrow(cbar_hover_allocs)

	var cbar_active_allocs *cgoAllocMap
	refd2203cf4.bar_active, cbar_active_allocs = x.BarActive.PassValue()
	allocsd2203cf4.Borrow(cbar_active_allocs)

	var cbar_filled_allocs *cgoAllocMap
	refd2203cf4.bar_filled, cbar_filled_allocs = x.BarFilled.PassValue()
	allocsd2203cf4.Borrow(cbar_filled_allocs)

	var ccursor_normal_allocs *cgoAllocMap
	refd2203cf4.cursor_normal, ccursor_normal_allocs = x.CursorNormal.PassValue()
	allocsd2203cf4.Borrow(ccursor_normal_allocs)

	var ccursor_hover_allocs *cgoAllocMap
	refd2203cf4.cursor_hover, ccursor_hover_allocs = x.CursorHover.PassValue()
	allocsd2203cf4.Borrow(ccursor_hover_allocs)

	var ccursor_active_allocs *cgoAllocMap
	refd2203cf4.cursor_active, ccursor_active_allocs = x.CursorActive.PassValue()
	allocsd2203cf4.Borrow(ccursor_active_allocs)

	var cborder_allocs *cgoAllocMap
	refd2203cf4.border, cborder_allocs = (C.float)(x.Border), cgoAllocsUnknown
	allocsd2203cf4.Borrow(cborder_allocs)

	var crounding_allocs *cgoAllocMap
	refd2203cf4.rounding, crounding_allocs = (C.float)(x.Rounding), cgoAllocsUnknown
	allocsd2203cf4.Borrow(crounding_allocs)

	var cbar_height_allocs *cgoAllocMap
	refd2203cf4.bar_height, cbar_height_allocs = (C.float)(x.BarHeight), cgoAllocsUnknown
	allocsd2203cf4.Borrow(cbar_height_allocs)

	var cpadding_allocs *cgoAllocMap
	refd2203cf4.padding, cpadding_allocs = x.Padding.PassValue()
	allocsd2203cf4.Borrow(cpadding_allocs)

	var cspacing_allocs *cgoAllocMap
	refd2203cf4.spacing, cspacing_allocs = x.Spacing.PassValue()
	allocsd2203cf4.Borrow(cspacing_allocs)

	var ccursor_size_allocs *cgoAllocMap
	refd2203cf4.cursor_size, ccursor_size_allocs = x.CursorSize.PassValue()
	allocsd2203cf4.Borrow(ccursor_size_allocs)

	var cshow_buttons_allocs *cgoAllocMap
	refd2203cf4.show_buttons, cshow_buttons_allocs = (C.int)(x.ShowButtons), cgoAllocsUnknown
	allocsd2203cf4.Borrow(cshow_buttons_allocs)

	var cinc_button_allocs *cgoAllocMap
	refd2203cf4.inc_button, cinc_button_allocs = x.IncButton.PassValue()
	allocsd2203cf4.Borrow(cinc_button_allocs)

	var cdec_button_allocs *cgoAllocMap
	refd2203cf4.dec_button, cdec_button_allocs = x.DecButton.PassValue()
	allocsd2203cf4.Borrow(cdec_button_allocs)

	var cinc_symbol_allocs *cgoAllocMap
	refd2203cf4.inc_symbol, cinc_symbol_allocs = (C.enum_nk_symbol_type)(x.IncSymbol), cgoAllocsUnknown
	allocsd2203cf4.Borrow(cinc_symbol_allocs)

	var cdec_symbol_allocs *cgoAllocMap
	refd2203cf4.dec_symbol, cdec_symbol_allocs = (C.enum_nk_symbol_type)(x.DecSymbol), cgoAllocsUnknown
	allocsd2203cf4.Borrow(cdec_symbol_allocs)

	var cuserdata_allocs *cgoAllocMap
	refd2203cf4.userdata, cuserdata_allocs = *(*C.nk_handle)(unsafe.Pointer(&x.Userdata)), cgoAllocsUnknown
	allocsd2203cf4.Borrow(cuserdata_allocs)

	var cdraw_begin_allocs *cgoAllocMap
	refd2203cf4.draw_begin, cdraw_begin_allocs = (*[0]byte)(unsafe.Pointer(x.DrawBegin)), cgoAllocsUnknown
	allocsd2203cf4.Borrow(cdraw_begin_allocs)

	var cdraw_end_allocs *cgoAllocMap
	refd2203cf4.draw_end, cdraw_end_allocs = (*[0]byte)(unsafe.Pointer(x.DrawEnd)), cgoAllocsUnknown
	allocsd2203cf4.Borrow(cdraw_end_allocs)

	x.refd2203cf4 = refd2203cf4
	x.allocsd2203cf4 = allocsd2203cf4
	return refd2203cf4, allocsd2203cf4

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x StyleSlider) PassValue() (C.struct_nk_style_slider, *cgoAllocMap) {
	if x.refd2203cf4 != nil {
		return *x.refd2203cf4, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *StyleSlider) Deref() {
	if x.refd2203cf4 == nil {
		return
	}
	x.Normal = *NewStyleItemRef(unsafe.Pointer(&x.refd2203cf4.normal))
	x.Hover = *NewStyleItemRef(unsafe.Pointer(&x.refd2203cf4.hover))
	x.Active = *NewStyleItemRef(unsafe.Pointer(&x.refd2203cf4.active))
	x.BorderColor = *NewColorRef(unsafe.Pointer(&x.refd2203cf4.border_color))
	x.BarNormal = *NewColorRef(unsafe.Pointer(&x.refd2203cf4.bar_normal))
	x.BarHover = *NewColorRef(unsafe.Pointer(&x.refd2203cf4.bar_hover))
	x.BarActive = *NewColorRef(unsafe.Pointer(&x.refd2203cf4.bar_active))
	x.BarFilled = *NewColorRef(unsafe.Pointer(&x.refd2203cf4.bar_filled))
	x.CursorNormal = *NewStyleItemRef(unsafe.Pointer(&x.refd2203cf4.cursor_normal))
	x.CursorHover = *NewStyleItemRef(unsafe.Pointer(&x.refd2203cf4.cursor_hover))
	x.CursorActive = *NewStyleItemRef(unsafe.Pointer(&x.refd2203cf4.cursor_active))
	x.Border = (float32)(x.refd2203cf4.border)
	x.Rounding = (float32)(x.refd2203cf4.rounding)
	x.BarHeight = (float32)(x.refd2203cf4.bar_height)
	x.Padding = *NewVec2Ref(unsafe.Pointer(&x.refd2203cf4.padding))
	x.Spacing = *NewVec2Ref(unsafe.Pointer(&x.refd2203cf4.spacing))
	x.CursorSize = *NewVec2Ref(unsafe.Pointer(&x.refd2203cf4.cursor_size))
	x.ShowButtons = (int32)(x.refd2203cf4.show_buttons)
	x.IncButton = *NewStyleButtonRef(unsafe.Pointer(&x.refd2203cf4.inc_button))
	x.DecButton = *NewStyleButtonRef(unsafe.Pointer(&x.refd2203cf4.dec_button))
	x.IncSymbol = (SymbolType)(x.refd2203cf4.inc_symbol)
	x.DecSymbol = (SymbolType)(x.refd2203cf4.dec_symbol)
	x.Userdata = *(*Handle)(unsafe.Pointer(&x.refd2203cf4.userdata))
	// x.DrawBegin is a callback func
	// x.DrawEnd is a callback func
}

// allocStructNkStyleSelectableMemory allocates memory for type C.struct_nk_style_selectable in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkStyleSelectableMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkStyleSelectableValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkStyleSelectableValue = unsafe.Sizeof([1]C.struct_nk_style_selectable{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *StyleSelectable) Ref() *C.struct_nk_style_selectable {
	if x == nil {
		return nil
	}
	return x.refdf1c4e20
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *StyleSelectable) Free() {
	if x != nil && x.allocsdf1c4e20 != nil {
		x.allocsdf1c4e20.(*cgoAllocMap).Free()
		x.refdf1c4e20 = nil
	}
}

// NewStyleSelectableRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewStyleSelectableRef(ref unsafe.Pointer) *StyleSelectable {
	if ref == nil {
		return nil
	}
	obj := new(StyleSelectable)
	obj.refdf1c4e20 = (*C.struct_nk_style_selectable)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *StyleSelectable) PassRef() (*C.struct_nk_style_selectable, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refdf1c4e20 != nil {
		return x.refdf1c4e20, nil
	}
	memdf1c4e20 := allocStructNkStyleSelectableMemory(1)
	refdf1c4e20 := (*C.struct_nk_style_selectable)(memdf1c4e20)
	allocsdf1c4e20 := new(cgoAllocMap)
	var cnormal_allocs *cgoAllocMap
	refdf1c4e20.normal, cnormal_allocs = x.Normal.PassValue()
	allocsdf1c4e20.Borrow(cnormal_allocs)

	var chover_allocs *cgoAllocMap
	refdf1c4e20.hover, chover_allocs = x.Hover.PassValue()
	allocsdf1c4e20.Borrow(chover_allocs)

	var cpressed_allocs *cgoAllocMap
	refdf1c4e20.pressed, cpressed_allocs = x.Pressed.PassValue()
	allocsdf1c4e20.Borrow(cpressed_allocs)

	var cnormal_active_allocs *cgoAllocMap
	refdf1c4e20.normal_active, cnormal_active_allocs = x.NormalActive.PassValue()
	allocsdf1c4e20.Borrow(cnormal_active_allocs)

	var chover_active_allocs *cgoAllocMap
	refdf1c4e20.hover_active, chover_active_allocs = x.HoverActive.PassValue()
	allocsdf1c4e20.Borrow(chover_active_allocs)

	var cpressed_active_allocs *cgoAllocMap
	refdf1c4e20.pressed_active, cpressed_active_allocs = x.PressedActive.PassValue()
	allocsdf1c4e20.Borrow(cpressed_active_allocs)

	var ctext_normal_allocs *cgoAllocMap
	refdf1c4e20.text_normal, ctext_normal_allocs = x.TextNormal.PassValue()
	allocsdf1c4e20.Borrow(ctext_normal_allocs)

	var ctext_hover_allocs *cgoAllocMap
	refdf1c4e20.text_hover, ctext_hover_allocs = x.TextHover.PassValue()
	allocsdf1c4e20.Borrow(ctext_hover_allocs)

	var ctext_pressed_allocs *cgoAllocMap
	refdf1c4e20.text_pressed, ctext_pressed_allocs = x.TextPressed.PassValue()
	allocsdf1c4e20.Borrow(ctext_pressed_allocs)

	var ctext_normal_active_allocs *cgoAllocMap
	refdf1c4e20.text_normal_active, ctext_normal_active_allocs = x.TextNormalActive.PassValue()
	allocsdf1c4e20.Borrow(ctext_normal_active_allocs)

	var ctext_hover_active_allocs *cgoAllocMap
	refdf1c4e20.text_hover_active, ctext_hover_active_allocs = x.TextHoverActive.PassValue()
	allocsdf1c4e20.Borrow(ctext_hover_active_allocs)

	var ctext_pressed_active_allocs *cgoAllocMap
	refdf1c4e20.text_pressed_active, ctext_pressed_active_allocs = x.TextPressedActive.PassValue()
	allocsdf1c4e20.Borrow(ctext_pressed_active_allocs)

	var ctext_background_allocs *cgoAllocMap
	refdf1c4e20.text_background, ctext_background_allocs = x.TextBackground.PassValue()
	allocsdf1c4e20.Borrow(ctext_background_allocs)

	var ctext_alignment_allocs *cgoAllocMap
	refdf1c4e20.text_alignment, ctext_alignment_allocs = (C.nk_flags)(x.TextAlignment), cgoAllocsUnknown
	allocsdf1c4e20.Borrow(ctext_alignment_allocs)

	var crounding_allocs *cgoAllocMap
	refdf1c4e20.rounding, crounding_allocs = (C.float)(x.Rounding), cgoAllocsUnknown
	allocsdf1c4e20.Borrow(crounding_allocs)

	var cpadding_allocs *cgoAllocMap
	refdf1c4e20.padding, cpadding_allocs = x.Padding.PassValue()
	allocsdf1c4e20.Borrow(cpadding_allocs)

	var ctouch_padding_allocs *cgoAllocMap
	refdf1c4e20.touch_padding, ctouch_padding_allocs = x.TouchPadding.PassValue()
	allocsdf1c4e20.Borrow(ctouch_padding_allocs)

	var cimage_padding_allocs *cgoAllocMap
	refdf1c4e20.image_padding, cimage_padding_allocs = x.ImagePadding.PassValue()
	allocsdf1c4e20.Borrow(cimage_padding_allocs)

	var cuserdata_allocs *cgoAllocMap
	refdf1c4e20.userdata, cuserdata_allocs = *(*C.nk_handle)(unsafe.Pointer(&x.Userdata)), cgoAllocsUnknown
	allocsdf1c4e20.Borrow(cuserdata_allocs)

	var cdraw_begin_allocs *cgoAllocMap
	refdf1c4e20.draw_begin, cdraw_begin_allocs = (*[0]byte)(unsafe.Pointer(x.DrawBegin)), cgoAllocsUnknown
	allocsdf1c4e20.Borrow(cdraw_begin_allocs)

	var cdraw_end_allocs *cgoAllocMap
	refdf1c4e20.draw_end, cdraw_end_allocs = (*[0]byte)(unsafe.Pointer(x.DrawEnd)), cgoAllocsUnknown
	allocsdf1c4e20.Borrow(cdraw_end_allocs)

	x.refdf1c4e20 = refdf1c4e20
	x.allocsdf1c4e20 = allocsdf1c4e20
	return refdf1c4e20, allocsdf1c4e20

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x StyleSelectable) PassValue() (C.struct_nk_style_selectable, *cgoAllocMap) {
	if x.refdf1c4e20 != nil {
		return *x.refdf1c4e20, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *StyleSelectable) Deref() {
	if x.refdf1c4e20 == nil {
		return
	}
	x.Normal = *NewStyleItemRef(unsafe.Pointer(&x.refdf1c4e20.normal))
	x.Hover = *NewStyleItemRef(unsafe.Pointer(&x.refdf1c4e20.hover))
	x.Pressed = *NewStyleItemRef(unsafe.Pointer(&x.refdf1c4e20.pressed))
	x.NormalActive = *NewStyleItemRef(unsafe.Pointer(&x.refdf1c4e20.normal_active))
	x.HoverActive = *NewStyleItemRef(unsafe.Pointer(&x.refdf1c4e20.hover_active))
	x.PressedActive = *NewStyleItemRef(unsafe.Pointer(&x.refdf1c4e20.pressed_active))
	x.TextNormal = *NewColorRef(unsafe.Pointer(&x.refdf1c4e20.text_normal))
	x.TextHover = *NewColorRef(unsafe.Pointer(&x.refdf1c4e20.text_hover))
	x.TextPressed = *NewColorRef(unsafe.Pointer(&x.refdf1c4e20.text_pressed))
	x.TextNormalActive = *NewColorRef(unsafe.Pointer(&x.refdf1c4e20.text_normal_active))
	x.TextHoverActive = *NewColorRef(unsafe.Pointer(&x.refdf1c4e20.text_hover_active))
	x.TextPressedActive = *NewColorRef(unsafe.Pointer(&x.refdf1c4e20.text_pressed_active))
	x.TextBackground = *NewColorRef(unsafe.Pointer(&x.refdf1c4e20.text_background))
	x.TextAlignment = (Flags)(x.refdf1c4e20.text_alignment)
	x.Rounding = (float32)(x.refdf1c4e20.rounding)
	x.Padding = *NewVec2Ref(unsafe.Pointer(&x.refdf1c4e20.padding))
	x.TouchPadding = *NewVec2Ref(unsafe.Pointer(&x.refdf1c4e20.touch_padding))
	x.ImagePadding = *NewVec2Ref(unsafe.Pointer(&x.refdf1c4e20.image_padding))
	x.Userdata = *(*Handle)(unsafe.Pointer(&x.refdf1c4e20.userdata))
	// x.DrawBegin is a callback func
	// x.DrawEnd is a callback func
}

// allocStructNkBufferMarkerMemory allocates memory for type C.struct_nk_buffer_marker in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkBufferMarkerMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkBufferMarkerValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkBufferMarkerValue = unsafe.Sizeof([1]C.struct_nk_buffer_marker{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BufferMarker) Ref() *C.struct_nk_buffer_marker {
	if x == nil {
		return nil
	}
	return x.refe53e6784
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BufferMarker) Free() {
	if x != nil && x.allocse53e6784 != nil {
		x.allocse53e6784.(*cgoAllocMap).Free()
		x.refe53e6784 = nil
	}
}

// NewBufferMarkerRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBufferMarkerRef(ref unsafe.Pointer) *BufferMarker {
	if ref == nil {
		return nil
	}
	obj := new(BufferMarker)
	obj.refe53e6784 = (*C.struct_nk_buffer_marker)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BufferMarker) PassRef() (*C.struct_nk_buffer_marker, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe53e6784 != nil {
		return x.refe53e6784, nil
	}
	meme53e6784 := allocStructNkBufferMarkerMemory(1)
	refe53e6784 := (*C.struct_nk_buffer_marker)(meme53e6784)
	allocse53e6784 := new(cgoAllocMap)
	var cactive_allocs *cgoAllocMap
	refe53e6784.active, cactive_allocs = (C.int)(x.Active), cgoAllocsUnknown
	allocse53e6784.Borrow(cactive_allocs)

	var coffset_allocs *cgoAllocMap
	refe53e6784.offset, coffset_allocs = (C.nk_size)(x.Offset), cgoAllocsUnknown
	allocse53e6784.Borrow(coffset_allocs)

	x.refe53e6784 = refe53e6784
	x.allocse53e6784 = allocse53e6784
	return refe53e6784, allocse53e6784

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BufferMarker) PassValue() (C.struct_nk_buffer_marker, *cgoAllocMap) {
	if x.refe53e6784 != nil {
		return *x.refe53e6784, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BufferMarker) Deref() {
	if x.refe53e6784 == nil {
		return
	}
	x.Active = (int32)(x.refe53e6784.active)
	x.Offset = (Size)(x.refe53e6784.offset)
}

// allocA1StructNkPageElementMemory allocates memory for type [1]C.struct_nk_page_element in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA1StructNkPageElementMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfA1StructNkPageElementValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfA1StructNkPageElementValue = unsafe.Sizeof([1][1]C.struct_nk_page_element{})

// unpackA1PageElement transforms a sliced Go data structure into plain C format.
func unpackA1PageElement(x [1]PageElement) (unpacked [1]C.struct_nk_page_element, allocs *cgoAllocMap) {
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(*[1]C.struct_nk_page_element) {
		go allocs.Free()
	})

	mem0 := allocA1StructNkPageElementMemory(1)
	allocs.Add(mem0)
	v0 := (*[1]C.struct_nk_page_element)(mem0)
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	unpacked = *(*[1]C.struct_nk_page_element)(mem0)
	return
}

// packA1PageElement reads sliced Go data structure out from plain C format.
func packA1PageElement(v *[1]PageElement, ptr0 *[1]C.struct_nk_page_element) {
	for i0 := range v {
		ptr1 := ptr0[i0]
		v[i0] = *NewPageElementRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Page) Ref() *C.struct_nk_page {
	if x == nil {
		return nil
	}
	return x.ref22a2ae6a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Page) Free() {
	if x != nil && x.allocs22a2ae6a != nil {
		x.allocs22a2ae6a.(*cgoAllocMap).Free()
		x.ref22a2ae6a = nil
	}
}

// NewPageRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPageRef(ref unsafe.Pointer) *Page {
	if ref == nil {
		return nil
	}
	obj := new(Page)
	obj.ref22a2ae6a = (*C.struct_nk_page)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Page) PassRef() (*C.struct_nk_page, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref22a2ae6a != nil {
		return x.ref22a2ae6a, nil
	}
	mem22a2ae6a := allocStructNkPageMemory(1)
	ref22a2ae6a := (*C.struct_nk_page)(mem22a2ae6a)
	allocs22a2ae6a := new(cgoAllocMap)
	var csize_allocs *cgoAllocMap
	ref22a2ae6a.size, csize_allocs = (C.uint)(x.Size), cgoAllocsUnknown
	allocs22a2ae6a.Borrow(csize_allocs)

	var cnext_allocs *cgoAllocMap
	ref22a2ae6a.next, cnext_allocs = unpackSPage(x.Next)
	allocs22a2ae6a.Borrow(cnext_allocs)

	var cwin_allocs *cgoAllocMap
	ref22a2ae6a.win, cwin_allocs = unpackA1PageElement(x.Win)
	allocs22a2ae6a.Borrow(cwin_allocs)

	x.ref22a2ae6a = ref22a2ae6a
	x.allocs22a2ae6a = allocs22a2ae6a
	return ref22a2ae6a, allocs22a2ae6a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Page) PassValue() (C.struct_nk_page, *cgoAllocMap) {
	if x.ref22a2ae6a != nil {
		return *x.ref22a2ae6a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Page) Deref() {
	if x.ref22a2ae6a == nil {
		return
	}
	x.Size = (uint32)(x.ref22a2ae6a.size)
	packSPage(x.Next, x.ref22a2ae6a.next)
	packA1PageElement(&x.Win, (*[1]C.struct_nk_page_element)(unsafe.Pointer(&x.ref22a2ae6a.win)))
}

// allocStructNkConfigStackVec2ElementMemory allocates memory for type C.struct_nk_config_stack_vec2_element in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkConfigStackVec2ElementMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkConfigStackVec2ElementValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkConfigStackVec2ElementValue = unsafe.Sizeof([1]C.struct_nk_config_stack_vec2_element{})

// unpackSVec2 transforms a sliced Go data structure into plain C format.
func unpackSVec2(x []Vec2) (unpacked *C.struct_nk_vec2, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.struct_nk_vec2) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocStructNkVec2Memory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_nk_vec2)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_nk_vec2)(unsafe.Pointer(h.Data))
	return
}

// packSVec2 reads sliced Go data structure out from plain C format.
func packSVec2(v []Vec2, ptr0 *C.struct_nk_vec2) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStructNkVec2Value]C.struct_nk_vec2)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewVec2Ref(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ConfigStackVec2Element) Ref() *C.struct_nk_config_stack_vec2_element {
	if x == nil {
		return nil
	}
	return x.ref215f67d3
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ConfigStackVec2Element) Free() {
	if x != nil && x.allocs215f67d3 != nil {
		x.allocs215f67d3.(*cgoAllocMap).Free()
		x.ref215f67d3 = nil
	}
}

// NewConfigStackVec2ElementRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewConfigStackVec2ElementRef(ref unsafe.Pointer) *ConfigStackVec2Element {
	if ref == nil {
		return nil
	}
	obj := new(ConfigStackVec2Element)
	obj.ref215f67d3 = (*C.struct_nk_config_stack_vec2_element)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ConfigStackVec2Element) PassRef() (*C.struct_nk_config_stack_vec2_element, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref215f67d3 != nil {
		return x.ref215f67d3, nil
	}
	mem215f67d3 := allocStructNkConfigStackVec2ElementMemory(1)
	ref215f67d3 := (*C.struct_nk_config_stack_vec2_element)(mem215f67d3)
	allocs215f67d3 := new(cgoAllocMap)
	var caddress_allocs *cgoAllocMap
	ref215f67d3.address, caddress_allocs = unpackSVec2(x.Address)
	allocs215f67d3.Borrow(caddress_allocs)

	var cold_value_allocs *cgoAllocMap
	ref215f67d3.old_value, cold_value_allocs = x.OldValue.PassValue()
	allocs215f67d3.Borrow(cold_value_allocs)

	x.ref215f67d3 = ref215f67d3
	x.allocs215f67d3 = allocs215f67d3
	return ref215f67d3, allocs215f67d3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ConfigStackVec2Element) PassValue() (C.struct_nk_config_stack_vec2_element, *cgoAllocMap) {
	if x.ref215f67d3 != nil {
		return *x.ref215f67d3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ConfigStackVec2Element) Deref() {
	if x.ref215f67d3 == nil {
		return
	}
	packSVec2(x.Address, x.ref215f67d3.address)
	x.OldValue = *NewVec2Ref(unsafe.Pointer(&x.ref215f67d3.old_value))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Cursor) Ref() *C.struct_nk_cursor {
	if x == nil {
		return nil
	}
	return x.refdc8563ff
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Cursor) Free() {
	if x != nil && x.allocsdc8563ff != nil {
		x.allocsdc8563ff.(*cgoAllocMap).Free()
		x.refdc8563ff = nil
	}
}

// NewCursorRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCursorRef(ref unsafe.Pointer) *Cursor {
	if ref == nil {
		return nil
	}
	obj := new(Cursor)
	obj.refdc8563ff = (*C.struct_nk_cursor)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Cursor) PassRef() (*C.struct_nk_cursor, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refdc8563ff != nil {
		return x.refdc8563ff, nil
	}
	memdc8563ff := allocStructNkCursorMemory(1)
	refdc8563ff := (*C.struct_nk_cursor)(memdc8563ff)
	allocsdc8563ff := new(cgoAllocMap)
	var cimg_allocs *cgoAllocMap
	refdc8563ff.img, cimg_allocs = x.Img.PassValue()
	allocsdc8563ff.Borrow(cimg_allocs)

	var csize_allocs *cgoAllocMap
	refdc8563ff.size, csize_allocs = x.Size.PassValue()
	allocsdc8563ff.Borrow(csize_allocs)

	var coffset_allocs *cgoAllocMap
	refdc8563ff.offset, coffset_allocs = x.Offset.PassValue()
	allocsdc8563ff.Borrow(coffset_allocs)

	x.refdc8563ff = refdc8563ff
	x.allocsdc8563ff = allocsdc8563ff
	return refdc8563ff, allocsdc8563ff

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Cursor) PassValue() (C.struct_nk_cursor, *cgoAllocMap) {
	if x.refdc8563ff != nil {
		return *x.refdc8563ff, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Cursor) Deref() {
	if x.refdc8563ff == nil {
		return
	}
	x.Img = *NewImageRef(unsafe.Pointer(&x.refdc8563ff.img))
	x.Size = *NewVec2Ref(unsafe.Pointer(&x.refdc8563ff.size))
	x.Offset = *NewVec2Ref(unsafe.Pointer(&x.refdc8563ff.offset))
}

// allocStructNkStyleScrollbarMemory allocates memory for type C.struct_nk_style_scrollbar in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkStyleScrollbarMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkStyleScrollbarValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkStyleScrollbarValue = unsafe.Sizeof([1]C.struct_nk_style_scrollbar{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *StyleScrollbar) Ref() *C.struct_nk_style_scrollbar {
	if x == nil {
		return nil
	}
	return x.refe74766c5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *StyleScrollbar) Free() {
	if x != nil && x.allocse74766c5 != nil {
		x.allocse74766c5.(*cgoAllocMap).Free()
		x.refe74766c5 = nil
	}
}

// NewStyleScrollbarRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewStyleScrollbarRef(ref unsafe.Pointer) *StyleScrollbar {
	if ref == nil {
		return nil
	}
	obj := new(StyleScrollbar)
	obj.refe74766c5 = (*C.struct_nk_style_scrollbar)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *StyleScrollbar) PassRef() (*C.struct_nk_style_scrollbar, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe74766c5 != nil {
		return x.refe74766c5, nil
	}
	meme74766c5 := allocStructNkStyleScrollbarMemory(1)
	refe74766c5 := (*C.struct_nk_style_scrollbar)(meme74766c5)
	allocse74766c5 := new(cgoAllocMap)
	var cnormal_allocs *cgoAllocMap
	refe74766c5.normal, cnormal_allocs = x.Normal.PassValue()
	allocse74766c5.Borrow(cnormal_allocs)

	var chover_allocs *cgoAllocMap
	refe74766c5.hover, chover_allocs = x.Hover.PassValue()
	allocse74766c5.Borrow(chover_allocs)

	var cactive_allocs *cgoAllocMap
	refe74766c5.active, cactive_allocs = x.Active.PassValue()
	allocse74766c5.Borrow(cactive_allocs)

	var cborder_color_allocs *cgoAllocMap
	refe74766c5.border_color, cborder_color_allocs = x.BorderColor.PassValue()
	allocse74766c5.Borrow(cborder_color_allocs)

	var ccursor_normal_allocs *cgoAllocMap
	refe74766c5.cursor_normal, ccursor_normal_allocs = x.CursorNormal.PassValue()
	allocse74766c5.Borrow(ccursor_normal_allocs)

	var ccursor_hover_allocs *cgoAllocMap
	refe74766c5.cursor_hover, ccursor_hover_allocs = x.CursorHover.PassValue()
	allocse74766c5.Borrow(ccursor_hover_allocs)

	var ccursor_active_allocs *cgoAllocMap
	refe74766c5.cursor_active, ccursor_active_allocs = x.CursorActive.PassValue()
	allocse74766c5.Borrow(ccursor_active_allocs)

	var ccursor_border_color_allocs *cgoAllocMap
	refe74766c5.cursor_border_color, ccursor_border_color_allocs = x.CursorBorderColor.PassValue()
	allocse74766c5.Borrow(ccursor_border_color_allocs)

	var cborder_allocs *cgoAllocMap
	refe74766c5.border, cborder_allocs = (C.float)(x.Border), cgoAllocsUnknown
	allocse74766c5.Borrow(cborder_allocs)

	var crounding_allocs *cgoAllocMap
	refe74766c5.rounding, crounding_allocs = (C.float)(x.Rounding), cgoAllocsUnknown
	allocse74766c5.Borrow(crounding_allocs)

	var cborder_cursor_allocs *cgoAllocMap
	refe74766c5.border_cursor, cborder_cursor_allocs = (C.float)(x.BorderCursor), cgoAllocsUnknown
	allocse74766c5.Borrow(cborder_cursor_allocs)

	var crounding_cursor_allocs *cgoAllocMap
	refe74766c5.rounding_cursor, crounding_cursor_allocs = (C.float)(x.RoundingCursor), cgoAllocsUnknown
	allocse74766c5.Borrow(crounding_cursor_allocs)

	var cpadding_allocs *cgoAllocMap
	refe74766c5.padding, cpadding_allocs = x.Padding.PassValue()
	allocse74766c5.Borrow(cpadding_allocs)

	var cshow_buttons_allocs *cgoAllocMap
	refe74766c5.show_buttons, cshow_buttons_allocs = (C.int)(x.ShowButtons), cgoAllocsUnknown
	allocse74766c5.Borrow(cshow_buttons_allocs)

	var cinc_button_allocs *cgoAllocMap
	refe74766c5.inc_button, cinc_button_allocs = x.IncButton.PassValue()
	allocse74766c5.Borrow(cinc_button_allocs)

	var cdec_button_allocs *cgoAllocMap
	refe74766c5.dec_button, cdec_button_allocs = x.DecButton.PassValue()
	allocse74766c5.Borrow(cdec_button_allocs)

	var cinc_symbol_allocs *cgoAllocMap
	refe74766c5.inc_symbol, cinc_symbol_allocs = (C.enum_nk_symbol_type)(x.IncSymbol), cgoAllocsUnknown
	allocse74766c5.Borrow(cinc_symbol_allocs)

	var cdec_symbol_allocs *cgoAllocMap
	refe74766c5.dec_symbol, cdec_symbol_allocs = (C.enum_nk_symbol_type)(x.DecSymbol), cgoAllocsUnknown
	allocse74766c5.Borrow(cdec_symbol_allocs)

	var cuserdata_allocs *cgoAllocMap
	refe74766c5.userdata, cuserdata_allocs = *(*C.nk_handle)(unsafe.Pointer(&x.Userdata)), cgoAllocsUnknown
	allocse74766c5.Borrow(cuserdata_allocs)

	var cdraw_begin_allocs *cgoAllocMap
	refe74766c5.draw_begin, cdraw_begin_allocs = (*[0]byte)(unsafe.Pointer(x.DrawBegin)), cgoAllocsUnknown
	allocse74766c5.Borrow(cdraw_begin_allocs)

	var cdraw_end_allocs *cgoAllocMap
	refe74766c5.draw_end, cdraw_end_allocs = (*[0]byte)(unsafe.Pointer(x.DrawEnd)), cgoAllocsUnknown
	allocse74766c5.Borrow(cdraw_end_allocs)

	x.refe74766c5 = refe74766c5
	x.allocse74766c5 = allocse74766c5
	return refe74766c5, allocse74766c5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x StyleScrollbar) PassValue() (C.struct_nk_style_scrollbar, *cgoAllocMap) {
	if x.refe74766c5 != nil {
		return *x.refe74766c5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *StyleScrollbar) Deref() {
	if x.refe74766c5 == nil {
		return
	}
	x.Normal = *NewStyleItemRef(unsafe.Pointer(&x.refe74766c5.normal))
	x.Hover = *NewStyleItemRef(unsafe.Pointer(&x.refe74766c5.hover))
	x.Active = *NewStyleItemRef(unsafe.Pointer(&x.refe74766c5.active))
	x.BorderColor = *NewColorRef(unsafe.Pointer(&x.refe74766c5.border_color))
	x.CursorNormal = *NewStyleItemRef(unsafe.Pointer(&x.refe74766c5.cursor_normal))
	x.CursorHover = *NewStyleItemRef(unsafe.Pointer(&x.refe74766c5.cursor_hover))
	x.CursorActive = *NewStyleItemRef(unsafe.Pointer(&x.refe74766c5.cursor_active))
	x.CursorBorderColor = *NewColorRef(unsafe.Pointer(&x.refe74766c5.cursor_border_color))
	x.Border = (float32)(x.refe74766c5.border)
	x.Rounding = (float32)(x.refe74766c5.rounding)
	x.BorderCursor = (float32)(x.refe74766c5.border_cursor)
	x.RoundingCursor = (float32)(x.refe74766c5.rounding_cursor)
	x.Padding = *NewVec2Ref(unsafe.Pointer(&x.refe74766c5.padding))
	x.ShowButtons = (int32)(x.refe74766c5.show_buttons)
	x.IncButton = *NewStyleButtonRef(unsafe.Pointer(&x.refe74766c5.inc_button))
	x.DecButton = *NewStyleButtonRef(unsafe.Pointer(&x.refe74766c5.dec_button))
	x.IncSymbol = (SymbolType)(x.refe74766c5.inc_symbol)
	x.DecSymbol = (SymbolType)(x.refe74766c5.dec_symbol)
	x.Userdata = *(*Handle)(unsafe.Pointer(&x.refe74766c5.userdata))
	// x.DrawBegin is a callback func
	// x.DrawEnd is a callback func
}

// allocStructNkWindowMemory allocates memory for type C.struct_nk_window in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkWindowMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkWindowValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkWindowValue = unsafe.Sizeof([1]C.struct_nk_window{})

// unpackSWindow transforms a sliced Go data structure into plain C format.
func unpackSWindow(x []Window) (unpacked *C.struct_nk_window, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.struct_nk_window) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocStructNkWindowMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_nk_window)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_nk_window)(unsafe.Pointer(h.Data))
	return
}

// packSWindow reads sliced Go data structure out from plain C format.
func packSWindow(v []Window, ptr0 *C.struct_nk_window) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStructNkWindowValue]C.struct_nk_window)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewWindowRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Window) Ref() *C.struct_nk_window {
	if x == nil {
		return nil
	}
	return x.ref921ef0ac
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Window) Free() {
	if x != nil && x.allocs921ef0ac != nil {
		x.allocs921ef0ac.(*cgoAllocMap).Free()
		x.ref921ef0ac = nil
	}
}

// NewWindowRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewWindowRef(ref unsafe.Pointer) *Window {
	if ref == nil {
		return nil
	}
	obj := new(Window)
	obj.ref921ef0ac = (*C.struct_nk_window)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Window) PassRef() (*C.struct_nk_window, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref921ef0ac != nil {
		return x.ref921ef0ac, nil
	}
	mem921ef0ac := allocStructNkWindowMemory(1)
	ref921ef0ac := (*C.struct_nk_window)(mem921ef0ac)
	allocs921ef0ac := new(cgoAllocMap)
	var cseq_allocs *cgoAllocMap
	ref921ef0ac.seq, cseq_allocs = (C.uint)(x.Seq), cgoAllocsUnknown
	allocs921ef0ac.Borrow(cseq_allocs)

	var cname_allocs *cgoAllocMap
	ref921ef0ac.name, cname_allocs = (C.nk_hash)(x.Name), cgoAllocsUnknown
	allocs921ef0ac.Borrow(cname_allocs)

	var cname_string_allocs *cgoAllocMap
	ref921ef0ac.name_string, cname_string_allocs = *(*[64]C.char)(unsafe.Pointer(&x.NameString)), cgoAllocsUnknown
	allocs921ef0ac.Borrow(cname_string_allocs)

	var cflags_allocs *cgoAllocMap
	ref921ef0ac.flags, cflags_allocs = (C.nk_flags)(x.Flags), cgoAllocsUnknown
	allocs921ef0ac.Borrow(cflags_allocs)

	var cbounds_allocs *cgoAllocMap
	ref921ef0ac.bounds, cbounds_allocs = x.Bounds.PassValue()
	allocs921ef0ac.Borrow(cbounds_allocs)

	var cscrollbar_allocs *cgoAllocMap
	ref921ef0ac.scrollbar, cscrollbar_allocs = x.Scrollbar.PassValue()
	allocs921ef0ac.Borrow(cscrollbar_allocs)

	var cbuffer_allocs *cgoAllocMap
	ref921ef0ac.buffer, cbuffer_allocs = x.Buffer.PassValue()
	allocs921ef0ac.Borrow(cbuffer_allocs)

	var clayout_allocs *cgoAllocMap
	ref921ef0ac.layout, clayout_allocs = unpackSPanel(x.Layout)
	allocs921ef0ac.Borrow(clayout_allocs)

	var cscrollbar_hiding_timer_allocs *cgoAllocMap
	ref921ef0ac.scrollbar_hiding_timer, cscrollbar_hiding_timer_allocs = (C.float)(x.ScrollbarHidingTimer), cgoAllocsUnknown
	allocs921ef0ac.Borrow(cscrollbar_hiding_timer_allocs)

	var cproperty_allocs *cgoAllocMap
	ref921ef0ac.property, cproperty_allocs = x.Property.PassValue()
	allocs921ef0ac.Borrow(cproperty_allocs)

	var cpopup_allocs *cgoAllocMap
	ref921ef0ac.popup, cpopup_allocs = x.Popup.PassValue()
	allocs921ef0ac.Borrow(cpopup_allocs)

	var cedit_allocs *cgoAllocMap
	ref921ef0ac.edit, cedit_allocs = x.Edit.PassValue()
	allocs921ef0ac.Borrow(cedit_allocs)

	var cscrolled_allocs *cgoAllocMap
	ref921ef0ac.scrolled, cscrolled_allocs = (C.uint)(x.Scrolled), cgoAllocsUnknown
	allocs921ef0ac.Borrow(cscrolled_allocs)

	var ctables_allocs *cgoAllocMap
	ref921ef0ac.tables, ctables_allocs = unpackSTable(x.Tables)
	allocs921ef0ac.Borrow(ctables_allocs)

	var ctable_count_allocs *cgoAllocMap
	ref921ef0ac.table_count, ctable_count_allocs = (C.ushort)(x.TableCount), cgoAllocsUnknown
	allocs921ef0ac.Borrow(ctable_count_allocs)

	var ctable_size_allocs *cgoAllocMap
	ref921ef0ac.table_size, ctable_size_allocs = (C.ushort)(x.TableSize), cgoAllocsUnknown
	allocs921ef0ac.Borrow(ctable_size_allocs)

	var cnext_allocs *cgoAllocMap
	ref921ef0ac.next, cnext_allocs = unpackSWindow(x.Next)
	allocs921ef0ac.Borrow(cnext_allocs)

	var cprev_allocs *cgoAllocMap
	ref921ef0ac.prev, cprev_allocs = unpackSWindow(x.Prev)
	allocs921ef0ac.Borrow(cprev_allocs)

	var cparent_allocs *cgoAllocMap
	ref921ef0ac.parent, cparent_allocs = unpackSWindow(x.Parent)
	allocs921ef0ac.Borrow(cparent_allocs)

	x.ref921ef0ac = ref921ef0ac
	x.allocs921ef0ac = allocs921ef0ac
	return ref921ef0ac, allocs921ef0ac

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Window) PassValue() (C.struct_nk_window, *cgoAllocMap) {
	if x.ref921ef0ac != nil {
		return *x.ref921ef0ac, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Window) Deref() {
	if x.ref921ef0ac == nil {
		return
	}
	x.Seq = (uint32)(x.ref921ef0ac.seq)
	x.Name = (Hash)(x.ref921ef0ac.name)
	x.NameString = *(*[64]byte)(unsafe.Pointer(&x.ref921ef0ac.name_string))
	x.Flags = (Flags)(x.ref921ef0ac.flags)
	x.Bounds = *NewRectRef(unsafe.Pointer(&x.ref921ef0ac.bounds))
	x.Scrollbar = *NewScrollRef(unsafe.Pointer(&x.ref921ef0ac.scrollbar))
	x.Buffer = *NewCommandBufferRef(unsafe.Pointer(&x.ref921ef0ac.buffer))
	packSPanel(x.Layout, x.ref921ef0ac.layout)
	x.ScrollbarHidingTimer = (float32)(x.ref921ef0ac.scrollbar_hiding_timer)
	x.Property = *NewPropertyStateRef(unsafe.Pointer(&x.ref921ef0ac.property))
	x.Popup = *NewPopupStateRef(unsafe.Pointer(&x.ref921ef0ac.popup))
	x.Edit = *NewEditStateRef(unsafe.Pointer(&x.ref921ef0ac.edit))
	x.Scrolled = (uint32)(x.ref921ef0ac.scrolled)
	packSTable(x.Tables, x.ref921ef0ac.tables)
	x.TableCount = (uint16)(x.ref921ef0ac.table_count)
	x.TableSize = (uint16)(x.ref921ef0ac.table_size)
	packSWindow(x.Next, x.ref921ef0ac.next)
	packSWindow(x.Prev, x.ref921ef0ac.prev)
	packSWindow(x.Parent, x.ref921ef0ac.parent)
}

// allocStructNkCommandTriangleFilledMemory allocates memory for type C.struct_nk_command_triangle_filled in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkCommandTriangleFilledMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkCommandTriangleFilledValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkCommandTriangleFilledValue = unsafe.Sizeof([1]C.struct_nk_command_triangle_filled{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CommandTriangleFilled) Ref() *C.struct_nk_command_triangle_filled {
	if x == nil {
		return nil
	}
	return x.ref410c5769
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CommandTriangleFilled) Free() {
	if x != nil && x.allocs410c5769 != nil {
		x.allocs410c5769.(*cgoAllocMap).Free()
		x.ref410c5769 = nil
	}
}

// NewCommandTriangleFilledRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCommandTriangleFilledRef(ref unsafe.Pointer) *CommandTriangleFilled {
	if ref == nil {
		return nil
	}
	obj := new(CommandTriangleFilled)
	obj.ref410c5769 = (*C.struct_nk_command_triangle_filled)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CommandTriangleFilled) PassRef() (*C.struct_nk_command_triangle_filled, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref410c5769 != nil {
		return x.ref410c5769, nil
	}
	mem410c5769 := allocStructNkCommandTriangleFilledMemory(1)
	ref410c5769 := (*C.struct_nk_command_triangle_filled)(mem410c5769)
	allocs410c5769 := new(cgoAllocMap)
	var cheader_allocs *cgoAllocMap
	ref410c5769.header, cheader_allocs = x.Header.PassValue()
	allocs410c5769.Borrow(cheader_allocs)

	var ca_allocs *cgoAllocMap
	ref410c5769.a, ca_allocs = x.A.PassValue()
	allocs410c5769.Borrow(ca_allocs)

	var cb_allocs *cgoAllocMap
	ref410c5769.b, cb_allocs = x.B.PassValue()
	allocs410c5769.Borrow(cb_allocs)

	var cc_allocs *cgoAllocMap
	ref410c5769.c, cc_allocs = x.C.PassValue()
	allocs410c5769.Borrow(cc_allocs)

	var ccolor_allocs *cgoAllocMap
	ref410c5769.color, ccolor_allocs = x.Color.PassValue()
	allocs410c5769.Borrow(ccolor_allocs)

	x.ref410c5769 = ref410c5769
	x.allocs410c5769 = allocs410c5769
	return ref410c5769, allocs410c5769

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CommandTriangleFilled) PassValue() (C.struct_nk_command_triangle_filled, *cgoAllocMap) {
	if x.ref410c5769 != nil {
		return *x.ref410c5769, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CommandTriangleFilled) Deref() {
	if x.ref410c5769 == nil {
		return
	}
	x.Header = *NewCommandRef(unsafe.Pointer(&x.ref410c5769.header))
	x.A = *NewVec2iRef(unsafe.Pointer(&x.ref410c5769.a))
	x.B = *NewVec2iRef(unsafe.Pointer(&x.ref410c5769.b))
	x.C = *NewVec2iRef(unsafe.Pointer(&x.ref410c5769.c))
	x.Color = *NewColorRef(unsafe.Pointer(&x.ref410c5769.color))
}

// allocStructNkKeyboardMemory allocates memory for type C.struct_nk_keyboard in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkKeyboardMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkKeyboardValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkKeyboardValue = unsafe.Sizeof([1]C.struct_nk_keyboard{})

// allocA29StructNkKeyMemory allocates memory for type [29]C.struct_nk_key in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA29StructNkKeyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfA29StructNkKeyValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfA29StructNkKeyValue = unsafe.Sizeof([1][29]C.struct_nk_key{})

// unpackA29Key transforms a sliced Go data structure into plain C format.
func unpackA29Key(x [29]Key) (unpacked [29]C.struct_nk_key, allocs *cgoAllocMap) {
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(*[29]C.struct_nk_key) {
		go allocs.Free()
	})

	mem0 := allocA29StructNkKeyMemory(1)
	allocs.Add(mem0)
	v0 := (*[29]C.struct_nk_key)(mem0)
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	unpacked = *(*[29]C.struct_nk_key)(mem0)
	return
}

// packA29Key reads sliced Go data structure out from plain C format.
func packA29Key(v *[29]Key, ptr0 *[29]C.struct_nk_key) {
	for i0 := range v {
		ptr1 := ptr0[i0]
		v[i0] = *NewKeyRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Keyboard) Ref() *C.struct_nk_keyboard {
	if x == nil {
		return nil
	}
	return x.refcc8c697c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Keyboard) Free() {
	if x != nil && x.allocscc8c697c != nil {
		x.allocscc8c697c.(*cgoAllocMap).Free()
		x.refcc8c697c = nil
	}
}

// NewKeyboardRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewKeyboardRef(ref unsafe.Pointer) *Keyboard {
	if ref == nil {
		return nil
	}
	obj := new(Keyboard)
	obj.refcc8c697c = (*C.struct_nk_keyboard)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Keyboard) PassRef() (*C.struct_nk_keyboard, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refcc8c697c != nil {
		return x.refcc8c697c, nil
	}
	memcc8c697c := allocStructNkKeyboardMemory(1)
	refcc8c697c := (*C.struct_nk_keyboard)(memcc8c697c)
	allocscc8c697c := new(cgoAllocMap)
	var ckeys_allocs *cgoAllocMap
	refcc8c697c.keys, ckeys_allocs = unpackA29Key(x.Keys)
	allocscc8c697c.Borrow(ckeys_allocs)

	var ctext_allocs *cgoAllocMap
	refcc8c697c.text, ctext_allocs = *(*[16]C.char)(unsafe.Pointer(&x.Text)), cgoAllocsUnknown
	allocscc8c697c.Borrow(ctext_allocs)

	var ctext_len_allocs *cgoAllocMap
	refcc8c697c.text_len, ctext_len_allocs = (C.int)(x.TextLen), cgoAllocsUnknown
	allocscc8c697c.Borrow(ctext_len_allocs)

	x.refcc8c697c = refcc8c697c
	x.allocscc8c697c = allocscc8c697c
	return refcc8c697c, allocscc8c697c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Keyboard) PassValue() (C.struct_nk_keyboard, *cgoAllocMap) {
	if x.refcc8c697c != nil {
		return *x.refcc8c697c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Keyboard) Deref() {
	if x.refcc8c697c == nil {
		return
	}
	packA29Key(&x.Keys, (*[29]C.struct_nk_key)(unsafe.Pointer(&x.refcc8c697c.keys)))
	x.Text = *(*[16]byte)(unsafe.Pointer(&x.refcc8c697c.text))
	x.TextLen = (int32)(x.refcc8c697c.text_len)
}

// allocStructNkTextUndoRecordMemory allocates memory for type C.struct_nk_text_undo_record in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkTextUndoRecordMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkTextUndoRecordValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkTextUndoRecordValue = unsafe.Sizeof([1]C.struct_nk_text_undo_record{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TextUndoRecord) Ref() *C.struct_nk_text_undo_record {
	if x == nil {
		return nil
	}
	return x.refe570b77c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TextUndoRecord) Free() {
	if x != nil && x.allocse570b77c != nil {
		x.allocse570b77c.(*cgoAllocMap).Free()
		x.refe570b77c = nil
	}
}

// NewTextUndoRecordRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTextUndoRecordRef(ref unsafe.Pointer) *TextUndoRecord {
	if ref == nil {
		return nil
	}
	obj := new(TextUndoRecord)
	obj.refe570b77c = (*C.struct_nk_text_undo_record)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TextUndoRecord) PassRef() (*C.struct_nk_text_undo_record, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe570b77c != nil {
		return x.refe570b77c, nil
	}
	meme570b77c := allocStructNkTextUndoRecordMemory(1)
	refe570b77c := (*C.struct_nk_text_undo_record)(meme570b77c)
	allocse570b77c := new(cgoAllocMap)
	var cwhere_allocs *cgoAllocMap
	refe570b77c.where, cwhere_allocs = (C.int)(x.Where), cgoAllocsUnknown
	allocse570b77c.Borrow(cwhere_allocs)

	var cinsert_length_allocs *cgoAllocMap
	refe570b77c.insert_length, cinsert_length_allocs = (C.short)(x.InsertLength), cgoAllocsUnknown
	allocse570b77c.Borrow(cinsert_length_allocs)

	var cdelete_length_allocs *cgoAllocMap
	refe570b77c.delete_length, cdelete_length_allocs = (C.short)(x.DeleteLength), cgoAllocsUnknown
	allocse570b77c.Borrow(cdelete_length_allocs)

	var cchar_storage_allocs *cgoAllocMap
	refe570b77c.char_storage, cchar_storage_allocs = (C.short)(x.CharStorage), cgoAllocsUnknown
	allocse570b77c.Borrow(cchar_storage_allocs)

	x.refe570b77c = refe570b77c
	x.allocse570b77c = allocse570b77c
	return refe570b77c, allocse570b77c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TextUndoRecord) PassValue() (C.struct_nk_text_undo_record, *cgoAllocMap) {
	if x.refe570b77c != nil {
		return *x.refe570b77c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TextUndoRecord) Deref() {
	if x.refe570b77c == nil {
		return
	}
	x.Where = (int32)(x.refe570b77c.where)
	x.InsertLength = (int16)(x.refe570b77c.insert_length)
	x.DeleteLength = (int16)(x.refe570b77c.delete_length)
	x.CharStorage = (int16)(x.refe570b77c.char_storage)
}

// Ref returns a reference to C object as it is.
func (x *DrawVertexLayoutElement) Ref() *C.struct_nk_draw_vertex_layout_element {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_draw_vertex_layout_element)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *DrawVertexLayoutElement) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewDrawVertexLayoutElementRef converts the C object reference into a raw struct reference without wrapping.
func NewDrawVertexLayoutElementRef(ref *C.struct_nk_draw_vertex_layout_element) *DrawVertexLayoutElement {
	return (*DrawVertexLayoutElement)(unsafe.Pointer(ref))
}

// NewDrawVertexLayoutElement allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewDrawVertexLayoutElement() *DrawVertexLayoutElement {
	return (*DrawVertexLayoutElement)(allocStructNkDrawVertexLayoutElementMemory(1))
}

// allocStructNkDrawVertexLayoutElementMemory allocates memory for type C.struct_nk_draw_vertex_layout_element in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkDrawVertexLayoutElementMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkDrawVertexLayoutElementValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkDrawVertexLayoutElementValue = unsafe.Sizeof([1]C.struct_nk_draw_vertex_layout_element{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *DrawVertexLayoutElement) PassRef() *C.struct_nk_draw_vertex_layout_element {
	if x == nil {
		x = (*DrawVertexLayoutElement)(allocStructNkDrawVertexLayoutElementMemory(1))
	}
	return (*C.struct_nk_draw_vertex_layout_element)(unsafe.Pointer(x))
}

// allocStructNkDrawNullTextureMemory allocates memory for type C.struct_nk_draw_null_texture in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkDrawNullTextureMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkDrawNullTextureValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkDrawNullTextureValue = unsafe.Sizeof([1]C.struct_nk_draw_null_texture{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DrawNullTexture) Ref() *C.struct_nk_draw_null_texture {
	if x == nil {
		return nil
	}
	return x.refc45a53be
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DrawNullTexture) Free() {
	if x != nil && x.allocsc45a53be != nil {
		x.allocsc45a53be.(*cgoAllocMap).Free()
		x.refc45a53be = nil
	}
}

// NewDrawNullTextureRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDrawNullTextureRef(ref unsafe.Pointer) *DrawNullTexture {
	if ref == nil {
		return nil
	}
	obj := new(DrawNullTexture)
	obj.refc45a53be = (*C.struct_nk_draw_null_texture)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DrawNullTexture) PassRef() (*C.struct_nk_draw_null_texture, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc45a53be != nil {
		return x.refc45a53be, nil
	}
	memc45a53be := allocStructNkDrawNullTextureMemory(1)
	refc45a53be := (*C.struct_nk_draw_null_texture)(memc45a53be)
	allocsc45a53be := new(cgoAllocMap)
	var ctexture_allocs *cgoAllocMap
	refc45a53be.texture, ctexture_allocs = *(*C.nk_handle)(unsafe.Pointer(&x.Texture)), cgoAllocsUnknown
	allocsc45a53be.Borrow(ctexture_allocs)

	var cuv_allocs *cgoAllocMap
	refc45a53be.uv, cuv_allocs = x.Uv.PassValue()
	allocsc45a53be.Borrow(cuv_allocs)

	x.refc45a53be = refc45a53be
	x.allocsc45a53be = allocsc45a53be
	return refc45a53be, allocsc45a53be

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DrawNullTexture) PassValue() (C.struct_nk_draw_null_texture, *cgoAllocMap) {
	if x.refc45a53be != nil {
		return *x.refc45a53be, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DrawNullTexture) Deref() {
	if x.refc45a53be == nil {
		return
	}
	x.Texture = *(*Handle)(unsafe.Pointer(&x.refc45a53be.texture))
	x.Uv = *NewVec2Ref(unsafe.Pointer(&x.refc45a53be.uv))
}

// allocStructNkCommandTriangleMemory allocates memory for type C.struct_nk_command_triangle in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkCommandTriangleMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkCommandTriangleValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkCommandTriangleValue = unsafe.Sizeof([1]C.struct_nk_command_triangle{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CommandTriangle) Ref() *C.struct_nk_command_triangle {
	if x == nil {
		return nil
	}
	return x.refcfbe3d74
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CommandTriangle) Free() {
	if x != nil && x.allocscfbe3d74 != nil {
		x.allocscfbe3d74.(*cgoAllocMap).Free()
		x.refcfbe3d74 = nil
	}
}

// NewCommandTriangleRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCommandTriangleRef(ref unsafe.Pointer) *CommandTriangle {
	if ref == nil {
		return nil
	}
	obj := new(CommandTriangle)
	obj.refcfbe3d74 = (*C.struct_nk_command_triangle)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CommandTriangle) PassRef() (*C.struct_nk_command_triangle, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refcfbe3d74 != nil {
		return x.refcfbe3d74, nil
	}
	memcfbe3d74 := allocStructNkCommandTriangleMemory(1)
	refcfbe3d74 := (*C.struct_nk_command_triangle)(memcfbe3d74)
	allocscfbe3d74 := new(cgoAllocMap)
	var cheader_allocs *cgoAllocMap
	refcfbe3d74.header, cheader_allocs = x.Header.PassValue()
	allocscfbe3d74.Borrow(cheader_allocs)

	var cline_thickness_allocs *cgoAllocMap
	refcfbe3d74.line_thickness, cline_thickness_allocs = (C.ushort)(x.LineThickness), cgoAllocsUnknown
	allocscfbe3d74.Borrow(cline_thickness_allocs)

	var ca_allocs *cgoAllocMap
	refcfbe3d74.a, ca_allocs = x.A.PassValue()
	allocscfbe3d74.Borrow(ca_allocs)

	var cb_allocs *cgoAllocMap
	refcfbe3d74.b, cb_allocs = x.B.PassValue()
	allocscfbe3d74.Borrow(cb_allocs)

	var cc_allocs *cgoAllocMap
	refcfbe3d74.c, cc_allocs = x.C.PassValue()
	allocscfbe3d74.Borrow(cc_allocs)

	var ccolor_allocs *cgoAllocMap
	refcfbe3d74.color, ccolor_allocs = x.Color.PassValue()
	allocscfbe3d74.Borrow(ccolor_allocs)

	x.refcfbe3d74 = refcfbe3d74
	x.allocscfbe3d74 = allocscfbe3d74
	return refcfbe3d74, allocscfbe3d74

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CommandTriangle) PassValue() (C.struct_nk_command_triangle, *cgoAllocMap) {
	if x.refcfbe3d74 != nil {
		return *x.refcfbe3d74, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CommandTriangle) Deref() {
	if x.refcfbe3d74 == nil {
		return
	}
	x.Header = *NewCommandRef(unsafe.Pointer(&x.refcfbe3d74.header))
	x.LineThickness = (uint16)(x.refcfbe3d74.line_thickness)
	x.A = *NewVec2iRef(unsafe.Pointer(&x.refcfbe3d74.a))
	x.B = *NewVec2iRef(unsafe.Pointer(&x.refcfbe3d74.b))
	x.C = *NewVec2iRef(unsafe.Pointer(&x.refcfbe3d74.c))
	x.Color = *NewColorRef(unsafe.Pointer(&x.refcfbe3d74.color))
}

// allocStructNkEditStateMemory allocates memory for type C.struct_nk_edit_state in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkEditStateMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkEditStateValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkEditStateValue = unsafe.Sizeof([1]C.struct_nk_edit_state{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *EditState) Ref() *C.struct_nk_edit_state {
	if x == nil {
		return nil
	}
	return x.refcc4bfa07
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *EditState) Free() {
	if x != nil && x.allocscc4bfa07 != nil {
		x.allocscc4bfa07.(*cgoAllocMap).Free()
		x.refcc4bfa07 = nil
	}
}

// NewEditStateRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewEditStateRef(ref unsafe.Pointer) *EditState {
	if ref == nil {
		return nil
	}
	obj := new(EditState)
	obj.refcc4bfa07 = (*C.struct_nk_edit_state)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *EditState) PassRef() (*C.struct_nk_edit_state, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refcc4bfa07 != nil {
		return x.refcc4bfa07, nil
	}
	memcc4bfa07 := allocStructNkEditStateMemory(1)
	refcc4bfa07 := (*C.struct_nk_edit_state)(memcc4bfa07)
	allocscc4bfa07 := new(cgoAllocMap)
	var cname_allocs *cgoAllocMap
	refcc4bfa07.name, cname_allocs = (C.nk_hash)(x.Name), cgoAllocsUnknown
	allocscc4bfa07.Borrow(cname_allocs)

	var cseq_allocs *cgoAllocMap
	refcc4bfa07.seq, cseq_allocs = (C.uint)(x.Seq), cgoAllocsUnknown
	allocscc4bfa07.Borrow(cseq_allocs)

	var cold_allocs *cgoAllocMap
	refcc4bfa07.old, cold_allocs = (C.uint)(x.Old), cgoAllocsUnknown
	allocscc4bfa07.Borrow(cold_allocs)

	var cactive_allocs *cgoAllocMap
	refcc4bfa07.active, cactive_allocs = (C.int)(x.Active), cgoAllocsUnknown
	allocscc4bfa07.Borrow(cactive_allocs)

	var cprev_allocs *cgoAllocMap
	refcc4bfa07.prev, cprev_allocs = (C.int)(x.Prev), cgoAllocsUnknown
	allocscc4bfa07.Borrow(cprev_allocs)

	var ccursor_allocs *cgoAllocMap
	refcc4bfa07.cursor, ccursor_allocs = (C.int)(x.Cursor), cgoAllocsUnknown
	allocscc4bfa07.Borrow(ccursor_allocs)

	var csel_start_allocs *cgoAllocMap
	refcc4bfa07.sel_start, csel_start_allocs = (C.int)(x.SelStart), cgoAllocsUnknown
	allocscc4bfa07.Borrow(csel_start_allocs)

	var csel_end_allocs *cgoAllocMap
	refcc4bfa07.sel_end, csel_end_allocs = (C.int)(x.SelEnd), cgoAllocsUnknown
	allocscc4bfa07.Borrow(csel_end_allocs)

	var cscrollbar_allocs *cgoAllocMap
	refcc4bfa07.scrollbar, cscrollbar_allocs = x.Scrollbar.PassValue()
	allocscc4bfa07.Borrow(cscrollbar_allocs)

	var cmode_allocs *cgoAllocMap
	refcc4bfa07.mode, cmode_allocs = (C.uchar)(x.Mode), cgoAllocsUnknown
	allocscc4bfa07.Borrow(cmode_allocs)

	var csingle_line_allocs *cgoAllocMap
	refcc4bfa07.single_line, csingle_line_allocs = (C.uchar)(x.SingleLine), cgoAllocsUnknown
	allocscc4bfa07.Borrow(csingle_line_allocs)

	x.refcc4bfa07 = refcc4bfa07
	x.allocscc4bfa07 = allocscc4bfa07
	return refcc4bfa07, allocscc4bfa07

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x EditState) PassValue() (C.struct_nk_edit_state, *cgoAllocMap) {
	if x.refcc4bfa07 != nil {
		return *x.refcc4bfa07, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *EditState) Deref() {
	if x.refcc4bfa07 == nil {
		return
	}
	x.Name = (Hash)(x.refcc4bfa07.name)
	x.Seq = (uint32)(x.refcc4bfa07.seq)
	x.Old = (uint32)(x.refcc4bfa07.old)
	x.Active = (int32)(x.refcc4bfa07.active)
	x.Prev = (int32)(x.refcc4bfa07.prev)
	x.Cursor = (int32)(x.refcc4bfa07.cursor)
	x.SelStart = (int32)(x.refcc4bfa07.sel_start)
	x.SelEnd = (int32)(x.refcc4bfa07.sel_end)
	x.Scrollbar = *NewScrollRef(unsafe.Pointer(&x.refcc4bfa07.scrollbar))
	x.Mode = (byte)(x.refcc4bfa07.mode)
	x.SingleLine = (byte)(x.refcc4bfa07.single_line)
}

// allocStructNkConfigStackButtonBehaviorElementMemory allocates memory for type C.struct_nk_config_stack_button_behavior_element in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkConfigStackButtonBehaviorElementMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkConfigStackButtonBehaviorElementValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkConfigStackButtonBehaviorElementValue = unsafe.Sizeof([1]C.struct_nk_config_stack_button_behavior_element{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ConfigStackButtonBehaviorElement) Ref() *C.struct_nk_config_stack_button_behavior_element {
	if x == nil {
		return nil
	}
	return x.ref485b597
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ConfigStackButtonBehaviorElement) Free() {
	if x != nil && x.allocs485b597 != nil {
		x.allocs485b597.(*cgoAllocMap).Free()
		x.ref485b597 = nil
	}
}

// NewConfigStackButtonBehaviorElementRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewConfigStackButtonBehaviorElementRef(ref unsafe.Pointer) *ConfigStackButtonBehaviorElement {
	if ref == nil {
		return nil
	}
	obj := new(ConfigStackButtonBehaviorElement)
	obj.ref485b597 = (*C.struct_nk_config_stack_button_behavior_element)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ConfigStackButtonBehaviorElement) PassRef() (*C.struct_nk_config_stack_button_behavior_element, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref485b597 != nil {
		return x.ref485b597, nil
	}
	mem485b597 := allocStructNkConfigStackButtonBehaviorElementMemory(1)
	ref485b597 := (*C.struct_nk_config_stack_button_behavior_element)(mem485b597)
	allocs485b597 := new(cgoAllocMap)
	var caddress_allocs *cgoAllocMap
	ref485b597.address, caddress_allocs = (*C.enum_nk_button_behavior)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Address)).Data)), cgoAllocsUnknown
	allocs485b597.Borrow(caddress_allocs)

	var cold_value_allocs *cgoAllocMap
	ref485b597.old_value, cold_value_allocs = (C.enum_nk_button_behavior)(x.OldValue), cgoAllocsUnknown
	allocs485b597.Borrow(cold_value_allocs)

	x.ref485b597 = ref485b597
	x.allocs485b597 = allocs485b597
	return ref485b597, allocs485b597

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ConfigStackButtonBehaviorElement) PassValue() (C.struct_nk_config_stack_button_behavior_element, *cgoAllocMap) {
	if x.ref485b597 != nil {
		return *x.ref485b597, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ConfigStackButtonBehaviorElement) Deref() {
	if x.ref485b597 == nil {
		return
	}
	hxfa3f05c := (*sliceHeader)(unsafe.Pointer(&x.Address))
	hxfa3f05c.Data = uintptr(unsafe.Pointer(x.ref485b597.address))
	hxfa3f05c.Cap = 0x7fffffff
	// hxfa3f05c.Len = ?

	x.OldValue = (ButtonBehavior)(x.ref485b597.old_value)
}

// allocStructNkContextMemory allocates memory for type C.struct_nk_context in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkContextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkContextValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkContextValue = unsafe.Sizeof([1]C.struct_nk_context{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Context) Ref() *C.struct_nk_context {
	if x == nil {
		return nil
	}
	return x.refc5463edd
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Context) Free() {
	if x != nil && x.allocsc5463edd != nil {
		x.allocsc5463edd.(*cgoAllocMap).Free()
		x.refc5463edd = nil
	}
}

// NewContextRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewContextRef(ref unsafe.Pointer) *Context {
	if ref == nil {
		return nil
	}
	obj := new(Context)
	obj.refc5463edd = (*C.struct_nk_context)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Context) PassRef() (*C.struct_nk_context, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc5463edd != nil {
		return x.refc5463edd, nil
	}
	memc5463edd := allocStructNkContextMemory(1)
	refc5463edd := (*C.struct_nk_context)(memc5463edd)
	allocsc5463edd := new(cgoAllocMap)
	var cinput_allocs *cgoAllocMap
	refc5463edd.input, cinput_allocs = x.Input.PassValue()
	allocsc5463edd.Borrow(cinput_allocs)

	var cstyle_allocs *cgoAllocMap
	refc5463edd.style, cstyle_allocs = x.Style.PassValue()
	allocsc5463edd.Borrow(cstyle_allocs)

	var cmemory_allocs *cgoAllocMap
	refc5463edd.memory, cmemory_allocs = x.Memory.PassValue()
	allocsc5463edd.Borrow(cmemory_allocs)

	var cclip_allocs *cgoAllocMap
	refc5463edd.clip, cclip_allocs = x.Clip.PassValue()
	allocsc5463edd.Borrow(cclip_allocs)

	var clast_widget_state_allocs *cgoAllocMap
	refc5463edd.last_widget_state, clast_widget_state_allocs = (C.nk_flags)(x.LastWidgetState), cgoAllocsUnknown
	allocsc5463edd.Borrow(clast_widget_state_allocs)

	var cdelta_time_seconds_allocs *cgoAllocMap
	refc5463edd.delta_time_seconds, cdelta_time_seconds_allocs = (C.float)(x.DeltaTimeSeconds), cgoAllocsUnknown
	allocsc5463edd.Borrow(cdelta_time_seconds_allocs)

	var cbutton_behavior_allocs *cgoAllocMap
	refc5463edd.button_behavior, cbutton_behavior_allocs = (C.enum_nk_button_behavior)(x.ButtonBehavior), cgoAllocsUnknown
	allocsc5463edd.Borrow(cbutton_behavior_allocs)

	var cstacks_allocs *cgoAllocMap
	refc5463edd.stacks, cstacks_allocs = x.Stacks.PassValue()
	allocsc5463edd.Borrow(cstacks_allocs)

	var ctext_edit_allocs *cgoAllocMap
	refc5463edd.text_edit, ctext_edit_allocs = x.TextEdit.PassValue()
	allocsc5463edd.Borrow(ctext_edit_allocs)

	var coverlay_allocs *cgoAllocMap
	refc5463edd.overlay, coverlay_allocs = x.Overlay.PassValue()
	allocsc5463edd.Borrow(coverlay_allocs)

	var cbuild_allocs *cgoAllocMap
	refc5463edd.build, cbuild_allocs = (C.int)(x.Build), cgoAllocsUnknown
	allocsc5463edd.Borrow(cbuild_allocs)

	var cuse_pool_allocs *cgoAllocMap
	refc5463edd.use_pool, cuse_pool_allocs = (C.int)(x.UsePool), cgoAllocsUnknown
	allocsc5463edd.Borrow(cuse_pool_allocs)

	var cpool_allocs *cgoAllocMap
	refc5463edd.pool, cpool_allocs = x.Pool.PassValue()
	allocsc5463edd.Borrow(cpool_allocs)

	var cbegin_allocs *cgoAllocMap
	refc5463edd.begin, cbegin_allocs = unpackSWindow(x.Begin)
	allocsc5463edd.Borrow(cbegin_allocs)

	var cend_allocs *cgoAllocMap
	refc5463edd.end, cend_allocs = unpackSWindow(x.End)
	allocsc5463edd.Borrow(cend_allocs)

	var cactive_allocs *cgoAllocMap
	refc5463edd.active, cactive_allocs = unpackSWindow(x.Active)
	allocsc5463edd.Borrow(cactive_allocs)

	var ccurrent_allocs *cgoAllocMap
	refc5463edd.current, ccurrent_allocs = unpackSWindow(x.Current)
	allocsc5463edd.Borrow(ccurrent_allocs)

	var cfreelist_allocs *cgoAllocMap
	refc5463edd.freelist, cfreelist_allocs = unpackSPageElement(x.Freelist)
	allocsc5463edd.Borrow(cfreelist_allocs)

	var ccount_allocs *cgoAllocMap
	refc5463edd.count, ccount_allocs = (C.uint)(x.Count), cgoAllocsUnknown
	allocsc5463edd.Borrow(ccount_allocs)

	var cseq_allocs *cgoAllocMap
	refc5463edd.seq, cseq_allocs = (C.uint)(x.Seq), cgoAllocsUnknown
	allocsc5463edd.Borrow(cseq_allocs)

	x.refc5463edd = refc5463edd
	x.allocsc5463edd = allocsc5463edd
	return refc5463edd, allocsc5463edd

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Context) PassValue() (C.struct_nk_context, *cgoAllocMap) {
	if x.refc5463edd != nil {
		return *x.refc5463edd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Context) Deref() {
	if x.refc5463edd == nil {
		return
	}
	x.Input = *NewInputRef(unsafe.Pointer(&x.refc5463edd.input))
	x.Style = *NewStyleRef(unsafe.Pointer(&x.refc5463edd.style))
	x.Memory = *NewBufferRef(unsafe.Pointer(&x.refc5463edd.memory))
	x.Clip = *NewClipboardRef(unsafe.Pointer(&x.refc5463edd.clip))
	x.LastWidgetState = (Flags)(x.refc5463edd.last_widget_state)
	x.DeltaTimeSeconds = (float32)(x.refc5463edd.delta_time_seconds)
	x.ButtonBehavior = (ButtonBehavior)(x.refc5463edd.button_behavior)
	x.Stacks = *NewConfigurationStacksRef(unsafe.Pointer(&x.refc5463edd.stacks))
	x.TextEdit = *NewTextEditRef(unsafe.Pointer(&x.refc5463edd.text_edit))
	x.Overlay = *NewCommandBufferRef(unsafe.Pointer(&x.refc5463edd.overlay))
	x.Build = (int32)(x.refc5463edd.build)
	x.UsePool = (int32)(x.refc5463edd.use_pool)
	x.Pool = *NewPoolRef(unsafe.Pointer(&x.refc5463edd.pool))
	packSWindow(x.Begin, x.refc5463edd.begin)
	packSWindow(x.End, x.refc5463edd.end)
	packSWindow(x.Active, x.refc5463edd.active)
	packSWindow(x.Current, x.refc5463edd.current)
	packSPageElement(x.Freelist, x.refc5463edd.freelist)
	x.Count = (uint32)(x.refc5463edd.count)
	x.Seq = (uint32)(x.refc5463edd.seq)
}

// allocStructNkConfigurationStacksMemory allocates memory for type C.struct_nk_configuration_stacks in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkConfigurationStacksMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkConfigurationStacksValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkConfigurationStacksValue = unsafe.Sizeof([1]C.struct_nk_configuration_stacks{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ConfigurationStacks) Ref() *C.struct_nk_configuration_stacks {
	if x == nil {
		return nil
	}
	return x.refcbfb6c4b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ConfigurationStacks) Free() {
	if x != nil && x.allocscbfb6c4b != nil {
		x.allocscbfb6c4b.(*cgoAllocMap).Free()
		x.refcbfb6c4b = nil
	}
}

// NewConfigurationStacksRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewConfigurationStacksRef(ref unsafe.Pointer) *ConfigurationStacks {
	if ref == nil {
		return nil
	}
	obj := new(ConfigurationStacks)
	obj.refcbfb6c4b = (*C.struct_nk_configuration_stacks)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ConfigurationStacks) PassRef() (*C.struct_nk_configuration_stacks, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refcbfb6c4b != nil {
		return x.refcbfb6c4b, nil
	}
	memcbfb6c4b := allocStructNkConfigurationStacksMemory(1)
	refcbfb6c4b := (*C.struct_nk_configuration_stacks)(memcbfb6c4b)
	allocscbfb6c4b := new(cgoAllocMap)
	var cstyle_items_allocs *cgoAllocMap
	refcbfb6c4b.style_items, cstyle_items_allocs = x.StyleItems.PassValue()
	allocscbfb6c4b.Borrow(cstyle_items_allocs)

	var cfloats_allocs *cgoAllocMap
	refcbfb6c4b.floats, cfloats_allocs = x.Floats.PassValue()
	allocscbfb6c4b.Borrow(cfloats_allocs)

	var cvectors_allocs *cgoAllocMap
	refcbfb6c4b.vectors, cvectors_allocs = x.Vectors.PassValue()
	allocscbfb6c4b.Borrow(cvectors_allocs)

	var cflags_allocs *cgoAllocMap
	refcbfb6c4b.flags, cflags_allocs = x.Flags.PassValue()
	allocscbfb6c4b.Borrow(cflags_allocs)

	var ccolors_allocs *cgoAllocMap
	refcbfb6c4b.colors, ccolors_allocs = x.Colors.PassValue()
	allocscbfb6c4b.Borrow(ccolors_allocs)

	var cfonts_allocs *cgoAllocMap
	refcbfb6c4b.fonts, cfonts_allocs = x.Fonts.PassValue()
	allocscbfb6c4b.Borrow(cfonts_allocs)

	var cbutton_behaviors_allocs *cgoAllocMap
	refcbfb6c4b.button_behaviors, cbutton_behaviors_allocs = x.ButtonBehaviors.PassValue()
	allocscbfb6c4b.Borrow(cbutton_behaviors_allocs)

	x.refcbfb6c4b = refcbfb6c4b
	x.allocscbfb6c4b = allocscbfb6c4b
	return refcbfb6c4b, allocscbfb6c4b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ConfigurationStacks) PassValue() (C.struct_nk_configuration_stacks, *cgoAllocMap) {
	if x.refcbfb6c4b != nil {
		return *x.refcbfb6c4b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ConfigurationStacks) Deref() {
	if x.refcbfb6c4b == nil {
		return
	}
	x.StyleItems = *NewConfigStackStyleItemRef(unsafe.Pointer(&x.refcbfb6c4b.style_items))
	x.Floats = *NewConfigStackFloatRef(unsafe.Pointer(&x.refcbfb6c4b.floats))
	x.Vectors = *NewConfigStackVec2Ref(unsafe.Pointer(&x.refcbfb6c4b.vectors))
	x.Flags = *NewConfigStackFlagsRef(unsafe.Pointer(&x.refcbfb6c4b.flags))
	x.Colors = *NewConfigStackColorRef(unsafe.Pointer(&x.refcbfb6c4b.colors))
	x.Fonts = *NewConfigStackUserFontRef(unsafe.Pointer(&x.refcbfb6c4b.fonts))
	x.ButtonBehaviors = *NewConfigStackButtonBehaviorRef(unsafe.Pointer(&x.refcbfb6c4b.button_behaviors))
}

// allocStructNkCommandMemory allocates memory for type C.struct_nk_command in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkCommandMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkCommandValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkCommandValue = unsafe.Sizeof([1]C.struct_nk_command{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Command) Ref() *C.struct_nk_command {
	if x == nil {
		return nil
	}
	return x.refa9d15177
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Command) Free() {
	if x != nil && x.allocsa9d15177 != nil {
		x.allocsa9d15177.(*cgoAllocMap).Free()
		x.refa9d15177 = nil
	}
}

// NewCommandRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCommandRef(ref unsafe.Pointer) *Command {
	if ref == nil {
		return nil
	}
	obj := new(Command)
	obj.refa9d15177 = (*C.struct_nk_command)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Command) PassRef() (*C.struct_nk_command, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa9d15177 != nil {
		return x.refa9d15177, nil
	}
	mema9d15177 := allocStructNkCommandMemory(1)
	refa9d15177 := (*C.struct_nk_command)(mema9d15177)
	allocsa9d15177 := new(cgoAllocMap)
	var c_type_allocs *cgoAllocMap
	refa9d15177._type, c_type_allocs = (C.enum_nk_command_type)(x.Type), cgoAllocsUnknown
	allocsa9d15177.Borrow(c_type_allocs)

	var cnext_allocs *cgoAllocMap
	refa9d15177.next, cnext_allocs = (C.nk_size)(x.Next), cgoAllocsUnknown
	allocsa9d15177.Borrow(cnext_allocs)

	x.refa9d15177 = refa9d15177
	x.allocsa9d15177 = allocsa9d15177
	return refa9d15177, allocsa9d15177

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Command) PassValue() (C.struct_nk_command, *cgoAllocMap) {
	if x.refa9d15177 != nil {
		return *x.refa9d15177, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Command) Deref() {
	if x.refa9d15177 == nil {
		return
	}
	x.Type = (CommandType)(x.refa9d15177._type)
	x.Next = (Size)(x.refa9d15177.next)
}

// allocStructNkCommandPolylineMemory allocates memory for type C.struct_nk_command_polyline in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkCommandPolylineMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkCommandPolylineValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkCommandPolylineValue = unsafe.Sizeof([1]C.struct_nk_command_polyline{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CommandPolyline) Ref() *C.struct_nk_command_polyline {
	if x == nil {
		return nil
	}
	return x.refdf010473
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CommandPolyline) Free() {
	if x != nil && x.allocsdf010473 != nil {
		x.allocsdf010473.(*cgoAllocMap).Free()
		x.refdf010473 = nil
	}
}

// NewCommandPolylineRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCommandPolylineRef(ref unsafe.Pointer) *CommandPolyline {
	if ref == nil {
		return nil
	}
	obj := new(CommandPolyline)
	obj.refdf010473 = (*C.struct_nk_command_polyline)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CommandPolyline) PassRef() (*C.struct_nk_command_polyline, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refdf010473 != nil {
		return x.refdf010473, nil
	}
	memdf010473 := allocStructNkCommandPolylineMemory(1)
	refdf010473 := (*C.struct_nk_command_polyline)(memdf010473)
	allocsdf010473 := new(cgoAllocMap)
	var cheader_allocs *cgoAllocMap
	refdf010473.header, cheader_allocs = x.Header.PassValue()
	allocsdf010473.Borrow(cheader_allocs)

	var ccolor_allocs *cgoAllocMap
	refdf010473.color, ccolor_allocs = x.Color.PassValue()
	allocsdf010473.Borrow(ccolor_allocs)

	var cline_thickness_allocs *cgoAllocMap
	refdf010473.line_thickness, cline_thickness_allocs = (C.ushort)(x.LineThickness), cgoAllocsUnknown
	allocsdf010473.Borrow(cline_thickness_allocs)

	var cpoint_count_allocs *cgoAllocMap
	refdf010473.point_count, cpoint_count_allocs = (C.ushort)(x.PointCount), cgoAllocsUnknown
	allocsdf010473.Borrow(cpoint_count_allocs)

	var cpoints_allocs *cgoAllocMap
	refdf010473.points, cpoints_allocs = unpackA1Vec2i(x.Points)
	allocsdf010473.Borrow(cpoints_allocs)

	x.refdf010473 = refdf010473
	x.allocsdf010473 = allocsdf010473
	return refdf010473, allocsdf010473

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CommandPolyline) PassValue() (C.struct_nk_command_polyline, *cgoAllocMap) {
	if x.refdf010473 != nil {
		return *x.refdf010473, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CommandPolyline) Deref() {
	if x.refdf010473 == nil {
		return
	}
	x.Header = *NewCommandRef(unsafe.Pointer(&x.refdf010473.header))
	x.Color = *NewColorRef(unsafe.Pointer(&x.refdf010473.color))
	x.LineThickness = (uint16)(x.refdf010473.line_thickness)
	x.PointCount = (uint16)(x.refdf010473.point_count)
	packA1Vec2i(&x.Points, (*[1]C.struct_nk_vec2i)(unsafe.Pointer(&x.refdf010473.points)))
}

// allocStructNkPopupStateMemory allocates memory for type C.struct_nk_popup_state in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkPopupStateMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkPopupStateValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkPopupStateValue = unsafe.Sizeof([1]C.struct_nk_popup_state{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PopupState) Ref() *C.struct_nk_popup_state {
	if x == nil {
		return nil
	}
	return x.ref4fb276c7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PopupState) Free() {
	if x != nil && x.allocs4fb276c7 != nil {
		x.allocs4fb276c7.(*cgoAllocMap).Free()
		x.ref4fb276c7 = nil
	}
}

// NewPopupStateRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPopupStateRef(ref unsafe.Pointer) *PopupState {
	if ref == nil {
		return nil
	}
	obj := new(PopupState)
	obj.ref4fb276c7 = (*C.struct_nk_popup_state)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PopupState) PassRef() (*C.struct_nk_popup_state, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4fb276c7 != nil {
		return x.ref4fb276c7, nil
	}
	mem4fb276c7 := allocStructNkPopupStateMemory(1)
	ref4fb276c7 := (*C.struct_nk_popup_state)(mem4fb276c7)
	allocs4fb276c7 := new(cgoAllocMap)
	var cwin_allocs *cgoAllocMap
	ref4fb276c7.win, cwin_allocs = unpackSWindow(x.Win)
	allocs4fb276c7.Borrow(cwin_allocs)

	var c_type_allocs *cgoAllocMap
	ref4fb276c7._type, c_type_allocs = (C.enum_nk_panel_type)(x.Type), cgoAllocsUnknown
	allocs4fb276c7.Borrow(c_type_allocs)

	var cname_allocs *cgoAllocMap
	ref4fb276c7.name, cname_allocs = (C.nk_hash)(x.Name), cgoAllocsUnknown
	allocs4fb276c7.Borrow(cname_allocs)

	var cactive_allocs *cgoAllocMap
	ref4fb276c7.active, cactive_allocs = (C.int)(x.Active), cgoAllocsUnknown
	allocs4fb276c7.Borrow(cactive_allocs)

	var ccombo_count_allocs *cgoAllocMap
	ref4fb276c7.combo_count, ccombo_count_allocs = (C.uint)(x.ComboCount), cgoAllocsUnknown
	allocs4fb276c7.Borrow(ccombo_count_allocs)

	var ccon_count_allocs *cgoAllocMap
	ref4fb276c7.con_count, ccon_count_allocs = (C.uint)(x.ConCount), cgoAllocsUnknown
	allocs4fb276c7.Borrow(ccon_count_allocs)

	var ccon_old_allocs *cgoAllocMap
	ref4fb276c7.con_old, ccon_old_allocs = (C.uint)(x.ConOld), cgoAllocsUnknown
	allocs4fb276c7.Borrow(ccon_old_allocs)

	var cactive_con_allocs *cgoAllocMap
	ref4fb276c7.active_con, cactive_con_allocs = (C.uint)(x.ActiveCon), cgoAllocsUnknown
	allocs4fb276c7.Borrow(cactive_con_allocs)

	var cheader_allocs *cgoAllocMap
	ref4fb276c7.header, cheader_allocs = x.Header.PassValue()
	allocs4fb276c7.Borrow(cheader_allocs)

	x.ref4fb276c7 = ref4fb276c7
	x.allocs4fb276c7 = allocs4fb276c7
	return ref4fb276c7, allocs4fb276c7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PopupState) PassValue() (C.struct_nk_popup_state, *cgoAllocMap) {
	if x.ref4fb276c7 != nil {
		return *x.ref4fb276c7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PopupState) Deref() {
	if x.ref4fb276c7 == nil {
		return
	}
	packSWindow(x.Win, x.ref4fb276c7.win)
	x.Type = (PanelType)(x.ref4fb276c7._type)
	x.Name = (Hash)(x.ref4fb276c7.name)
	x.Active = (int32)(x.ref4fb276c7.active)
	x.ComboCount = (uint32)(x.ref4fb276c7.combo_count)
	x.ConCount = (uint32)(x.ref4fb276c7.con_count)
	x.ConOld = (uint32)(x.ref4fb276c7.con_old)
	x.ActiveCon = (uint32)(x.ref4fb276c7.active_con)
	x.Header = *NewRectRef(unsafe.Pointer(&x.ref4fb276c7.header))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PageElement) Ref() *C.struct_nk_page_element {
	if x == nil {
		return nil
	}
	return x.ref8c626785
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PageElement) Free() {
	if x != nil && x.allocs8c626785 != nil {
		x.allocs8c626785.(*cgoAllocMap).Free()
		x.ref8c626785 = nil
	}
}

// NewPageElementRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPageElementRef(ref unsafe.Pointer) *PageElement {
	if ref == nil {
		return nil
	}
	obj := new(PageElement)
	obj.ref8c626785 = (*C.struct_nk_page_element)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PageElement) PassRef() (*C.struct_nk_page_element, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8c626785 != nil {
		return x.ref8c626785, nil
	}
	mem8c626785 := allocStructNkPageElementMemory(1)
	ref8c626785 := (*C.struct_nk_page_element)(mem8c626785)
	allocs8c626785 := new(cgoAllocMap)
	var cdata_allocs *cgoAllocMap
	ref8c626785.data, cdata_allocs = *(*C.union_nk_page_data)(unsafe.Pointer(&x.Data)), cgoAllocsUnknown
	allocs8c626785.Borrow(cdata_allocs)

	var cnext_allocs *cgoAllocMap
	ref8c626785.next, cnext_allocs = unpackSPageElement(x.Next)
	allocs8c626785.Borrow(cnext_allocs)

	var cprev_allocs *cgoAllocMap
	ref8c626785.prev, cprev_allocs = unpackSPageElement(x.Prev)
	allocs8c626785.Borrow(cprev_allocs)

	x.ref8c626785 = ref8c626785
	x.allocs8c626785 = allocs8c626785
	return ref8c626785, allocs8c626785

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PageElement) PassValue() (C.struct_nk_page_element, *cgoAllocMap) {
	if x.ref8c626785 != nil {
		return *x.ref8c626785, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PageElement) Deref() {
	if x.ref8c626785 == nil {
		return
	}
	x.Data = *(*PageData)(unsafe.Pointer(&x.ref8c626785.data))
	packSPageElement(x.Next, x.ref8c626785.next)
	packSPageElement(x.Prev, x.ref8c626785.prev)
}

// allocStructNkCommandTextMemory allocates memory for type C.struct_nk_command_text in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkCommandTextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkCommandTextValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkCommandTextValue = unsafe.Sizeof([1]C.struct_nk_command_text{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CommandText) Ref() *C.struct_nk_command_text {
	if x == nil {
		return nil
	}
	return x.refad63db63
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CommandText) Free() {
	if x != nil && x.allocsad63db63 != nil {
		x.allocsad63db63.(*cgoAllocMap).Free()
		x.refad63db63 = nil
	}
}

// NewCommandTextRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCommandTextRef(ref unsafe.Pointer) *CommandText {
	if ref == nil {
		return nil
	}
	obj := new(CommandText)
	obj.refad63db63 = (*C.struct_nk_command_text)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CommandText) PassRef() (*C.struct_nk_command_text, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refad63db63 != nil {
		return x.refad63db63, nil
	}
	memad63db63 := allocStructNkCommandTextMemory(1)
	refad63db63 := (*C.struct_nk_command_text)(memad63db63)
	allocsad63db63 := new(cgoAllocMap)
	var cheader_allocs *cgoAllocMap
	refad63db63.header, cheader_allocs = x.Header.PassValue()
	allocsad63db63.Borrow(cheader_allocs)

	var cfont_allocs *cgoAllocMap
	refad63db63.font, cfont_allocs = unpackSUserFont(x.Font)
	allocsad63db63.Borrow(cfont_allocs)

	var cbackground_allocs *cgoAllocMap
	refad63db63.background, cbackground_allocs = x.Background.PassValue()
	allocsad63db63.Borrow(cbackground_allocs)

	var cforeground_allocs *cgoAllocMap
	refad63db63.foreground, cforeground_allocs = x.Foreground.PassValue()
	allocsad63db63.Borrow(cforeground_allocs)

	var cx_allocs *cgoAllocMap
	refad63db63.x, cx_allocs = (C.short)(x.X), cgoAllocsUnknown
	allocsad63db63.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	refad63db63.y, cy_allocs = (C.short)(x.Y), cgoAllocsUnknown
	allocsad63db63.Borrow(cy_allocs)

	var cw_allocs *cgoAllocMap
	refad63db63.w, cw_allocs = (C.ushort)(x.W), cgoAllocsUnknown
	allocsad63db63.Borrow(cw_allocs)

	var ch_allocs *cgoAllocMap
	refad63db63.h, ch_allocs = (C.ushort)(x.H), cgoAllocsUnknown
	allocsad63db63.Borrow(ch_allocs)

	var cheight_allocs *cgoAllocMap
	refad63db63.height, cheight_allocs = (C.float)(x.Height), cgoAllocsUnknown
	allocsad63db63.Borrow(cheight_allocs)

	var clength_allocs *cgoAllocMap
	refad63db63.length, clength_allocs = (C.int)(x.Length), cgoAllocsUnknown
	allocsad63db63.Borrow(clength_allocs)

	var cstring_allocs *cgoAllocMap
	refad63db63.string, cstring_allocs = *(*[1]C.char)(unsafe.Pointer(&x.String)), cgoAllocsUnknown
	allocsad63db63.Borrow(cstring_allocs)

	x.refad63db63 = refad63db63
	x.allocsad63db63 = allocsad63db63
	return refad63db63, allocsad63db63

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CommandText) PassValue() (C.struct_nk_command_text, *cgoAllocMap) {
	if x.refad63db63 != nil {
		return *x.refad63db63, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CommandText) Deref() {
	if x.refad63db63 == nil {
		return
	}
	x.Header = *NewCommandRef(unsafe.Pointer(&x.refad63db63.header))
	packSUserFont(x.Font, x.refad63db63.font)
	x.Background = *NewColorRef(unsafe.Pointer(&x.refad63db63.background))
	x.Foreground = *NewColorRef(unsafe.Pointer(&x.refad63db63.foreground))
	x.X = (int16)(x.refad63db63.x)
	x.Y = (int16)(x.refad63db63.y)
	x.W = (uint16)(x.refad63db63.w)
	x.H = (uint16)(x.refad63db63.h)
	x.Height = (float32)(x.refad63db63.height)
	x.Length = (int32)(x.refad63db63.length)
	x.String = *(*[1]byte)(unsafe.Pointer(&x.refad63db63.string))
}

// allocStructNkPropertyStateMemory allocates memory for type C.struct_nk_property_state in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkPropertyStateMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkPropertyStateValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkPropertyStateValue = unsafe.Sizeof([1]C.struct_nk_property_state{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PropertyState) Ref() *C.struct_nk_property_state {
	if x == nil {
		return nil
	}
	return x.ref491b08a7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PropertyState) Free() {
	if x != nil && x.allocs491b08a7 != nil {
		x.allocs491b08a7.(*cgoAllocMap).Free()
		x.ref491b08a7 = nil
	}
}

// NewPropertyStateRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPropertyStateRef(ref unsafe.Pointer) *PropertyState {
	if ref == nil {
		return nil
	}
	obj := new(PropertyState)
	obj.ref491b08a7 = (*C.struct_nk_property_state)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PropertyState) PassRef() (*C.struct_nk_property_state, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref491b08a7 != nil {
		return x.ref491b08a7, nil
	}
	mem491b08a7 := allocStructNkPropertyStateMemory(1)
	ref491b08a7 := (*C.struct_nk_property_state)(mem491b08a7)
	allocs491b08a7 := new(cgoAllocMap)
	var cactive_allocs *cgoAllocMap
	ref491b08a7.active, cactive_allocs = (C.int)(x.Active), cgoAllocsUnknown
	allocs491b08a7.Borrow(cactive_allocs)

	var cprev_allocs *cgoAllocMap
	ref491b08a7.prev, cprev_allocs = (C.int)(x.Prev), cgoAllocsUnknown
	allocs491b08a7.Borrow(cprev_allocs)

	var cbuffer_allocs *cgoAllocMap
	ref491b08a7.buffer, cbuffer_allocs = *(*[64]C.char)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocs491b08a7.Borrow(cbuffer_allocs)

	var clength_allocs *cgoAllocMap
	ref491b08a7.length, clength_allocs = (C.int)(x.Length), cgoAllocsUnknown
	allocs491b08a7.Borrow(clength_allocs)

	var ccursor_allocs *cgoAllocMap
	ref491b08a7.cursor, ccursor_allocs = (C.int)(x.Cursor), cgoAllocsUnknown
	allocs491b08a7.Borrow(ccursor_allocs)

	var cname_allocs *cgoAllocMap
	ref491b08a7.name, cname_allocs = (C.nk_hash)(x.Name), cgoAllocsUnknown
	allocs491b08a7.Borrow(cname_allocs)

	var cseq_allocs *cgoAllocMap
	ref491b08a7.seq, cseq_allocs = (C.uint)(x.Seq), cgoAllocsUnknown
	allocs491b08a7.Borrow(cseq_allocs)

	var cold_allocs *cgoAllocMap
	ref491b08a7.old, cold_allocs = (C.uint)(x.Old), cgoAllocsUnknown
	allocs491b08a7.Borrow(cold_allocs)

	var cstate_allocs *cgoAllocMap
	ref491b08a7.state, cstate_allocs = (C.int)(x.State), cgoAllocsUnknown
	allocs491b08a7.Borrow(cstate_allocs)

	x.ref491b08a7 = ref491b08a7
	x.allocs491b08a7 = allocs491b08a7
	return ref491b08a7, allocs491b08a7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PropertyState) PassValue() (C.struct_nk_property_state, *cgoAllocMap) {
	if x.ref491b08a7 != nil {
		return *x.ref491b08a7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PropertyState) Deref() {
	if x.ref491b08a7 == nil {
		return
	}
	x.Active = (int32)(x.ref491b08a7.active)
	x.Prev = (int32)(x.ref491b08a7.prev)
	x.Buffer = *(*[64]byte)(unsafe.Pointer(&x.ref491b08a7.buffer))
	x.Length = (int32)(x.ref491b08a7.length)
	x.Cursor = (int32)(x.ref491b08a7.cursor)
	x.Name = (Hash)(x.ref491b08a7.name)
	x.Seq = (uint32)(x.ref491b08a7.seq)
	x.Old = (uint32)(x.ref491b08a7.old)
	x.State = (int32)(x.ref491b08a7.state)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *UserFont) Ref() *C.struct_nk_user_font {
	if x == nil {
		return nil
	}
	return x.ref738ce62e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *UserFont) Free() {
	if x != nil && x.allocs738ce62e != nil {
		x.allocs738ce62e.(*cgoAllocMap).Free()
		x.ref738ce62e = nil
	}
}

// NewUserFontRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewUserFontRef(ref unsafe.Pointer) *UserFont {
	if ref == nil {
		return nil
	}
	obj := new(UserFont)
	obj.ref738ce62e = (*C.struct_nk_user_font)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *UserFont) PassRef() (*C.struct_nk_user_font, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref738ce62e != nil {
		return x.ref738ce62e, nil
	}
	mem738ce62e := allocStructNkUserFontMemory(1)
	ref738ce62e := (*C.struct_nk_user_font)(mem738ce62e)
	allocs738ce62e := new(cgoAllocMap)
	var cuserdata_allocs *cgoAllocMap
	ref738ce62e.userdata, cuserdata_allocs = *(*C.nk_handle)(unsafe.Pointer(&x.Userdata)), cgoAllocsUnknown
	allocs738ce62e.Borrow(cuserdata_allocs)

	var cheight_allocs *cgoAllocMap
	ref738ce62e.height, cheight_allocs = (C.float)(x.Height), cgoAllocsUnknown
	allocs738ce62e.Borrow(cheight_allocs)

	var cwidth_allocs *cgoAllocMap
	ref738ce62e.width, cwidth_allocs = x.Width.PassValue()
	allocs738ce62e.Borrow(cwidth_allocs)

	x.ref738ce62e = ref738ce62e
	x.allocs738ce62e = allocs738ce62e
	return ref738ce62e, allocs738ce62e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x UserFont) PassValue() (C.struct_nk_user_font, *cgoAllocMap) {
	if x.ref738ce62e != nil {
		return *x.ref738ce62e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *UserFont) Deref() {
	if x.ref738ce62e == nil {
		return
	}
	x.Userdata = *(*Handle)(unsafe.Pointer(&x.ref738ce62e.userdata))
	x.Height = (float32)(x.ref738ce62e.height)
	// x.Width is a callback func
}

// allocStructNkCommandLineMemory allocates memory for type C.struct_nk_command_line in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkCommandLineMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkCommandLineValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkCommandLineValue = unsafe.Sizeof([1]C.struct_nk_command_line{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CommandLine) Ref() *C.struct_nk_command_line {
	if x == nil {
		return nil
	}
	return x.ref47fcc852
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CommandLine) Free() {
	if x != nil && x.allocs47fcc852 != nil {
		x.allocs47fcc852.(*cgoAllocMap).Free()
		x.ref47fcc852 = nil
	}
}

// NewCommandLineRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCommandLineRef(ref unsafe.Pointer) *CommandLine {
	if ref == nil {
		return nil
	}
	obj := new(CommandLine)
	obj.ref47fcc852 = (*C.struct_nk_command_line)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CommandLine) PassRef() (*C.struct_nk_command_line, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref47fcc852 != nil {
		return x.ref47fcc852, nil
	}
	mem47fcc852 := allocStructNkCommandLineMemory(1)
	ref47fcc852 := (*C.struct_nk_command_line)(mem47fcc852)
	allocs47fcc852 := new(cgoAllocMap)
	var cheader_allocs *cgoAllocMap
	ref47fcc852.header, cheader_allocs = x.Header.PassValue()
	allocs47fcc852.Borrow(cheader_allocs)

	var cline_thickness_allocs *cgoAllocMap
	ref47fcc852.line_thickness, cline_thickness_allocs = (C.ushort)(x.LineThickness), cgoAllocsUnknown
	allocs47fcc852.Borrow(cline_thickness_allocs)

	var cbegin_allocs *cgoAllocMap
	ref47fcc852.begin, cbegin_allocs = x.Begin.PassValue()
	allocs47fcc852.Borrow(cbegin_allocs)

	var cend_allocs *cgoAllocMap
	ref47fcc852.end, cend_allocs = x.End.PassValue()
	allocs47fcc852.Borrow(cend_allocs)

	var ccolor_allocs *cgoAllocMap
	ref47fcc852.color, ccolor_allocs = x.Color.PassValue()
	allocs47fcc852.Borrow(ccolor_allocs)

	x.ref47fcc852 = ref47fcc852
	x.allocs47fcc852 = allocs47fcc852
	return ref47fcc852, allocs47fcc852

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CommandLine) PassValue() (C.struct_nk_command_line, *cgoAllocMap) {
	if x.ref47fcc852 != nil {
		return *x.ref47fcc852, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CommandLine) Deref() {
	if x.ref47fcc852 == nil {
		return
	}
	x.Header = *NewCommandRef(unsafe.Pointer(&x.ref47fcc852.header))
	x.LineThickness = (uint16)(x.ref47fcc852.line_thickness)
	x.Begin = *NewVec2iRef(unsafe.Pointer(&x.ref47fcc852.begin))
	x.End = *NewVec2iRef(unsafe.Pointer(&x.ref47fcc852.end))
	x.Color = *NewColorRef(unsafe.Pointer(&x.ref47fcc852.color))
}

// unpackArgSContext transforms a sliced Go data structure into plain C format.
func unpackArgSContext(x []Context) (unpacked *C.struct_nk_context, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.struct_nk_context) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocStructNkContextMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_nk_context)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_nk_context)(unsafe.Pointer(h.Data))
	return
}

// packSContext reads sliced Go data structure out from plain C format.
func packSContext(v []Context, ptr0 *C.struct_nk_context) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStructNkContextValue]C.struct_nk_context)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewContextRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSUserFont transforms a sliced Go data structure into plain C format.
func unpackArgSUserFont(x []UserFont) (unpacked *C.struct_nk_user_font, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.struct_nk_user_font) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocStructNkUserFontMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_nk_user_font)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_nk_user_font)(unsafe.Pointer(h.Data))
	return
}

// unpackArgSBuffer transforms a sliced Go data structure into plain C format.
func unpackArgSBuffer(x []Buffer) (unpacked *C.struct_nk_buffer, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.struct_nk_buffer) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocStructNkBufferMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_nk_buffer)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_nk_buffer)(unsafe.Pointer(h.Data))
	return
}

// unpackArgSPanel transforms a sliced Go data structure into plain C format.
func unpackArgSPanel(x []Panel) (unpacked *C.struct_nk_panel, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.struct_nk_panel) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocStructNkPanelMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_nk_panel)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_nk_panel)(unsafe.Pointer(h.Data))
	return
}

// unpackPCharString represents the data from Go string as *C.char and avoids copying.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	h := (*stringHeader)(unsafe.Pointer(&str))
	return (*C.char)(unsafe.Pointer(h.Data)), cgoAllocsUnknown
}

// unpackArgSColor transforms a sliced Go data structure into plain C format.
func unpackArgSColor(x []Color) (unpacked *C.struct_nk_color, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.struct_nk_color) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocStructNkColorMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_nk_color)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_nk_color)(unsafe.Pointer(h.Data))
	return
}

// unpackArgSTextEdit transforms a sliced Go data structure into plain C format.
func unpackArgSTextEdit(x []TextEdit) (unpacked *C.struct_nk_text_edit, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.struct_nk_text_edit) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocStructNkTextEditMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_nk_text_edit)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_nk_text_edit)(unsafe.Pointer(h.Data))
	return
}

// allocPCharMemory allocates memory for type *C.char in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPCharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPCharValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPCharValue = unsafe.Sizeof([1]*C.char{})

// unpackArgSString transforms a sliced Go data structure into plain C format.
func unpackArgSString(x []string) (unpacked **C.char, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.char) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPCharMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.char)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = unpackPCharString(x[i0])
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.char)(unsafe.Pointer(h.Data))
	return
}

// packSString reads sliced Go data structure out from plain C format.
func packSString(v []string, ptr0 **C.char) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.char)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = packPCharString(ptr1)
	}
}

// unpackArgSCursor transforms a sliced Go data structure into plain C format.
func unpackArgSCursor(x []Cursor) (unpacked *C.struct_nk_cursor, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.struct_nk_cursor) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocStructNkCursorMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_nk_cursor)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_nk_cursor)(unsafe.Pointer(h.Data))
	return
}

// unpackArgSVec2 transforms a sliced Go data structure into plain C format.
func unpackArgSVec2(x []Vec2) (unpacked *C.struct_nk_vec2, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.struct_nk_vec2) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocStructNkVec2Memory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_nk_vec2)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_nk_vec2)(unsafe.Pointer(h.Data))
	return
}

// unpackArgSStyleItem transforms a sliced Go data structure into plain C format.
func unpackArgSStyleItem(x []StyleItem) (unpacked *C.struct_nk_style_item, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.struct_nk_style_item) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocStructNkStyleItemMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_nk_style_item)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_nk_style_item)(unsafe.Pointer(h.Data))
	return
}

// unpackArgSRect transforms a sliced Go data structure into plain C format.
func unpackArgSRect(x []Rect) (unpacked *C.struct_nk_rect, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.struct_nk_rect) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocStructNkRectMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_nk_rect)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_nk_rect)(unsafe.Pointer(h.Data))
	return
}

// packSRect reads sliced Go data structure out from plain C format.
func packSRect(v []Rect, ptr0 *C.struct_nk_rect) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStructNkRectValue]C.struct_nk_rect)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewRectRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSImage transforms a sliced Go data structure into plain C format.
func unpackArgSImage(x []Image) (unpacked *C.struct_nk_image, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.struct_nk_image) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocStructNkImageMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_nk_image)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_nk_image)(unsafe.Pointer(h.Data))
	return
}

// packSImage reads sliced Go data structure out from plain C format.
func packSImage(v []Image, ptr0 *C.struct_nk_image) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStructNkImageValue]C.struct_nk_image)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewImageRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSMemoryStatus transforms a sliced Go data structure into plain C format.
func unpackArgSMemoryStatus(x []MemoryStatus) (unpacked *C.struct_nk_memory_status, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.struct_nk_memory_status) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocStructNkMemoryStatusMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_nk_memory_status)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_nk_memory_status)(unsafe.Pointer(h.Data))
	return
}

// packSMemoryStatus reads sliced Go data structure out from plain C format.
func packSMemoryStatus(v []MemoryStatus, ptr0 *C.struct_nk_memory_status) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStructNkMemoryStatusValue]C.struct_nk_memory_status)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewMemoryStatusRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSCommandBuffer transforms a sliced Go data structure into plain C format.
func unpackArgSCommandBuffer(x []CommandBuffer) (unpacked *C.struct_nk_command_buffer, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.struct_nk_command_buffer) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocStructNkCommandBufferMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_nk_command_buffer)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_nk_command_buffer)(unsafe.Pointer(h.Data))
	return
}

// unpackArgSCommand transforms a sliced Go data structure into plain C format.
func unpackArgSCommand(x []Command) (unpacked *C.struct_nk_command, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.struct_nk_command) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocStructNkCommandMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_nk_command)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_nk_command)(unsafe.Pointer(h.Data))
	return
}

// packSCommand reads sliced Go data structure out from plain C format.
func packSCommand(v []Command, ptr0 *C.struct_nk_command) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStructNkCommandValue]C.struct_nk_command)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewCommandRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSInput transforms a sliced Go data structure into plain C format.
func unpackArgSInput(x []Input) (unpacked *C.struct_nk_input, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.struct_nk_input) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocStructNkInputMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_nk_input)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_nk_input)(unsafe.Pointer(h.Data))
	return
}

// packSInput reads sliced Go data structure out from plain C format.
func packSInput(v []Input, ptr0 *C.struct_nk_input) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStructNkInputValue]C.struct_nk_input)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewInputRef(unsafe.Pointer(&ptr1))
	}
}
